<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>软件体系结构 | 早早起床，拥抱太阳</title><meta name="author" content="如风"><meta name="copyright" content="如风"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="考点 题型  选择（15） 填空（10） 简答 综合  记忆内容 工厂方法   抽象工厂   具体工厂   模式的优缺点 模型用来干什么的 单例模式 核心模型   五个元素   构件   连接件   端口   4+1视图  有哪五个视图，是从什么角度来的  典型的软件体系风格  每种体系结构的元素（构件-连接件） 特点  只了解（主被动过滤器定义） 基于事件的隐式调用 优缺点 定义 分层体系结构">
<meta property="og:type" content="article">
<meta property="og:title" content="软件体系结构">
<meta property="og:url" content="https://blog.liyifan001.top/2023/06/06/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/index.html">
<meta property="og:site_name" content="早早起床，拥抱太阳">
<meta property="og:description" content="考点 题型  选择（15） 填空（10） 简答 综合  记忆内容 工厂方法   抽象工厂   具体工厂   模式的优缺点 模型用来干什么的 单例模式 核心模型   五个元素   构件   连接件   端口   4+1视图  有哪五个视图，是从什么角度来的  典型的软件体系风格  每种体系结构的元素（构件-连接件） 特点  只了解（主被动过滤器定义） 基于事件的隐式调用 优缺点 定义 分层体系结构">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/1668325987314FA3E3F866C40A665F46EF56BBD227395.png">
<meta property="article:published_time" content="2023-06-06T10:05:52.000Z">
<meta property="article:modified_time" content="2023-06-11T08:58:02.855Z">
<meta property="article:author" content="如风">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/1668325987314FA3E3F866C40A665F46EF56BBD227395.png"><link rel="shortcut icon" href="/images/favicon.ico"><link rel="canonical" href="https://blog.liyifan001.top/2023/06/06/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 如风","link":"链接: ","source":"来源: 早早起床，拥抱太阳","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '软件体系结构',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-06-11 16:58:02'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/1668273103133D8802D069515E0A42BC91FDE752B8A5C.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">34</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">32</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/1668325987314FA3E3F866C40A665F46EF56BBD227395.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">早早起床，拥抱太阳</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">软件体系结构</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-06T10:05:52.000Z" title="发表于 2023-06-06 18:05:52">2023-06-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-11T08:58:02.855Z" title="更新于 2023-06-11 16:58:02">2023-06-11</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">14.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>43分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="软件体系结构"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>考点</h1>
<h2 id="题型">题型</h2>
<blockquote>
<p>选择（15）</p>
<p>填空（10）</p>
<p>简答</p>
<p>综合</p>
</blockquote>
<h2 id="记忆内容">记忆内容</h2>
<p>工厂方法</p>
<ul>
<li>
<p>抽象工厂</p>
</li>
<li>
<p>具体工厂</p>
</li>
</ul>
<p>模式的优缺点</p>
<p>模型用来干什么的</p>
<p>单例模式</p>
<p>核心模型</p>
<ul>
<li>
<p>五个元素</p>
</li>
<li>
<p>构件</p>
</li>
<li>
<p>连接件</p>
</li>
<li>
<p>端口</p>
</li>
</ul>
<p>4+1视图</p>
<ul>
<li>有哪五个视图，是从什么角度来的</li>
</ul>
<p>典型的软件体系风格</p>
<ul>
<li>每种体系结构的元素（构件-连接件）</li>
<li>特点</li>
</ul>
<p>只了解（主被动过滤器定义）</p>
<p>基于事件的隐式调用</p>
<p>优缺点</p>
<p>定义</p>
<p>分层体系结构</p>
<ul>
<li>特点</li>
</ul>
<p>仓储结构</p>
<ul>
<li>构件-连接件</li>
<li>主动被动的概念</li>
</ul>
<p>解决一个问题判断用到什么体系结构</p>
<p>不考框架，但综合体最好结合框架。</p>
<h1>知识点</h1>
<h2 id="课程简介">课程简介</h2>
<p>High-level Design<br>
宏观结构设计</p>
<p>Software Architecture</p>
<p>软件架构</p>
<ul>
<li>软件体系结构建模</li>
<li>体系结构风格</li>
</ul>
<p>Low-level Design<br>
微观结构设计</p>
<p>Design Patterns<br>
设计模式</p>
<ul>
<li>面向对象设计原则</li>
<li>典型设计模式</li>
</ul>
<h2 id="综观软件架构">综观软件架构</h2>
<p>软件架构 vs.设计模式</p>
<blockquote>
<p>在软件架构设计时,根据抽象程度从高到低可划分为三个层次的模式：</p>
<ol>
<li>架构模式(Architectural Pattern)、</li>
<li>设计模式(Design Pattern)、</li>
<li>代码模式(Coding Pattern)。<br>
架构模式是一个系统的高层次策略，涉及到大尺度的组件以及整体性质。架构模式的好坏可以影响到总体布局和框架性结构。<br>
设计模式是中等尺度的结构策略。这些中等尺度的结构实现了一些大尺度组件的行为和它们之间的关系。模式的好坏不会影响到系统的总体布局和总体框架。设计模式定义出子系统或组件的微观结构。<br>
代码模式（或成例）是特定的范例和与特定语言有关的编程技巧。代码模式的好坏会影响到一个中等尺度组件的内部、外部的结构或行为的底层细节，但不会影响到一个部件或子系统的中等尺度的结构，更不会影响到系统的总体布局和大尺度框架</li>
</ol>
</blockquote>
<p>框架</p>
<blockquote>
<p>软件框架是面向领域（如ERP、计算领域等）的、可复用的“半成品”软件，它实现了该领域的共性部分，并提供了一些定义良好的可变点以保证灵活性和可扩展性。也就是说软件框架是领域分析结果的软件化，是领域内最终应用的模板。</p>
<p>框架是可被应用开发者定制的应用骨架。<font color='red'>框架实现了某应用领域通用完备功能</font>（除去特殊应用的部分）的底层服务。使用这种框架的编程人员可以在一个通用功能已经实现的基础上开始具体的系统开发。</p>
<p>框架具体表现为一组抽象类（构件）以及其实例（对象）之间的相互作用方式。框架描述了系统中所有的构件、构件之间的交互、连接件以及如何将构件和连接件结合的规则。</p>
<p>软件框架的一个显著特点是<font color='green'>逆向控制</font>（Inversion of Control），应用开发人员只要将应用特定的模块绑定到框架内，框架则根据自己的交互机制自动调用该模块，控制由框架负责。</p>
</blockquote>
<p>以子程序和类为单位的软件复用出现了很多的不足之处：</p>
<blockquote>
<p>（1）子程序的库越来越庞大以至于其使用人员难以掌握</p>
<p>（2）大多数类的粒度很小，其自身不能完成所有有用的功能</p>
<p>正是因为这些原因，使得人们在复用中将一组类（模块）作为一个整体来考虑，由此出现了软件框架。</p>
</blockquote>
<p>框架Framework分类</p>
<blockquote>
<p>软件框架可分为三大类：</p>
<ul>
<li>
<p>基础设施框架：用于简化系统级软件的开发，如操作系统、用户界面、语言处理等，典型例子为面向对象的、跨平台的、开放源码的网络编程基础设施框架ACE，MacApp, MFC等。</p>
</li>
<li>
<p>中间件框架：用于组装分布式应用和构件，典型例子为DCOM, RMI, CORBA等。</p>
</li>
<li>
<p>应用框架：使用最广泛。如Web应用框架Eclipse ，Struts等，以及用于各类应用领域的应用框架等。</p>
</li>
</ul>
</blockquote>
<p>框架 vs.软件架构</p>
<ul>
<li>框架比架构更具体，更偏重于技术。</li>
<li>确定框架后，软件体系结构也随之确定。</li>
<li>对于<font color='red'>同一软件体系结构</font>（比如Web开发中的MVC），可以通过<font color='red'>多种框架来实现</font>。</li>
</ul>
<p>在软件开发中，“框架”（framework）和&quot;架构&quot;（architecture）是两个相关但不同的概念。</p>
<blockquote>
<p><font color='cornflowerblue'>框架（Framework）：</font></p>
<p>框架是一个软件开发的基础结构，它提供了一组通用的工具、类库、函数和规范，用于支持特定类型的应用程序或软件系统的开发。框架通常包含了解决特定问题的重要组件和功能模块，开发者可以在其基础上构建自己的应用程序。<br>
框架一般具有一定的约定和规范，开发者需要按照框架提供的结构和设计原则进行开发。框架可以提供一致的开发环境和编程模型，简化了开发过程，提高了开发效率。<br>
一些常见的框架包括Web开发中的Django、Ruby on Rails，前端开发中的React、Angular，以及移动应用开发中的Flutter、React Native等。<br>
<font color='cornflowerblue'>架构（Architecture）：</font></p>
<p>架构是指软件系统或应用程序的整体设计和组织结构。它关注的是系统各个组件之间的关系、功能模块的划分、数据流程和通信方式等高层次的设计决策。<br>
架构决定了系统的整体结构、组件的分布和交互方式，以及系统的性能、可扩展性、可维护性等重要特征。<br>
良好的架构能够确保系统的稳定性、可靠性和可维护性，并且有助于系统的演化和扩展。<br>
一些常见的软件架构模式包括分层架构、客户端-服务器架构、微服务架构、事件驱动架构等。<br>
简而言之，框架是一个具体的开发工具和平台，提供了一系列的工具和函数库，帮助开发者更快速地构建应用程序。而架构则是对整个系统的高层次设计，关注系统组件的组织和交互，以及系统的性能、可维护性等方面。框架是构建在架构之上的具体实现。</p>
</blockquote>
<p>框架 vs.设计模式</p>
<blockquote>
<p>设计模式是对在某种环境中反复出现的问题以及解决该问题的方案的描述，<font color='green'>它比框架更抽象</font>；框架可以用代码表示，也能直接执行或复用，而对模式而言只有实例才能用代码表示;<br>
设计模式是比框架更小的元素，一个框架中往往含有一个或多个设计模式，框架总是针对某一特定应用领域，但同一模式却可适用于各种应用。<br>
<font color='cornflowerblue'>框架是软件，而设计模式是软件策略。</font></p>
</blockquote>
<h2 id="软件体系结构概述">软件体系结构概述</h2>
<p>软件体系结构基本组成元素:</p>
<ul>
<li>the constituent elements ― Component 构件</li>
<li>the interaction rules/mechanism ― Connector 连接件</li>
</ul>
<blockquote>
<p>Software Architecture Design = Decomposition + Composition<br>
软件架构设计-分与合的艺术</p>
<p>系统分解建立在对系统需求理解的基础上<br>
系统构件的组合方式则主要侧重于满足系统的<font color='cornflowerblue'>非功能性需求</font></p>
</blockquote>
<p>构件/组件 Component：系统的逻辑与功能结构组成单元</p>
<p>连接件  Connector：构件间交互的机制和规则</p>
<h3 id="font-color-red-软件体系结构核心模型-font"><font color='red'>软件体系结构核心模型</font></h3>
<ol>
<li>Component 构件</li>
<li>Connector 连接件</li>
<li>Configuration 配置</li>
<li>Port 端口</li>
<li>Role 角色</li>
</ol>
<p><font color='cornflowerblue'>构件 、连接件和配置是组成核心模型的最基本元素。</font></p>
<p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16859644759101685964475765.png" alt=""></p>
<h4 id="构件解析">构件解析</h4>
<ul>
<li>构件是具有某种功能的可重用的软件模板单元，表示了系统中主要的计算元素和数据存储。</li>
<li>构件是一个抽象概念，与具体实现技术无关。</li>
<li>原子构件不可再分；复合构件可分解为其他复合构件和原子构件。</li>
<li>构件通过其接口与外部环境交互，接口由一组**端口  （Port）**组成。</li>
<li>每个端口表示构件和外部环境的交互作用点。如：包构件的端口指包外部可见对象的接口或属性，而模块构件的端口则是指模块中申明的外部过程或函数以及数据结构与变量。</li>
</ul>
<p><strong>典型构件</strong></p>
<table>
<thead>
<tr>
<th>构件类型</th>
<th>构件支持的相互作用类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>模块(Module)</td>
<td>过程调用、数据共享</td>
</tr>
<tr>
<td>对象(Object)</td>
<td>方法调用</td>
</tr>
<tr>
<td>中间件(Middleware)</td>
<td>消息传递、通讯协议</td>
</tr>
<tr>
<td>过程/进程(Process)</td>
<td>消息传递、远程调用、  通讯协议、同步</td>
</tr>
<tr>
<td>数据文件(Datafile)</td>
<td>读写</td>
</tr>
<tr>
<td>数据库(Database)</td>
<td>模式、查询语言</td>
</tr>
<tr>
<td>文档(Document)</td>
<td>共享变量访问</td>
</tr>
</tbody>
</table>
<p>软件重用与构件技术</p>
<p>程序代码片断的复用       分析和设计的复用       标准构件</p>
<p>如何获取构件？</p>
<blockquote>
<ul>
<li>
<p>从现有构件中直接获得或作适应性修改;</p>
</li>
<li>
<p>从遗留工程提取可重用构件;</p>
</li>
<li>
<p>购买商业构件;</p>
</li>
<li>
<p>开发新构件</p>
</li>
</ul>
</blockquote>
<p>面向对象技术中的构件</p>
<p>构件≥对象<br>
构件可以是被封装的对象类、类树、功能模块、软件框架、文档、分析件、设计模式等；<br>
构件作为一个逻辑紧密的程序代码包的形式出现，有良好的接口</p>
<p>构件的组织形式</p>
<ul>
<li>通过包</li>
<li>通过构件之间的交互关系</li>
</ul>
<p>包/命名空间：</p>
<blockquote>
<p>包（Package）或名字空间（Namespace）是对象的结构化组织，将一些相关的类集合为一个包，形成高内聚，低耦合的类集合；<br>
系统的包结构或名字空间的划分体现了软件的一种宏观静态结构。</p>
</blockquote>
<p>基于MVC模式的应用框架包含3种组件：<font color='red'>Model，View，Controller</font></p>
<h4 id="连接件">连接件</h4>
<p>构件间相互<font color='red'>交互</font>的机制或规则</p>
<blockquote>
<ul>
<li>机制：是指连接件的具体实现形式：如过程调用、共享存储区、网络</li>
<li>规则：是指构件使用连接件应遵循的规范。如对过程调用的接口参数形式、共享存储区的数据存储结构（队列、堆栈等）、网络协议（TCP/IP，HTTP等）。</li>
</ul>
</blockquote>
<p>角色：连接件的交互参与者</p>
<ul>
<li>通过连接件实现交互时，构件在交互过程中体现为不同的角色。<br>
如RPC: 过程调用的调用方和被调用方<br>
如C/S连接：客户方和服务器方<br>
一个连接件所涉及的角色可以是二元的，也可以是多元的。<br>
如：过程调用涉及的角色是二元的：调用者（caller）和被调用者（callee）<br>
消息队列涉及的角色是多元的：消息源（source）和多个消息接收者/处理者（receivers/handlers）</li>
</ul>
<p>单向连接和双向连接</p>
<p>同步/异步连接</p>
<blockquote>
<p>GPT</p>
<p>在软件工程中，框架构件（Framework Components）和连接件（Connectors）是两个不同的概念，用于描述软件体系结构中的不同角色和功能。</p>
<p>框架构件（Framework Components）：</p>
<p>框架构件是指在软件框架中提供基础结构和核心功能的组件。框架构件是框架的核心部分，它们提供了一系列的通用工具、类库、函数和规范，用于支持特定类型的应用程序的开发。<br>
框架构件通常具有一定的约定和规范，开发者需要按照框架提供的结构和设计原则进行开发。它们可以包括用于处理输入输出、网络通信、数据库访问、用户界面等功能的组件。<br>
框架构件提供了一致的开发环境和编程模型，以简化开发过程并提高开发效率。开发者可以在框架的基础上构建自己的应用程序。<br>
连接件（Connectors）：</p>
<p>连接件是指在软件体系结构中用于连接和协调系统组件之间通信和交互的组件。连接件提供了一种通用的机制，使得不同的组件可以通过定义的接口进行交互。<br>
连接件可以包括消息传递机制、共享内存、远程调用、事件驱动等。它们定义了组件之间的通信规则和交互方式，帮助不同组件之间实现相互作用和协作。<br>
连接件的设计可以基于特定的通信协议或模式，如发布-订阅、请求-响应、观察者等。通过连接件，组件之间可以进行数据传输、事件触发和协同处理。</p>
<p>总结来说，框架构件是软件框架的核心组件，提供基础结构和核心功能，用于支持应用程序的开发。连接件是用于连接和协调系统组件之间通信和交互的组件，提供通用的机制和规则，使组件可以相互作用和协作。它们在软件体系结构中扮演不同的角色，共同促进软件的模块化、可重用性和灵活性。</p>
</blockquote>
<h4 id="配置">配置</h4>
<p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16859658916701685965891226.png" alt=""></p>
<p>配置表示构件和连接件的拓扑逻辑和约束，包括：</p>
<ul>
<li>构件的端口与连接件的角色之间的关联关系；</li>
<li>复合构件与其子构件的嵌套包含关系；</li>
</ul>
<h2 id="4-1视图（重要）">4+1视图（重要）</h2>
<p>“4+1”视图模型：<font color='red'>逻辑视图、开发视图、进程视图、物理视图、场景</font>。</p>
<p>软件架构为谁而设计？</p>
<ul>
<li>架构师要为客户负责，满足他们的业务目标和约束条件；</li>
<li>架构师要为用户负责，使他们关心的功能需求和运行期质量属性得以满足；</li>
<li>架构师必须顾及处于协作分工“下游”的开发人员；</li>
<li>架构师还必须考虑“周边”的管理人员，为他们进行分工管理、协调控制、评估监控等工作提供清晰的基础。</li>
</ul>
<p><font color='red'>软件架构视图 </font></p>
<blockquote>
<p>架构视图是对从某一视角或某一点上所看到的系统的简化描述，描述中涵盖了系统的某一特定方面，而省略了与此方面无关的实体。</p>
<p>架构要涵盖的内容和决策很多，采用&quot;分而治之&quot;的办法从不同视角分别设计；同时，也为软件架构的理解、交流和归档提供方便。</p>
</blockquote>
<p>多重视图方法，从根本上说是需求种类的复杂性所致。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16859663016641685966301335.png" alt=""></p>
<p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16859663236661685966322845.png" alt=""></p>
<p>非功能需求-常被忽视的一大类需求</p>
<blockquote>
<p>约束性需求既包括企业级的商业考虑，也包括最终用户级的实际情况；既包括具体技术的明确要求，又要考虑开发团队的真实状况。</p>
<p>约束性需求对架构设计影响很大，如受到&quot;项目预算有限&quot;的限制，架构师就不应选择昂贵的技术或中间件等，而考虑到开发人员分散在不同地点&quot;，就更应注重软件模块职责划分的合理性、松耦合性等等。</p>
</blockquote>
<p>运行期质量属性</p>
<p>主要指软件系统在运行期间表现出的质量水平。</p>
<blockquote>
<p>常见的运行期质量属性包括:<br>
(1)性能：软件系统及时提供相应服务的能力。具体包括速度、吞吐量和持续高速性这三方面的要求。<br>
(2)安全性：指软件系统同时兼顾向合法用户提供服务，又阻止非授权使用功能的能力。<br>
(3)易用性：软件系统易于使用的程度。<br>
(4)可用性：可用性与易用性不相同。可用性指系统长时间无故障运行的能力。<br>
(5)可伸缩性：当用户增加时，软件系统维持高服务质量的能力。<br>
(6)互操作性：指本软件系统与其他系统交换数据和相互调用服务的难易程度。<br>
(7)可靠性：软件系统在一定时间内无故障运行的能力。<br>
(8)健壮性：也称容错性，是指软件系统在异常情况仍能够正常运行的</p>
</blockquote>
<p>开发期质量属性</p>
<blockquote>
<p>开发期质量属性是开发人员最为关心的。要达到怎样的目标应根据项目的具体情况而定，过度设计会花费额外的代价。<br>
常见的开发期质量属性包括:<br>
(1)易理解性：是软件设计能被开发人员理解的难易程度。<br>
(2)可扩展性：为适应新需求或者需求变化，为软件增加功能和提升性能的能力。也称为灵活性。<br>
(3)可重用性<br>
(4)可测试性<br>
(5)可维护性<br>
(6)可移植性</p>
</blockquote>
<p>4+1视图模型   		Kruchten 1995<br>
<font color='red'>逻辑视图、进程视图、开发视图、物理视图+场景视图</font><br>
四视图体系结构 		Hofmeister et al. 2000<br>
概念视图、代码视图、模块视图、执行视图<br>
COMET			Hassan Gomaa 2011<br>
Collaborative Object Modeling and Architectural Design Method<br>
一种基于UML的软件建模和体系结构设计方法</p>
<p>“4+1”视图模型从5个不同的视角来描述软件体系结构:<br>
逻辑视角、进程视角、开发视角、物理视角和场景视角。<br>
每一个视角只关心系统的一个侧面，5个视角结合在一起反映系统的软件体系结构的完整内容。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16859665016661685966501446.png" alt=""></p>
<p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16859666176651685966617243.png" alt=""></p>
<p>4+1视图本身并没有一套严格的视图表示法。<br>
工程实践中，架构设计人员往往会采用各自不同的表示法。<br>
大型软件公司通常拥有自己的建模工具。</p>
<blockquote>
<p>Logic View（逻辑视图）：基于功能需求抽象，刻画系统的静态结构模型；<br>
Process View（进程视图）：刻画系统运行时的结构模型；<br>
Development View（开发视图）：考虑开发技术、过程与组织，刻画系统的开发管理结构模型；<br>
Physical View（物理视图）：逻辑视图中各功能构件在安装部署环境中的映射，刻画系统的安装部署结构模型；<br>
Scenarios View（场景视图）：从系统使用的角度对系统结构的描述。它反映的是在完成某个系统功能时，系统各功能构件间的交互关系。</p>
</blockquote>
<h3 id="逻辑视图">逻辑视图</h3>
<p>在面向对象技术中，可以用对象模型代表逻辑视图，用类图描述逻辑视图。</p>
<ul>
<li>构件：类、类服务、参数化类、类层次（包）</li>
<li>连接件：关联、包含聚集、使用、继承、实例化</li>
</ul>
<p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16859670196661685967018808.png" alt=""></p>
<p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16859671946691685967194496.png" alt=""></p>
<h3 id="开发视图">开发视图</h3>
<p>开发视图关注软件开发环境下实际模块的组织和管理，体现为软件模块、库、子系统和开发单元的结构化组织。<br>
开发视图要充分考虑软件实现的要求与约束，如软件开发技术要求、开发过程与组织形式、软件的复用性，以及技术与管理风险等因素。<br>
开发视图可采用层次结构，每一层为上层提供良好定义的接口，层次越低，通用性越好。<br>
构件：模块、子系统、层<br>
连接件：参照相关性、模块/过程调用</p>
<p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16859676386651685967638366.png" alt=""></p>
<p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16859677346701685967733911.png" alt=""></p>
<h3 id="进程视图">进程视图</h3>
<p>进程视图侧重系统的<font color='red'>运行特性</font>，关注<font color='red'>非功能性需求</font>（性能、可用性）。<br>
进程视图强调并发性、分布性、系统集成性和容错能力，为逻辑视图中的构件设计适合的进程/线程结构。它定义逻辑视图中的各个构件具体在进程/线程中的映射结构。<br>
构件：进程、简化进程、循环进程<br>
连接件：消息、远程过程调用（RPC）、双向消息、事件广播</p>
<p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16859678566651685967856244.png" alt=""></p>
<p>软件被划分为一系列单独的任务。任务是独立的控制线程，可以在处理节点上单独被调度。<br>
主要任务是可以唯一处理的架构元素；次要任务是由于实施原因而引入的局部附加任务（周期性活动、缓冲、暂停等等）。它们可以轻量线程来实施。 主要任务的通讯途径是良好定义的交互任务通信机制：基于消息的同步或异步通信服务、远程过程调用、事件广播等。次要任务则以会见或共享内存来通信。在同一过程或处理节点上，主要任务不应对它们的分配做出任何假定。<br>
所有的终端由单个的 Termal process 处理，其中 Termal process 由输入队列中的消息进行驱动。Controller 对象在组成控制过程三个任务之中的一项任务上执行：Low cycle rate task 扫描所有的非活动终端(200 ms)，将 High cycle rate task(10 ms)扫描清单中的终端激活，其中 High cycle rate task 检测任何重要的状态变化，将它们传递给 Main controller task，由它来对状态的变更进行解释,并通过向对应的终端发送消息来通信。这里 Controller 过程中的通信通过共享内存来实现。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16859679406671685967940117.png" alt=""></p>
<h3 id="物理视图">物理视图</h3>
<p>物理视图主要考虑如何<strong>把软件映射到硬件</strong>，它通常要考虑软件系统在计算物理节点与网络拓扑结构上的运行部署等问题。<br>
主要关注系统性能、可扩展性、可靠性等软件非功能性需求约束。<br>
构件：处理器、计算机、其它设备<br>
连接件：通信协议等</p>
<p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16859689086691685968908501.png" alt=""></p>
<p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16859689406701685968939742.png" alt=""></p>
<h3 id="场景视图">场景视图</h3>
<p>场景视图从<font color='red'>系统使用的角度</font>对系统结构进行描述。<br>
场景反映在完成一个系统功能时，系统各功能构件间的协作关系。<br>
场景处于中心位置，它使四个视图有机联系起来，从某种意义上说场景是最重要的需求抽象。</p>
<p>场景的表示法:</p>
<ul>
<li>文本、图形表示均可；</li>
<li>静态方面用用例图表现，动态方面用活动图、状态图、交互图表现。</li>
</ul>
<p>四种视图的元素通过数量比较少的一组重要场景进行无缝协同工作<br>
在某种意义上<font color='red'>场景是最重要的需求抽象</font>，它们的设计使用对象场景图和对象交互图来表示。<br>
该视图是其他视图的冗余（因此&quot;＋1&quot;），但它起到了两个作用：</p>
<ol>
<li>作为一项驱动因素来发现架构设计过程中的架构元素。</li>
<li>作为架构设计结束后的一项验证和说明功能，既以视图的角度来说明又作为架构原型测试的出发点。</li>
</ol>
<p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16859691936741685969192757.png" alt=""></p>
<p>案例2：</p>
<p><strong>邮件代发系统MailProxy</strong></p>
<p>有层次的切分决策过程：</p>
<p>用例视图+逻辑视图+物理视图  设计</p>
<p>问题描述：<br>
很多公司的客服系统都需要批量向客户发送邮件，MailProxy作为一款软件产品,其核心功能就是邮件代发。</p>
<p>MailProxy的基本功能:</p>
<ol>
<li>MailProxy和客户系统对接</li>
<li>通过对Mail Server系统的调度完成自动邮件代发</li>
<li>反馈发送结果给客户系统(含Log日志等)</li>
<li>提供灵活的规则设置等功能</li>
</ol>
<p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16859692936651685969293077.png" alt=""></p>
<p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16859693847461685969384667.png" alt=""></p>
<p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16859694056671685969405275.png" alt=""></p>
<p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16859694436651685969442805.png" alt=""></p>
<p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16859694586741685969458484.png" alt=""></p>
<p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16859694756711685969474956.png" alt=""></p>
<h2 id="架构风格与软件质量属性">架构风格与软件质量属性</h2>
<p>架构设计的目标</p>
<ul>
<li>通过对使用场景的深刻理解来建立业务需求和技术需求之间的“桥梁”</li>
<li>寻求最佳技术方案来实现业务需求</li>
<li>重点是识别对系统结构有重要影响的业务需求</li>
<li>降低技术方案业务风险</li>
<li>让系统具有足够的灵活性</li>
<li>解决质量指标要求之间的平衡</li>
<li>解决其他因素之间的冲突</li>
</ul>
<p>良好的架构设计</p>
<blockquote>
<p>一般特点：</p>
<p>o最大化的重用</p>
<p>o尽可能简单明了</p>
<p>o最灵活的拓展性</p>
</blockquote>
<p>展现系统的结构但是隐藏实现的细节<br>
满足所有的使用需求<br>
能解决系统相关人员（stakeholders）的各种顾虑<br>
很好地实现功能需求，同时也满足质量指标的要求</p>
<p>架构设计核心步骤</p>
<ul>
<li>明确架构设计的目的（objectives）</li>
<li>找出关键场景（key scenarios）</li>
<li>概略分析开发的应用 （overview）</li>
<li>识别“敏感点” （hotspots）</li>
<li>制定候选方案 （candidate solutions）</li>
</ul>
<p>体系结构风格Architectural Styles</p>
<p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16860409200791686040919858.png" alt=""></p>
<p>构架样式的类型</p>
<p>以数据为中心的构架<br>
数据集成——一个集中式的数据集与多个客户端进行通信<br>
数据流构架<br>
成批数据流；管道和过滤器<br>
虚拟组织架<br>
目标：可移植性<br>
模拟对象：模拟硬件不具备的功能或软件环境<br>
实例：java虚拟机(java的平台独立性)<br>
调用——返回构架<br>
目标：可更改性和可扩展性<br>
主——子程序（传统）；面向对象（类派生）；层次样式</p>
<p>独立组件构架<br>
由独立进程或对象组成，通过消息进行通信<br>
例：C/S模式<br>
异质构架<br>
多种构架样式的综合<br>
局部异质/层次异质/并行异质（同时符合几种样式）</p>
<h2 id="典型软件体系结构风格及其应用模式">典型软件体系结构风格及其应用模式</h2>
<p>Classic Software Architecture Styles&amp;Patterns</p>
<p>软件体系结构风格</p>
<blockquote>
<p>经过工程实践提炼总结得到，对某一类型或某一应用领域的软件系统具有普遍适用性或借鉴性的体系结构风格。</p>
<ul>
<li>每种体系结构风格包含对系统结构组成元素即构件的描述，以及构件间的组合机制的描述即连接件。</li>
<li>体系结构风格可以帮助我们快速分析与设计一个系统的体系结构，体现了一种系统体系结构的重用。</li>
<li>设计人员在选择一种风格时，可以根据每种风格的特性来进行抉择需要参照的系统体系结构。</li>
</ul>
</blockquote>
<p>在实际中，风格一般用于理论界，而工程界则偏爱于使用模式这一词。本课程中，我们用风格专指具有一般意义的体系结构，而用模式指一种体系结构风格在工程实践中的不同应用形式。</p>
<p>典型的软件体系结构风格</p>
<ul>
<li>管道-过滤器体系结构风格</li>
<li>基于事件的隐式调用体系结构风格分层体系结构风格</li>
<li>仓库风格</li>
<li>异构系统合成风格</li>
</ul>
<h3 id="管道一过滤器（Pipe-Filter-体系结构风格">管道一过滤器（Pipe-Filter)体系结构风格</h3>
<p>管道一过滤器体系结构风格为<strong>处理数据流的软件系统架构</strong>提供了一种参考结构。它是由过滤器和管道组成的。每个处理步骤都被封装在一个过滤器组件中，数据流通过相邻过滤器之间的管道进行传输。每个过滤器可以单独修改，功能单一，并且它们之间的顺序可以进行配置。</p>
<p>构件类型:过滤器（Filter) ----数据处理构件</p>
<p>连接件类型:管道(Pipe) ----过滤器间的连接件</p>
<p>管道-过滤器风格及其应用模式</p>
<p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16860417493741686041748898.png" alt=""></p>
<p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16860417863771686041785863.png" alt=""></p>
<p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16860418123701686041811415.png" alt=""></p>
<p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16860418903691686041890032.png" alt=""></p>
<p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16860420430111686042041483.png" alt=""></p>
<p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16860421363841686042135589.png" alt=""></p>
<p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16860423363731686042335583.png" alt=""></p>
<p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16860424903701686042490031.png" alt=""></p>
<p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16860425373701686042537182.png" alt=""></p>
<h3 id="基于事件的隐式调用体系结构风格">基于事件的隐式调用体系结构风格</h3>
<p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16860426373681686042636908.png" alt=""></p>
<p>基于事件的（隐式调用风格）系统结构风格中，构件间不采用直接耦合方式交互，而是通过<font color='red'>事件机制交互</font>。系统中的<font color='red'>事件处理者构件</font>可以通过<font color='red'>事件注册</font>来订阅它所关心的事件相关联。当某一事件发生时，系统会通知所有与这个事件相关联的<font color='red'>事件处理者构件</font>，即一个事件的激发导致了<font color='red'>事件处理者构件</font>与<font color='red'>事件源构件间</font>的隐式地交互。</p>
<p>构件类型:</p>
<ul>
<li>
<p>事件源(Event Source)构件</p>
</li>
<li>
<p>事件处理者(Event Handler)构件</p>
</li>
<li>
<p>事件分发者(Event Dispatcher)构件</p>
</li>
</ul>
<p>连接件类型:事件对象(Event)<br>
An event is a notification that occurs in response to an action, such as a change in state, or as a result of the user clicking the mouse or pressing a key while viewing the document.</p>
<p>Context（适用场景)</p>
<ul>
<li>松散耦合的异步运行系统
<ul>
<li>对事件的处理无顺序要求的系统</li>
<li>事件的处理要求具有很好的灵活性</li>
<li>非集中式控制的实时响应软件系统</li>
</ul>
</li>
<li>典型系统案例
<ul>
<li>图形用户界面系统</li>
<li>某些监控系统</li>
<li>现代高级语言的异常处理</li>
</ul>
</li>
</ul>
<p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16860429723711686042971797.png" alt=""></p>
<p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16860439834101686043983247.png" alt=""></p>
<p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16860442033701686044202775.png" alt=""></p>
<p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16860442284411686044228371.png" alt=""></p>
<h3 id="分层体系结构风格及应用模式">分层体系结构风格及应用模式</h3>
<blockquote>
<p>诺贝尔奖获得者赫伯特A.西蒙曾论述到:“要构造一门关于复杂系统的比较正规的理论，有一条路就是求助于层级理论…我们可以期望，在一个复杂性必然是从简单性进化而来的世界中，复杂系统是层级结构的”。对于软件这样复杂的人造事务，发现层级和运用层级，是分析和构建的基本原则。</p>
</blockquote>
<p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16860444000101686044398636.png" alt=""></p>
<p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16860444953701686044495090.png" alt=""></p>
<p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16860445523771686044551425.png" alt=""></p>
<p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16860446003741686044600114.png" alt=""></p>
<p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16860446143821686044614269.png" alt=""></p>
<p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16860446313691686044631290.png" alt=""></p>
<p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16860448009261686044800767.png" alt=""></p>
<p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16860448550201686044854303.png" alt=""></p>
<p>特点优点:<br>
。层构件的封装性、可重用性、可替换性·系统的局部依赖特性<br>
缺点:<br>
。层构件间的依赖性，特别是当低层构件的修改影响高层构件的时候，可能引起底层之上的多个层构件的修改。<br>
。效率问题:顶层构件到底层构件之间需要进行层层的参数传递/转换等。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16860449080251686044907130.png" alt=""></p>
<h3 id="Repository风格及应用模式">Repository风格及应用模式</h3>
<p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16860452179291686045217767.png" alt=""></p>
<p>Context（适用场景)</p>
<blockquote>
<p>以数据为中心的分布式系统</p>
<p>Repositories Types:<br>
a.Passive Repository: Database系统</p>
<p>Accessed by a set of components.</p>
<p>b.Active Repository: Blackboard系统</p>
<p>Sends notification to components when data of interest changes.</p>
</blockquote>
<p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16860458959241686045895742.png" alt=""></p>
<h1>复习思路</h1>
<p>软件架构设计时，根据抽象程度从高到低分为三个层次的模式：架构模式，设计模式和代码模式。</p>
<h2 id="体系结构">体系结构</h2>
<p>软件体系结构基本组成元素包括：构件Component 和 连接件 Connector 和配置。</p>
<p>构件：系统的逻辑与功能结构组成单元。</p>
<p>连接件：构件之间交互的机制和规则。</p>
<p>软件体系结构核心模型：<strong>构件</strong>+<strong>连接件</strong>+角色+端口+<strong>配置</strong></p>
<p><img src="https://cdn.infinityday.cn//typora/image-20230606210100072.png" alt="image-20230606210100072"></p>
<h3 id="构件-Component">构件 Component</h3>
<ul>
<li>
<p>构件是具有某种功能的、可重用的软件模板单元，表示了系统中主要的<strong>计算元素</strong>和<strong>数据存储</strong>。</p>
</li>
<li>
<p>构件通过其<strong>接口</strong>和外界进行交互，而构件的接口由一组 <strong>端口</strong> 组成。</p>
</li>
<li>
<p>每个端口表示构件和外部环境之间的<strong>交互作用点</strong>。</p>
<blockquote>
<p>如：包构件的端口指包外部可见对象的接口或属性，而模块构件的端口则是指模块中申明的外部过程或函数以及数据结构与变量。</p>
</blockquote>
</li>
<li>
<p>构件是一个抽象概念，与实现技术无关。</p>
</li>
<li>
<p>原子构件不可再分；复合构件可分解为其他复合构件和原子构件。</p>
</li>
</ul>
<p>一些常见的构件：</p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>构件类型</strong></th>
<th style="text-align:left"><strong>构件支持的相互作用类型</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">模块(Module)</td>
<td style="text-align:left">过程调用、数据共享</td>
</tr>
<tr>
<td style="text-align:center">对象</td>
<td style="text-align:left">方法调用</td>
</tr>
<tr>
<td style="text-align:center">中间件</td>
<td style="text-align:left">消息传递、通讯协议</td>
</tr>
<tr>
<td style="text-align:center">进程</td>
<td style="text-align:left">消息传递、远程调用、  通讯协议、同步</td>
</tr>
<tr>
<td style="text-align:center">数据文件</td>
<td style="text-align:left">读写</td>
</tr>
<tr>
<td style="text-align:center">数据库</td>
<td style="text-align:left">模式、查询语言</td>
</tr>
<tr>
<td style="text-align:center">文档</td>
<td style="text-align:left">共享变量访问</td>
</tr>
</tbody>
</table>
<h3 id="连接件-Connector">连接件 Connector</h3>
<p>定义：连接件是构件之间相互交互的<strong>机制</strong>或<strong>规则</strong>。</p>
<blockquote>
<ul>
<li>机制：是指<strong>连接件的具体实现形式</strong>：如过程调用、共享存储区、网络。</li>
<li>规则：是指<strong>构件使用连接件应遵循的规范</strong>。如对过程调用的接口参数形式、共享存储区的数据存储结构（队列、堆栈等）、网络协议（TCP/IP，HTTP等）。</li>
</ul>
</blockquote>
<h3 id="角色">角色</h3>
<p>角色是连接件的交互参与者。</p>
<ul>
<li>通过连接件实现交互时，构件在交互过程中体现为不同的角色。</li>
</ul>
<blockquote>
<ul>
<li>
<p>如RPC: 过程调用的调用方和被调用方</p>
</li>
<li>
<p>如C/S连接：客户方和服务器方</p>
</li>
</ul>
</blockquote>
<ul>
<li>
<p>一个连接件所涉及的角色可以是二元的，也可以是多元的。</p>
<blockquote>
<ul>
<li>
<p>过程调用涉及的角色是二元的：调用者（caller）和被调用者（callee）</p>
</li>
<li>
<p>消息队列涉及的角色是多元的：消息源（source）和多个消息接收者/处理者（receivers/handlers）</p>
</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="配置-2">配置</h3>
<p><img src="https://cdn.infinityday.cn//typora/image-20230606212026866.png" alt="image-20230606212026866"></p>
<p>定义：配置表示构件和连接件的拓扑逻辑和约束。包括：</p>
<ul>
<li>构件的端口与连接件的角色之间的关联关系。</li>
<li>复合构件与其子构件的嵌套包含关系。</li>
</ul>
<p>​</p>
<h3 id="4-1-视图模型">4+1 视图模型</h3>
<p><img src="https://cdn.infinityday.cn//typora/image-20230607102940940.png" alt="image-20230607102940940"></p>
<p>逻辑视图：基于功能需求抽象出来的，用于刻画系统的<strong>静态结构模型</strong>；</p>
<p>开发视图：考虑开发技术、过程与组织，刻画系统的<strong>开发管理结构模型</strong>；</p>
<p>进程视图：刻画系统<strong>运行时的结构模型</strong>；</p>
<p>物理视图：逻辑视图各功能构件在安装部署环境中的映射，刻画系统的<strong>安装部署结构模型</strong>。</p>
<p>场景视图：从系统使用的角度对系统结构的描述。它反映了在完成某个系统功能时，系统各功能构件间的交互关系。</p>
<h3 id="典型软件体系结构风格">典型软件体系结构风格</h3>
<h4 id="管道-过滤器体系结构风格">管道-过滤器体系结构风格</h4>
<p>管道一过滤器体系结构风格为<strong>处理数据流的软件系统架构</strong>提供了一种参考结构。它是由过滤器和管道组成的。每个处理步骤都被封装在一个过滤器组件中，数据流通过相邻过滤器之间的管道进行传输。每个过滤可以单独修改，功能单一，并且它们之间的顺序可以进行配置。</p>
<ul>
<li>构件：过滤器（数据处理构件）</li>
<li>连接件：管道（实现过滤器之间交互的连接件）</li>
</ul>
<p><strong>适用场景</strong>：数据流处理软件系统的常见体系结构风格</p>
<blockquote>
<p>Windows cmd, unix shell命令解释系统</p>
</blockquote>
<p><strong>功能特点</strong>：</p>
<ul>
<li>处理或者转换输入数据流</li>
<li>对数据流的处理可以容易的分为几个独立的处理步骤</li>
</ul>
<p><strong>非功能特点：</strong></p>
<ul>
<li>系统的升级要求可以通过替换/增加/重组过滤器实现。</li>
<li>不同处理步骤不共享信息（过滤器构件之间松耦合）。</li>
</ul>
<blockquote>
<p>被动过滤器：当前过滤器从上一个过滤器拉入数据，然后把数据压出给下一个。</p>
<p>主动过滤器：同时支持拉入、压出。</p>
</blockquote>
<p><strong>优点</strong>：</p>
<ul>
<li>高内聚、低耦合</li>
<li>灵活性可扩展性</li>
<li>可重用性</li>
<li>有利于维护与更新</li>
<li>支持局部步骤的并行处理以提高效率</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>整体上串行增量式处理，存在效率问题</li>
<li>数据格式转换问题，额外开销</li>
<li>不适合交互式应用系统：因为过滤器的输入输出都有限制</li>
</ul>
<p>应用案例：Page Controller</p>
<p><img src="https://cdn.infinityday.cn//typora/image-20230607112203291.png" alt="image-20230607112203291"></p>
<h4 id="基于事件的隐式调用体系结构风格-2">基于事件的隐式调用体系结构风格</h4>
<p>基于事件的(隐式调用风格)系统结构风格中，构件间不采用直接耦合方式交互，而是通过事件机制交互。系统中的事件处理者构件可以通过事件注册来订阅它所关心的事件相关联。当某一事件发生时，系统会通知所有与这个事件相关联的事件处理者构件，即一个事件的激发导致了事件处理者构件与事件源构件间的隐式地交互。</p>
<p><img src="https://cdn.infinityday.cn//typora/image-20230607114621641.png" alt="image-20230607114621641"></p>
<p>构件：事件源构件、事件分发者构件，事件处理者构件</p>
<p>连接件：事件对象（事件是响应操作而发生的通知，例如状态更改或用户在查看文档时单击鼠标或按键）</p>
<p>适用场景：松散耦合的异步运行系统</p>
<blockquote>
<ul>
<li>图形用户界面系统</li>
<li>监控系统</li>
<li>高级语言的异常处理（try exception)等</li>
</ul>
</blockquote>
<p>优点：</p>
<ul>
<li>系统具有很好的灵活性，系统易于伸缩扩展</li>
</ul>
<p>缺点：</p>
<ul>
<li>系统控制权问题</li>
<li>数据的交换问题</li>
</ul>
<h4 id="分层体系结构风格">分层体系结构风格</h4>
<p>构件：各个子层</p>
<p>连接件：端口、接口  （相邻子层之间的调用关系、交互协议）</p>
<p><img src="https://cdn.infinityday.cn//typora/image-20230609192640514.png" alt="image-20230609192640514"></p>
<blockquote>
<p>TCP/IP协议，MVC模型等等。</p>
</blockquote>
<p><strong>优点</strong>：</p>
<ul>
<li>层构件的封装性，可重用性、可替换性</li>
<li>系统的局部依赖特性，松耦合。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>过多层次增加开销；过少层次结构较差</li>
<li>效率问题：顶层构件到底层构件之间需要进行层层参数传递和转换等。</li>
<li>层构件之间的依赖性：底层的修改可能会导致层层修改。</li>
</ul>
<h4 id="仓储体系结构风格">仓储体系结构风格</h4>
<p>以数据为中心的体系结构风格。</p>
<ul>
<li>构件：独立构件，仲裁者（调解员）</li>
<li>连接件：仓库</li>
</ul>
<p>适用场景：以数据为中心的分布式系统。</p>
<p>主动仓储和被动仓储的判断：</p>
<blockquote>
<p>主动仓储（BlackBoard黑板系统）：当感兴趣的数据变化时，发送通知给构件。它的构件是知识源Knowledge Source和仲裁员，连接件是黑板。典型案例是<strong>专家系统</strong>。</p>
<ul>
<li>黑板：知识源对黑板进行更改，逐步导致问题的解决方案。</li>
<li>知识源：独立分离的应用相关知识，知识源之间的交互仅仅通过黑板。</li>
<li>调解员：由黑板的状态驱动，监控黑板的变化，决定下一步选哪个知识源进行工作。</li>
</ul>
<p><img src="https://cdn.infinityday.cn//typora/image-20230607151243824.png" alt="image-20230607151243824"></p>
<p>被动仓储（Database数据库系统）：  由一组构件访问。典型案例是Windows剪切板。</p>
</blockquote>
<p>优点：</p>
<ul>
<li>可扩展性</li>
<li>可维护性</li>
<li>安全性</li>
<li>并行处理性</li>
</ul>
<p>缺点：</p>
<ul>
<li>单一失败点（如果仓库这个连接件出问题了，整个系统也会出问题；解决方法是：分布式仓库、数据备份以及灾难恢复演练）</li>
</ul>
<h4 id="体系结构风格对比分析">体系结构风格对比分析</h4>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:center">管道过滤器</th>
<th style="text-align:center">基于事件的隐式调用</th>
<th style="text-align:center">分层体系结构风格</th>
<th style="text-align:center">仓储体系结构风格</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">构件</td>
<td style="text-align:center">过滤器</td>
<td style="text-align:center">事件源，事件分发者，事件处理者</td>
<td style="text-align:center">每个子层</td>
<td style="text-align:center">独立构件、仲裁者</td>
</tr>
<tr>
<td style="text-align:left">连接件</td>
<td style="text-align:center">管道</td>
<td style="text-align:center">事件对象</td>
<td style="text-align:center">子层的端口、接口（子层之间的交互协议、调用关系）</td>
<td style="text-align:center">仓库</td>
</tr>
<tr>
<td style="text-align:left">适用场景</td>
<td style="text-align:center">采用数据流的软件系统结构；Web Page Controller.</td>
<td style="text-align:center">适用于松耦合的异步运行系统；图形操作系统、监控、高级语言的异常处理机制等。</td>
<td style="text-align:center">适用于需要分解的大系统；希望可移植性等。</td>
<td style="text-align:center">适用于以数据为中心的分布式系统。</td>
</tr>
<tr>
<td style="text-align:left">优点</td>
<td style="text-align:center"><strong>优点</strong>：1. 高内聚低耦合；2.灵活性可扩展性；3. 可重用性；4. 易于维护和更新；5.局部并行性，提高效率。</td>
<td style="text-align:center"><strong>优点</strong>：1. 系统非常灵活，并且容易伸缩扩展。（- 增添构件只需将它注册到系统 - 删除构件不会影响其他构件的接口）</td>
<td style="text-align:center"><strong>优点</strong>：1. 封装性，可重用，可替换2. 系统具有局部依赖性，带来松耦合</td>
<td style="text-align:center"><strong>优点</strong>：1. 可扩展 2. 易维护 3. 安全性 4. 并行处理性</td>
</tr>
<tr>
<td style="text-align:left">缺点</td>
<td style="text-align:center"><strong>缺点</strong>：1.全局串行，影响系统效率；2. 数据经过过滤器时进行格式转换，增加额外开销。</td>
<td style="text-align:center">**缺点：**1.系统控制权问题：系统放弃全局控制权，无法知道当前事件具体所需的事件处理者，也不能知道事件的处理顺序和事件。 2. 数据转换问题：当数据出现必须要使用一个共享仓库时，会影响全局性能和资源控制。</td>
<td style="text-align:center">**缺点：**1. 分层过多影响效率，分层过少影响结构清晰性。2. 当底层改变时，可能会导致顶层每层修改。3. 顶层与底层之间的交互需要经过多层转换与传递，增加开销。</td>
<td style="text-align:center">**缺点：**1.单一失败点</td>
</tr>
<tr>
<td style="text-align:left">补充知识</td>
<td style="text-align:center">无</td>
<td style="text-align:center">无</td>
<td style="text-align:center">无</td>
<td style="text-align:center">主动仓储、被动仓储</td>
</tr>
</tbody>
</table>
<h2 id="设计模式">设计模式</h2>
<ul>
<li>总体来说，Architecture更加关注的是所谓的High-level Design ，着眼于不同业务中共性的解决方案；</li>
<li>Pattern关注的重点在于通过经验提取的“准则或指导方案”在设计中的应用，因此在不同层面考虑问题的时候就形成了不同问题域上的Pattern。</li>
</ul>
<h3 id="面向对象设计的基本原则">面向对象设计的基本原则</h3>
<ol>
<li>开闭原则：对扩展开放，对修改关闭。（工厂方法，抽象工厂，桥模式等等</li>
<li>里式代换原则（LSP）：一个软件实体如果使用的是一个基类，那么一定适用于其子类，而且它根本不能察觉出基类对象和子类对象的区别。</li>
<li>依赖倒转原则：依赖于抽象，不要依赖于具体。针对接口编程，不要针对实现编程。</li>
<li>接口隔离原则（ISP）：使用多个专门的接口比使用单一总接口好。（一个类对另一个类的依赖性应当建立在最小的接口上）。</li>
<li>合成复用原则：尽量使用合成，尽量不要使用继承。</li>
<li>迪米特法则：一个对象对其他对象尽可能少了解。</li>
<li>单一职责原则：只能让一个类/接口/方法有且仅有一个职责</li>
</ol>
<h3 id="创建型模式">创建型模式</h3>
<p><strong>创建型模式</strong>要求：工厂方法、抽象工厂、原型模式、单例模式；什么样的设计模式属于哪种类型，每种设计模式有自己的特点和侧重搞清楚。尤其是工厂和抽象工厂要区别开。</p>
<h4 id="工厂方法">工厂方法</h4>
<ul>
<li><strong>意图</strong>：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</li>
<li><strong>解决的问题</strong>：主要解决接口选择的问题。</li>
<li><strong>使用场景</strong>：我们明确地计划不同条件下创建不同实例时。例如：1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 3、设计一个连接服务器的框架，需要三个协议，“POP3”、“IMAP”、“HTTP”，可以把这三个作为产品类，共同实现一个接口。</li>
<li><strong>上下文</strong>：一个类无法预测它必须创建的对象的类。一个类希望其子类指定它所创建的对象。类将责任委托给多个辅助子类之一，并且您希望本地化哪个辅助子类是代表。</li>
<li><strong>类图</strong>：</li>
</ul>
<p><img src="https://cdn.infinityday.cn//typora/image-20230607170435510.png" alt="image-20230607170435510"></p>
<h4 id="抽象工厂">抽象工厂</h4>
<ul>
<li><strong>意图</strong>：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</li>
<li><strong>解决的问题</strong>：主要解决接口选择的问题。</li>
<li><strong>使用场景</strong>：系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。例如： 1、QQ 换皮肤，一整套一起换。 2、生成不同操作系统的程序。</li>
<li><strong>类图</strong>：<img src="https://cdn.infinityday.cn//typora/image-20230607170414344.png" alt="image-20230607170414344"></li>
<li><strong>注意</strong>：产品族（华为生产手机电脑平板，华为的手机电脑平板就是一个产品族）难扩展，产品等级（华为生产手机电脑平板，小米也生产手机电脑平板，华为和小米就是不同的产品族，手机、电脑和平板是不同的产品等级）易扩展。</li>
</ul>
<h4 id="原型模式">原型模式</h4>
<blockquote>
<p>原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。</p>
</blockquote>
<ul>
<li><strong>意图</strong>：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</li>
<li><strong>解决的问题</strong>：在运行期建立和删除原型。</li>
<li><strong>使用场景</strong>：1、当一个系统应该独立于它的产品创建，构成和表示时。 2、当要实例化的类是在运行时刻指定时，例如，通过动态装载。 3、为了避免创建一个与产品类层次平行的工厂类层次时。 4、当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。 5、细胞分裂。 6、JAVA 中的 Object clone() 方法。</li>
<li><strong>类图：</strong></li>
</ul>
<p><img src="https://cdn.infinityday.cn//typora/image-20230607173427616.png" alt="image-20230607173427616"></p>
<h4 id="单例模式">单例模式</h4>
<blockquote>
<p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>
</blockquote>
<ul>
<li><strong>意图</strong>：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</li>
<li><strong>解决的问题</strong>：一个全局使用的类频繁地创建与销毁。</li>
<li><strong>使用场景</strong>：当您想控制实例数目，节省系统资源的时候 ; 1、一个班级只有一个班主任。2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。</li>
<li><strong>类图：</strong></li>
</ul>
<p><img src="https://cdn.infinityday.cn//typora/image-20230607173530021.png" alt="image-20230607173530021"></p>
<ul>
<li>**注意事项：**getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。</li>
</ul>
<h3 id="结构型模式">结构型模式</h3>
<p><strong>结构型模式</strong>要求：适配器模式（不同实现机制，类和对象适配的差别和特点），组合模式（安全性和透明性问题，意图），桥模式，装饰器模式；搞清楚哪个地方用哪个。</p>
<h4 id="桥接模式">桥接模式</h4>
<ul>
<li>
<p><strong>意图</strong>：桥接模式的目的是将抽象与其实现分离，使得两者可以独立变化。</p>
</li>
<li>
<p><strong>解决的问题</strong>：在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。</p>
</li>
<li>
<p><strong>使用场景</strong>：实现系统可能有多个角度分类，每一种角度都可能变化。这个时候我们把这种多角度分类分离出来，让它们独立变化，减少它们之间耦合。1、如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。 2、对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。 3、一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。</p>
</li>
<li>
<p>角色：抽象，改进后的抽象，实现者，具体实现者，客户端。</p>
</li>
<li>
<p><strong>类图：</strong></p>
<p><img src="https://cdn.infinityday.cn//typora/image-20230611144134232.png" alt="image-20230611144134232"></p>
</li>
</ul>
<h4 id="适配器模式">适配器模式</h4>
<ul>
<li>
<p><strong>意图</strong>：将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
</li>
<li>
<p><strong>解决的问题</strong>：主要解决在软件系统中，常常要将一些&quot;现存的对象&quot;放到新的环境中，而新环境要求的接口是现对象不能满足的。</p>
</li>
<li>
<p><strong>使用场景</strong>：</p>
<blockquote>
<ol>
<li>系统需要使用现有的类，而此类的接口不符合系统的需要。</li>
<li>想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。</li>
<li>通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）</li>
<li>美国电器 110V，中国 220V，就要有一个适配器将 110V 转化为 220V。</li>
<li>JAVA JDK 1.1 提供了 Enumeration 接口，而在 1.2 中提供了 Iterator 接口，想要使用 1.2 的 JDK，则要将以前系统的 Enumeration 接口转化为 Iterator 接口，这时就需要适配器模式。</li>
<li>在 LINUX 上运行 WINDOWS 程序。</li>
<li>JAVA 中的 <code>JDBC</code>。</li>
</ol>
</blockquote>
</li>
<li>
<p>角色：适配器Adapter，被适配者Adaptee，目标接口Target，客户端Client。</p>
</li>
<li>
<p><strong>类图：</strong></p>
<p><img src="https://cdn.infinityday.cn//typora/E9IBSI%60582_QIVD85QZYKPC.png" alt="img"></p>
</li>
</ul>
<p>案例：电脑客户端希望上网，但是没有网线接口，只有USB接口。</p>
<blockquote>
<ul>
<li>目标接口：网线接口 to USB接口</li>
<li>Adaptee：网线</li>
<li>Adapter：网线适配器</li>
</ul>
</blockquote>
<p>实现方式：</p>
<p>类适配器（通过继承来实现）、对象适配器（通过组合来实现）。</p>
<ul>
<li>类适配器：Adapter继承Adaptee类并实现Target接口，属于委派操作。</li>
<li>对象适配器：Adapter中组合Adaptee类（作为类成员变量）并实现Target接口，属于容器操作。</li>
</ul>
<h4 id="组合模式">组合模式</h4>
<ul>
<li>
<p><strong>意图</strong>：将对象组合成树形结构，以表示部分整体层次结构。组合模式使客户端能够统一地处理单个对象和对象的组合。</p>
</li>
<li>
<p><strong>解决的问题</strong>：它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以像处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。</p>
</li>
<li>
<p><strong>使用场景</strong>：</p>
<blockquote>
<ol>
<li>你想表示对象的部分-整体层次结构。</li>
<li>层次结构系统</li>
<li>你希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结<br>
构中的所有对象。</li>
<li>算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作数也可以是操作数、操作符和另一个操作数。</li>
<li>在 JAVA AWT 和 SWING 中，对于 Button 和 Checkbox 是树叶，Container 是树枝。</li>
</ol>
</blockquote>
</li>
<li>
<p><strong>角色</strong>：Client, Component（组件）, Leaf（叶子节点）, Composite(复合结点)</p>
</li>
<li>
<p><strong>类图：</strong></p>
</li>
</ul>
<p><img src="https://cdn.infinityday.cn//typora/image-20230608114624716.png" alt="image-20230608114624716"></p>
<ul>
<li>
<p>透明组合模式类图：<img src="https://cdn.infinityday.cn//typora/image-20230611154524307.png" alt="image-20230611154524307"></p>
</li>
<li>
<p>安全性组合模式类图：<img src="https://cdn.infinityday.cn//typora/image-20230611154542754.png" alt="image-20230611154542754"></p>
</li>
<li>
<p>安全性组合模式和透明性组合模式</p>
<blockquote>
<ul>
<li>透明组合模式：在该方式中，由于抽象构件（Component）声明了所有子类中的全部方法，所以客户端无须区别树叶对象（leaf）和树枝（Composite）对象，对客户端来说是透明的。但其缺点是：树叶构件本来没有 Add()、Remove() 及 GetChild() 方法，却要实现它们（空实现或抛异常），这样会带来一些安全性问题。</li>
<li>安全组合模式：将管理子构件的方法移到组合构件中，抽象构件和叶子构件没有对子对象的管理方法，这样就避免了上一种方式的安全性问题，但由于叶子和分支有不同的接口，客户端在调用时要知道树叶对象和树枝对象的存在，所以失去了透明性。</li>
</ul>
</blockquote>
</li>
</ul>
<p>优点：</p>
<ul>
<li>简化客户端操作</li>
<li>易于扩展</li>
<li>高层模块调用简单</li>
</ul>
<p>缺点：</p>
<ul>
<li>可能违反开闭原则</li>
<li>在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。</li>
</ul>
<h4 id="装饰器模式">装饰器模式</h4>
<ul>
<li>
<p><strong>意图</strong>：用于为对象增加新的职责，灵活扩展新功能。</p>
</li>
<li>
<p><strong>解决的问题</strong>：我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。这个时候我们选择组合而不是继承的方式，装饰器模式的核心思想是“组合优于继承”。通过嵌套对象之间的关系来实现功能的组合，避免了类之间的紧耦合关系。（组合复用原则）</p>
</li>
<li>
<p><strong>使用场景</strong>：</p>
<blockquote>
<ol>
<li>在不想增加很多子类的情况下扩展类。</li>
<li>孙悟空有 72 变，当他变成&quot;庙宇&quot;后，他的根本还是一只猴子，但是他又有了庙宇的功能。</li>
</ol>
</blockquote>
</li>
<li>
<p><strong>角色</strong>：Client, Component（组件接口）, Concrete Component（具体组件）, Decorator(装饰器)，Concrete Decorator（具体装饰器）</p>
</li>
<li>
<p><strong>类图：</strong></p>
</li>
</ul>
<p><img src="https://cdn.infinityday.cn//typora/image-20230608115312236.png" alt="image-20230608115312236"></p>
<p><img src="https://cdn.infinityday.cn//typora/image-20230608114823799.png" alt="image-20230608114823799"></p>
<p><strong>优点</strong></p>
<ul>
<li>提高灵活性和可扩展性</li>
<li>简便不同的组合</li>
<li>提高可维护性</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>代码的复杂性</li>
<li>增加性能开销</li>
</ul>
<p><strong>应用场景</strong></p>
<ul>
<li>
<p>在不影响其他对象的情况下，为单个对象添加新功能</p>
</li>
<li>
<p>动态组合多种可选功能</p>
</li>
<li>
<p>具体应用: GUI可视化组件,通信协议,日志系统,权限控制系统</p>
</li>
</ul>
<h3 id="行为型模式">行为型模式</h3>
<p><strong>行为型模式</strong>要求：迭代器模式，命令模式，备忘录（Memento）模式了解，观察者（Observer）模式。</p>
<h4 id="Command模式-命令模式">Command模式 命令模式</h4>
<ul>
<li>
<p><strong>意图</strong>：将请求封装为对象，从而让您使用不同的请求参数化客户端、排队或记录请求，并支持可撤销操作。</p>
</li>
<li>
<p><strong>解决的问题</strong>：在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。</p>
</li>
<li>
<p><strong>使用场景</strong>：</p>
<blockquote>
<ol>
<li>文本编辑器</li>
<li>图形编辑器</li>
</ol>
</blockquote>
</li>
<li>
<p>适用性：</p>
<blockquote>
<ol>
<li>对待执行的操作对对象进行参数化</li>
<li>指定、排队和在不同时间执行请求</li>
<li>支持撤销操作</li>
<li>支持记录变更，以防系统崩溃时应用更改</li>
<li>基于原语操作构建高级操作来构建系统结构——事务。</li>
</ol>
</blockquote>
</li>
<li>
<p><strong>角色：</strong></p>
<ul>
<li>Invoker：请求者，调用者，持有命令对象的引用，负责发起命令。</li>
<li>Receiver：执行具体的请求。</li>
<li>Command：命令接口。</li>
<li>ConcreteCommand：具体命令，实现命令接口，执行相关请求操作。</li>
</ul>
</li>
<li>
<p><strong>类图：</strong></p>
</li>
</ul>
<p><img src="https://cdn.infinityday.cn//typora/image-20230608225953095.png" alt="image-20230608225953095"></p>
<p><img src="https://cdn.infinityday.cn//typora/image-20230608231018682.png" alt="image-20230608231018682"></p>
<p>优点：</p>
<ul>
<li>动作封装</li>
<li>解耦发送者和接收者</li>
<li>可拓展性</li>
<li>简化和集中错误处理</li>
<li>支持撤销和重做的功能</li>
<li>易于实现宏命令和组合命令</li>
</ul>
<p>缺点：</p>
<ul>
<li>引入了额外的类和对象，复杂度高</li>
<li>增加性能消耗</li>
</ul>
<h4 id="迭代器模式">迭代器模式</h4>
<ul>
<li>
<p><strong>意图</strong>：提供一种访问聚合对象元素的方式，而不暴露其底层表示。</p>
</li>
<li>
<p><strong>解决的问题</strong>：不同的方式来遍历整个整合对象。</p>
</li>
<li>
<p><strong>使用场景</strong>：</p>
<blockquote>
<ol>
<li>JAVA 中的 iterator</li>
</ol>
</blockquote>
</li>
<li>
<p>适用性：</p>
<blockquote>
<ol>
<li>提供一种访问聚合对象内容的方式，但不暴露其内部表示。</li>
<li>支持多次遍历聚合对象内容。</li>
<li>为遍历不同的聚合对象结构提供统一的接口（即支持多态迭代）。</li>
</ol>
</blockquote>
</li>
<li>
<p><strong>角色：</strong></p>
<ul>
<li>Iterator 迭代器接口</li>
<li>ConcreteIterator 具体迭代器</li>
<li>Aggregate 集合接口</li>
<li>ConcreteAggregate 具体集合</li>
</ul>
</li>
<li>
<p><strong>类图：</strong></p>
</li>
</ul>
<p><img src="https://cdn.infinityday.cn//typora/image-20230608232544494.png" alt="image-20230608232544494"></p>
<h4 id="观察者模式（发布订阅机制）">观察者模式（发布订阅机制）</h4>
<ul>
<li>
<p><strong>意图</strong>：定义一种对象之间的一对多依赖关系，当一个对象改变状态时，所有依赖它的对象都会自动被通知并更新。</p>
</li>
<li>
<p><strong>解决的问题</strong>：一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。</p>
</li>
<li>
<p><strong>使用场景</strong>：</p>
<blockquote>
<p>拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价。</p>
</blockquote>
</li>
<li>
<p>适用性：</p>
<blockquote>
<ol>
<li>当一个抽象有两个方面，一个依赖于另一个方面时，将这些方面封装在单独的对象中，可以让您独立地变化和重用它们。</li>
<li>当一个对象的更改需要更改其它对象，并且你不知道需要更改多少个对象时。</li>
<li>当一个对象应该能够通知其他对象，而不做任何假设这些对象是谁。换句话说，你不希望这些对象紧密耦合。</li>
</ol>
</blockquote>
</li>
<li>
<p>角色：</p>
<ul>
<li>主题对象 Subject</li>
<li>具体主题对象 Concrete Subject</li>
<li>观察者 Observer</li>
<li>具体观察者 Concrete Observer</li>
</ul>
</li>
<li>
<p><strong>类图：</strong><img src="https://cdn.infinityday.cn//typora/image-20230609093019196.png" alt="image-20230609093019196"></p>
</li>
</ul>
<p>例子：借钱和还钱；</p>
<blockquote>
<p>张三向李四，王五借钱，设置主题对象是借钱者，观察者是债主；那么张三是具体主题对象，李四，王五是具体观察者。当具体主题对象有钱时，就使用Notify()告知观察者，然后调用Update()，这代表债主观察者们得到钱。</p>
</blockquote>
<p>总结：观察者观察主题对象的状态（订阅），当主题对象的状态改变时通知观察者调用Update()。</p>
<h4 id="备忘录模式">备忘录模式</h4>
<p><img src="https://cdn.infinityday.cn//typora/image-20230609093702238.png" alt="image-20230609093702238"></p>
<p>主要作用：捕获并且保存对象内部的状态。</p>
<p>角色：</p>
<ul>
<li>Memento 备忘录，存储发起者的内部状态，防止发起者之外的对象访问备忘录。</li>
<li>Originator 发起者，创建备忘录来记录当前状态，或者使用备忘录恢复状态。</li>
<li>Caretaker 看守人，管理员，负责保存备忘录，不能修改备忘录的内容。</li>
</ul>
<p>优点：</p>
<ul>
<li>封装性</li>
<li>简易恢复和撤销</li>
<li>简化发起人</li>
</ul>
<p>缺点：</p>
<ul>
<li>增加内存使用（保存的状态在内存中）</li>
<li>性能开销（频繁使用备忘录）</li>
<li>复杂性（备忘录模式增加程序复杂性）</li>
</ul>
<p>适用场景：</p>
<ul>
<li>维护对象的历史状态</li>
<li>不希望暴露复杂的内部状态</li>
</ul>
<blockquote>
<ul>
<li>文本编辑器</li>
<li>绘图应用</li>
<li>数据库系统</li>
<li>游戏开发</li>
<li>版本控制系统</li>
</ul>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://github.com/Leevan001">如风</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://blog.liyifan001.top/2023/06/06/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/">https://blog.liyifan001.top/2023/06/06/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.liyifan001.top" target="_blank">早早起床，拥抱太阳</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/1668325987314FA3E3F866C40A665F46EF56BBD227395.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/1668273103133D8802D069515E0A42BC91FDE752B8A5C.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">如风</div><div class="author-info__description">热爱睡觉的小笨蛋一枚吖~</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">34</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">32</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Leevan001"><i></i><span>🛴前往小家...</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Leevan001" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:liyifancqu@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">考点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">题型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%B0%E5%BF%86%E5%86%85%E5%AE%B9"><span class="toc-number">1.2.</span> <span class="toc-text">记忆内容</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BE%E7%A8%8B%E7%AE%80%E4%BB%8B"><span class="toc-number">2.1.</span> <span class="toc-text">课程简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%BC%E8%A7%82%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84"><span class="toc-number">2.2.</span> <span class="toc-text">综观软件架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0"><span class="toc-number">2.3.</span> <span class="toc-text">软件体系结构概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#font-color-red-%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9E%8B-font"><span class="toc-number">2.3.1.</span> <span class="toc-text">软件体系结构核心模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E4%BB%B6%E8%A7%A3%E6%9E%90"><span class="toc-number">2.3.1.1.</span> <span class="toc-text">构件解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E4%BB%B6"><span class="toc-number">2.3.1.2.</span> <span class="toc-text">连接件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE"><span class="toc-number">2.3.1.3.</span> <span class="toc-text">配置</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1%E8%A7%86%E5%9B%BE%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number">2.4.</span> <span class="toc-text">4+1视图（重要）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%A7%86%E5%9B%BE"><span class="toc-number">2.4.1.</span> <span class="toc-text">逻辑视图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E8%A7%86%E5%9B%BE"><span class="toc-number">2.4.2.</span> <span class="toc-text">开发视图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%A7%86%E5%9B%BE"><span class="toc-number">2.4.3.</span> <span class="toc-text">进程视图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E8%A7%86%E5%9B%BE"><span class="toc-number">2.4.4.</span> <span class="toc-text">物理视图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E8%A7%86%E5%9B%BE"><span class="toc-number">2.4.5.</span> <span class="toc-text">场景视图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC%E4%B8%8E%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E5%B1%9E%E6%80%A7"><span class="toc-number">2.5.</span> <span class="toc-text">架构风格与软件质量属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E9%A3%8E%E6%A0%BC%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.6.</span> <span class="toc-text">典型软件体系结构风格及其应用模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E4%B8%80%E8%BF%87%E6%BB%A4%E5%99%A8%EF%BC%88Pipe-Filter-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E9%A3%8E%E6%A0%BC"><span class="toc-number">2.6.1.</span> <span class="toc-text">管道一过滤器（Pipe-Filter)体系结构风格</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E4%BA%8B%E4%BB%B6%E7%9A%84%E9%9A%90%E5%BC%8F%E8%B0%83%E7%94%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E9%A3%8E%E6%A0%BC"><span class="toc-number">2.6.2.</span> <span class="toc-text">基于事件的隐式调用体系结构风格</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B1%82%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E9%A3%8E%E6%A0%BC%E5%8F%8A%E5%BA%94%E7%94%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.6.3.</span> <span class="toc-text">分层体系结构风格及应用模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Repository%E9%A3%8E%E6%A0%BC%E5%8F%8A%E5%BA%94%E7%94%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.6.4.</span> <span class="toc-text">Repository风格及应用模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">复习思路</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.</span> <span class="toc-text">体系结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E4%BB%B6-Component"><span class="toc-number">3.1.1.</span> <span class="toc-text">构件 Component</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E4%BB%B6-Connector"><span class="toc-number">3.1.2.</span> <span class="toc-text">连接件 Connector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%92%E8%89%B2"><span class="toc-number">3.1.3.</span> <span class="toc-text">角色</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-2"><span class="toc-number">3.1.4.</span> <span class="toc-text">配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E8%A7%86%E5%9B%BE%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.1.5.</span> <span class="toc-text">4+1 视图模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E9%A3%8E%E6%A0%BC"><span class="toc-number">3.1.6.</span> <span class="toc-text">典型软件体系结构风格</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E9%81%93-%E8%BF%87%E6%BB%A4%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E9%A3%8E%E6%A0%BC"><span class="toc-number">3.1.6.1.</span> <span class="toc-text">管道-过滤器体系结构风格</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E4%BA%8B%E4%BB%B6%E7%9A%84%E9%9A%90%E5%BC%8F%E8%B0%83%E7%94%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E9%A3%8E%E6%A0%BC-2"><span class="toc-number">3.1.6.2.</span> <span class="toc-text">基于事件的隐式调用体系结构风格</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B1%82%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E9%A3%8E%E6%A0%BC"><span class="toc-number">3.1.6.3.</span> <span class="toc-text">分层体系结构风格</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%93%E5%82%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E9%A3%8E%E6%A0%BC"><span class="toc-number">3.1.6.4.</span> <span class="toc-text">仓储体系结构风格</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E9%A3%8E%E6%A0%BC%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90"><span class="toc-number">3.1.6.5.</span> <span class="toc-text">体系结构风格对比分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.2.</span> <span class="toc-text">设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99"><span class="toc-number">3.2.1.</span> <span class="toc-text">面向对象设计的基本原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.2.2.</span> <span class="toc-text">创建型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">工厂方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82"><span class="toc-number">3.2.2.2.</span> <span class="toc-text">抽象工厂</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.2.2.3.</span> <span class="toc-text">原型模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.2.2.4.</span> <span class="toc-text">单例模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.2.3.</span> <span class="toc-text">结构型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.2.3.1.</span> <span class="toc-text">桥接模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.2.3.2.</span> <span class="toc-text">适配器模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.2.3.3.</span> <span class="toc-text">组合模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.2.3.4.</span> <span class="toc-text">装饰器模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.2.4.</span> <span class="toc-text">行为型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Command%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.2.4.1.</span> <span class="toc-text">Command模式 命令模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.2.4.2.</span> <span class="toc-text">迭代器模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%9C%BA%E5%88%B6%EF%BC%89"><span class="toc-number">3.2.4.3.</span> <span class="toc-text">观察者模式（发布订阅机制）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.2.4.4.</span> <span class="toc-text">备忘录模式</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/07/02/%E5%A4%8F%E4%BB%A4%E8%90%A5%E9%9A%8F%E8%AE%B0/" title="夏令营随记"><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/1668325981308812465B3FBC4B5003BF35EA940C3FCBE.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="夏令营随记"/></a><div class="content"><a class="title" href="/2023/07/02/%E5%A4%8F%E4%BB%A4%E8%90%A5%E9%9A%8F%E8%AE%B0/" title="夏令营随记">夏令营随记</a><time datetime="2023-07-02T09:18:38.000Z" title="发表于 2023-07-02 17:18:38">2023-07-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/25/%E8%8B%B1%E8%AF%AD%E9%97%AE%E7%AD%94/" title="英语问答"><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/1668274206122R-C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="英语问答"/></a><div class="content"><a class="title" href="/2023/06/25/%E8%8B%B1%E8%AF%AD%E9%97%AE%E7%AD%94/" title="英语问答">英语问答</a><time datetime="2023-06-25T02:54:38.000Z" title="发表于 2023-06-25 10:54:38">2023-06-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/17/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" title="机器学习"><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/1668325991403394931B30F162EA8AD66B450E0F93413.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="机器学习"/></a><div class="content"><a class="title" href="/2023/06/17/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" title="机器学习">机器学习</a><time datetime="2023-06-17T13:22:55.000Z" title="发表于 2023-06-17 21:22:55">2023-06-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/06/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/" title="软件体系结构"><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/1668325987314FA3E3F866C40A665F46EF56BBD227395.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="软件体系结构"/></a><div class="content"><a class="title" href="/2023/06/06/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/" title="软件体系结构">软件体系结构</a><time datetime="2023-06-06T10:05:52.000Z" title="发表于 2023-06-06 18:05:52">2023-06-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/03/%E6%95%B0%E6%8D%AE%E5%BA%93/" title="数据库"><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/1668325964310EA2896391D75964E20FD6F6F2657923C.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据库"/></a><div class="content"><a class="title" href="/2023/06/03/%E6%95%B0%E6%8D%AE%E5%BA%93/" title="数据库">数据库</a><time datetime="2023-06-03T12:11:46.000Z" title="发表于 2023-06-03 20:11:46">2023-06-03</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16683306913121668330690512.png')"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By 如风</div><div class="footer_custom_text">广阔天地，大有作为</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
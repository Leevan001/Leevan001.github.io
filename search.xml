<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>最短路径算法</title>
      <link href="/2022/11/28/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95/"/>
      <url>/2022/11/28/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>2022年11月24日 17:22:48</p><h1 id="搜索求解"><a href="#搜索求解" class="headerlink" title="搜索求解"></a>搜索求解</h1><ul><li>是AI的基本技术之一 , 在人工智能各应用领域中被广泛地使用</li><li>早期的AI程序与搜索技术联系紧密：几乎所有的（智力难题、棋类游戏、简单数学定理证明）都是以<strong>搜索</strong>为基础的</li><li>现在，搜索技术已渗透在各种AI系统中，可以说没有哪一种AI应用不用搜索方法，在专家系统、自然语言理解、自动程序设计、模式识别、机器人学、信息检索和博弈都在广泛使用</li><li>搜索算法——问题求解智能体</li><li>智力游戏：3传教士+3野人渡河、一条船、每次2人；如何规划摆渡方案？     可有几种方案？所用步骤是否最少——如何找到？</li></ul><h2 id="什么是搜索？"><a href="#什么是搜索？" class="headerlink" title="什么是搜索？"></a><strong>什么是搜索？</strong></h2><p>•根据问题的实际情况不断寻找可利用的知识，构造出<strong>一条代价较少的推理路线</strong>，使问题得到圆满解决的过程。</p><p>包括两个方面：</p><p>•找到从初始事实到问题最终答案的一条推理路径</p><p>•找到的这条路径在时间和空间上复杂度最小</p><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16695411773711669541177267.png"></p><h2 id="状态图搜索"><a href="#状态图搜索" class="headerlink" title="状态图搜索"></a><strong>状态图搜索</strong></h2><p>由于搜索的目的是为了寻找初始节点到目标节点的路径，所以在搜索过程中就得<font color='red'>随时记录搜索轨迹</font>font&gt;。<br>必须记住下一步还可以走哪些点：  OPEN表（存放待扩展的节点表）<br>必须记住哪些点走过了：   CLOSED表（存放已扩展的节点）<br>必须记住从目标返回的路径<br>每个表示状态的节点结构中必须有指向父节点的指针<br>所谓对一个节点进行“扩展”是指对该节点用某个可用操作进行作用，生成该节点的一组子节点（后续节点）</p><h2 id="图的一般搜索策略"><a href="#图的一般搜索策略" class="headerlink" title="图的一般搜索策略"></a>图的一般搜索策略</h2><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16695413670001669541366673.png" style="zoom: 33%;" /><h2 id="图搜索分类"><a href="#图搜索分类" class="headerlink" title="图搜索分类"></a><strong>图搜索分类</strong></h2><p>对OPEN表中节点排序方式产生了不同的搜索策略， 不同的搜索搜索策略效率不同。</p><p>排序是任意的，即盲目的——盲目搜索</p><p>排序用启发信息为依据——启发式搜索</p><h3 id="盲目式搜索"><a href="#盲目式搜索" class="headerlink" title="盲目式搜索"></a><strong>盲目式搜索</strong></h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>对特定问题不具有任何相关信息的条件下，按照固定的步骤（依次或者随机）进行搜索，搜索过程中获得的中间信息不用来改进控制策略。一般只适用于求解比较简单的问题</p><h4 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h4><p>宽度优先（Breadth-first search）<br>深度优先（Depth-first search）<br>等代价（代价优先）搜索（Uniform-cost search）</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>搜索过程中不使用与问题有关的经验信息<br>搜索效率低<br>不适合大空间的实际问题求解</p><h3 id="启发式搜索"><a href="#启发式搜索" class="headerlink" title="启发式搜索"></a><strong>启发式搜索</strong></h3><h4 id="为什么需要启发式搜索？"><a href="#为什么需要启发式搜索？" class="headerlink" title="为什么需要启发式搜索？"></a>为什么需要启发式搜索？</h4><p>•盲目搜索的不足</p><p>•效率低，耗费过多的计算空间与时间</p><p>•可能带来组合爆炸</p><p>•分析前面介绍的宽度优先、深度优先搜索，或等代价搜索算法, 其主要的差别是 OPEN表中待扩展节点的顺序问题。人们就试图找到一种方法用于排列待扩展节点的顺序，即选择最有希望的节点加以扩展，那么，搜索效率将会大为提高。</p><h4 id="什么可以做为启发式信息？"><a href="#什么可以做为启发式信息？" class="headerlink" title="什么可以做为启发式信息？"></a>什么可以做为启发式信息？</h4><p>•启发性信息是指那种与具体问题求解过程有关的，并可指导搜索过程朝着最有希望方向前进的控制信息。</p><h4 id="启发式就是要猜测："><a href="#启发式就是要猜测：" class="headerlink" title="启发式就是要猜测："></a>启发式就是要猜测：</h4><p>从节点n开始，找到最优解的可能性有多大？</p><p>从起始节点开始，经过节点n，到达目标节点的最佳路径的费用是多少</p><p>启发式搜索是利用与问题有关的启发性信息，并以这些启发性信息指导的搜索的问题求解过程。</p><p>•需定义一个评价函数，对当前的搜索状态进行评估， 找出一个最有希望的节点来扩展。</p><p>•重排OPEN表， 选择最有希望的节点加以扩展。</p><h1 id="广度优先"><a href="#广度优先" class="headerlink" title="广度优先"></a>广度优先</h1><p>宽度&#x2F;广度优先搜索基本思想：</p><p>•首先扩展根节点；</p><p>•接着扩展根节点的所有后继节点；</p><p>•然后再扩展后继节点的后继，依此类推；</p><p>•在第n层节点还没有全部搜索完之前，不进入第n+1层节点的搜索。</p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16695455519681669545551734.png" style="zoom:33%;" /><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16695455839791669545583908.png" style="zoom:33%;" /><h1 id="深度优先"><a href="#深度优先" class="headerlink" title="深度优先"></a>深度优先</h1><p>深度优先搜索基本思想：</p><p>•总是扩展搜索树的当前扩展分支中最深的节点；</p><p>•搜索直接伸展到搜索树的最深层，直到那里的节点没有后继节点；</p><p>•然后搜索算法回退到下一个还有未扩展后继节点的上层节点继续扩展。</p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16695457309591669545730420.png" style="zoom:33%;" /><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16694527612791669452760592.png" style="zoom:50%;" /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">常见错误：在得到一条成功路径之后就结束</span><br><span class="line">记录[]，路径[]</span><br><span class="line">dfs(起始，末尾)：</span><br><span class="line">if(当前=末尾)&#123;</span><br><span class="line">进行结束操作</span><br><span class="line">&#125;</span><br><span class="line">for(i=1;i&lt;n;i++)&#123;</span><br><span class="line">if(符合要求)&#123;</span><br><span class="line">记录，记录路径</span><br><span class="line">dfs</span><br><span class="line">清空记录</span><br><span class="line">清空记录的路径</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="A-算法"><a href="#A-算法" class="headerlink" title="A*算法"></a>A*算法</h1><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16695501730961669550172582.png" style="zoom:33%;" /><p>有序搜索，也称优先搜索&#x2F;全局择优， 选择OPEN表上具有最小 f 值的节点作为下一个要扩展的节点。</p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16695502450981669550244635.png" style="zoom:33%;" /><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16695506490991669550648681.png" style="zoom:33%;" /><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16695507920971669550791346.png"></p><p>维基解释：</p><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16695516431001669551642519.png"></p><h1 id="迪杰斯特拉（Dijkstra）算法"><a href="#迪杰斯特拉（Dijkstra）算法" class="headerlink" title="迪杰斯特拉（Dijkstra）算法"></a>迪杰斯特拉（Dijkstra）算法</h1><p><a href="https://www.cnblogs.com/goldsunshine/p/12978305.html">一个很好的讲解博客</a></p><p>Dijkstra 算法是一个基于「贪心」、「广度优先搜索」、「动态规划」求一个图中一个点到其他所有点的最短路径的算法，时间复杂度 O(n2)</p><p>等代价搜索(Uniform-cost Search)</p><p>BFS的扩展版本：Expand node with lowest path cost<br>1959年由Dijkstra（迪科斯彻）提出——Dijkstra算法<br>基本思想：<br>是宽度优先搜索的一种推广，不是沿着等长度路径断层进行扩展，而是沿着等代价路径断层进行扩展。<br>状态图中每条连接弧线上的有关代价，表示时间、距离等开销。<br>节点代价的定义：<br>g (n)： 表示从初始节点 S。到节点n的代价；<br>c (n1, n2) : 表示从父节点 n1 到其子节点 n2 的代价；<br>g (n2) &#x3D; g (n1) + c ( n1 ,n2)</p><p>《算法图解》</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">狄克斯特拉算法包含4个步骤。</span><br><span class="line">(1) 找出最便宜的节点，即可在最短时间内前往的节点。</span><br><span class="line">(2) 对于该节点的邻居，检查是否有前往它们的更短路径，如果有，就更新其开销。</span><br><span class="line">(3) 重复这个过程，直到对图中的每个节点都这样做了。</span><br><span class="line">(4) 计算最终路径。</span><br></pre></td></tr></table></figure><h1 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h1><p>本实验要求用广度优先算法、深度优先算法和A*算法求解“罗马尼亚度假问题”，即找到从初始地点 Arad到目的地点 Bucharest 的一条最佳路径 </p><p>1.给出各种搜索算法得到的具体路径、相应的代价、经过的节点数、open表和close表</p><p>2.这几种方法效果做对比，例如时间维度</p><p>加分项：交互性界面，可自选出发地和目标地</p><p>图为罗马尼亚的地图，上面也显示了各个城市之间的代价值</p><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16692775423361669277542193.png"></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><p>从图的一个未遍历的节点出发，先遍历这个节点的相邻节点，再依次遍历每个相邻节点的相邻节点，找到目标节点或完全遍历结束。</p><h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><p>从图中一个未访问的顶点 V开始，沿着一条路一直走到底，然后从这条路尽头的节点回退到上一个节点，再从另一条路开始走到底…，不断递归重复此过程，直到找到目标节点或所有的顶点都遍历完成。</p><h3 id="A-算法-1"><a href="#A-算法-1" class="headerlink" title="A* 算法"></a>A* 算法</h3><p>通过下面这个函数来计算每个节点的优先级：</p><p>​      f(n) &#x3D; g(n) + h(n)</p><p>其中：</p><p>•f(n)是节点n的综合优先级。当我们选择下一个要遍历的节点时，我们总会选取综合优先级最高（值最小）的节点。</p><p>•g(n) 是节点n距离起点的代价。</p><p>h(n)是节点n距离终点的预计代价，这也就是A*算法的启发函数。</p><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16692776874071669277687301.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(OPEN!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    从OPEN表中取f(n)最小的节点n;</span><br><span class="line">    <span class="keyword">if</span>(n节点==目标节点)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">for</span>(当前节点n的每个子节点X)</span><br><span class="line">    &#123;</span><br><span class="line">        计算f(X);</span><br><span class="line">        <span class="keyword">if</span>(XinOPEN)</span><br><span class="line">            <span class="keyword">if</span>(新的f(X)&lt;OPEN中的f(X))</span><br><span class="line">            &#123;</span><br><span class="line">                把n设置为X的父亲;</span><br><span class="line">                更新OPEN表中的f(n);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(XinCLOSE)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(Xnotinboth)</span><br><span class="line">        &#123;</span><br><span class="line">            把n设置为X的父亲;</span><br><span class="line">            求f(X);</span><br><span class="line">            并将X插入OPEN表中;<span class="comment">//还没有排序</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//endfor</span></span><br><span class="line">    将n节点插入CLOSE表中;</span><br><span class="line">    按照f(n)将OPEN表中的节点排序;<span class="comment">//实际上是比较OPEN表内节点f的大小，从最小路径的节点向下进行。</span></span><br><span class="line">&#125;<span class="comment">//endwhile(OPEN!=NULL)</span></span><br></pre></td></tr></table></figure><h1 id="实验代码-amp-结果"><a href="#实验代码-amp-结果" class="headerlink" title="实验代码&amp;结果"></a>实验代码&amp;结果</h1><p>文件：</p><p>citymap.txt</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Arad Zerind 75 Timisoara 118 Sibiu 140</span><br><span class="line">Bucharest Urziceni 85 Giurgiu 90 Pitesti 101 Fagaras 211</span><br><span class="line">Craiova Drobeta 120 Pitesti 138 Rimnicu 146</span><br><span class="line">Drobeta Mehadia 75 Craiova 120</span><br><span class="line">Eforie Hirsova 86</span><br><span class="line">Fagaras Sibiu 99 Bucharest 211</span><br><span class="line">Giurgiu Bucharest 90</span><br><span class="line">Hirsova Eforie 86 Urziceni 98</span><br><span class="line">Iasi Neamt 87 Vaslui 92</span><br><span class="line">Lugoj Mehadia 70 Timisoara 111</span><br><span class="line">Mehadia Lugoj 70 Drobeta 75</span><br><span class="line">Neamt Iasi 87</span><br><span class="line">Oradea Zerind 71 Sibiu 151</span><br><span class="line">Pitesti Rimnicu 97 Bucharest 101 Craiova 138</span><br><span class="line">Rimnicu Sibiu 80 Pitesti 97 Craiova 146</span><br><span class="line">Sibiu Rimnicu 80 Fagaras 99 Arad 140 Oradea 151</span><br><span class="line">Timisoara Lugoj 111 Arad 118</span><br><span class="line">Urziceni Bucharest 85 Hirsova 98 Vaslui 142</span><br><span class="line">Vaslui Iasi 92 Urziceni 142</span><br><span class="line">Zerind Oradea 71 Arad 75</span><br></pre></td></tr></table></figure><p>cityname.txt</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Arad, Bucharest, Craiova,Drobeta, Eforie, Fagaras,Giurgiu, Hirsova, Iasi,Lugoj, Mehadia, </span><br><span class="line">Neamt,Oradea, Pitesti, Rimnicu,Sibiu, Timisoara, Urziceni,Vaslui, Zerind</span><br></pre></td></tr></table></figure><p>dis_info.txt</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Arad=(91, 492)</span><br><span class="line">Bucharest=(400, 327)</span><br><span class="line">Craiova=(253, 288)</span><br><span class="line">Drobeta=(165, 299)</span><br><span class="line">Eforie=(562, 293)</span><br><span class="line">Fagaras=(305, 449)</span><br><span class="line">Giurgiu=(375, 270)</span><br><span class="line">Hirsova=(534, 350)</span><br><span class="line">Iasi=(473, 506)</span><br><span class="line">Lugoj=(165, 379)</span><br><span class="line">Mehadia=(168, 339)</span><br><span class="line">Neamt=(406, 537)</span><br><span class="line">Oradea=(131, 571)</span><br><span class="line">Pitesti=(320, 368)</span><br><span class="line">Rimnicu=(233, 410)</span><br><span class="line">Sibiu=(207, 457)</span><br><span class="line">Timisoara=(94, 410)</span><br><span class="line">Urziceni=(456, 350)</span><br><span class="line">Vaslui=(509, 444)</span><br><span class="line">Zerind=(108, 531)</span><br></pre></td></tr></table></figure><p>导入库</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> PriorityQueue <span class="comment">#优先队列</span></span><br></pre></td></tr></table></figure><p>导入数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">city</span>(<span class="title class_ inherited__">object</span>):  <span class="comment"># 每一个城市的信息</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, coordination</span>):</span><br><span class="line">        self.name = name  <span class="comment"># 城市名</span></span><br><span class="line">        self.coordination=coordination</span><br><span class="line">        <span class="comment">#self.nextnum=0</span></span><br><span class="line">        self.nextcity=[]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">neighbour</span>(<span class="title class_ inherited__">object</span>):<span class="comment">#邻居</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,dist,point=(<span class="params"></span>)</span>):</span><br><span class="line">        self.name=name</span><br><span class="line">        self.dist=dist</span><br><span class="line">        self.predict=<span class="number">1e5</span></span><br><span class="line">        self.state=<span class="literal">False</span> <span class="comment">#是否已遍历，相当于将数据分到close表或open表</span></span><br><span class="line">        self.beforcity=<span class="string">&quot;&quot;</span></span><br><span class="line">        self.point=point</span><br><span class="line">file1=<span class="string">&quot;./cityname.txt&quot;</span></span><br><span class="line">file2=<span class="string">&quot;./dis_info.txt&quot;</span></span><br><span class="line">f = <span class="built_in">open</span>(file1, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">info=f.read()</span><br><span class="line">f.close()</span><br><span class="line">info</span><br><span class="line">txt_info=[]</span><br><span class="line">f = <span class="built_in">open</span>(file2, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">line = f.readline() <span class="comment"># 读取第一行</span></span><br><span class="line"><span class="keyword">while</span> line:</span><br><span class="line">    <span class="comment">#txt_data = eval(line) # 可将字符串变为元组</span></span><br><span class="line">    txt_info.append(line.replace(<span class="string">&quot;\n&quot;</span>,<span class="string">&quot;&quot;</span>)) <span class="comment"># 列表增加</span></span><br><span class="line">    line = f.readline() <span class="comment"># 读取下一</span></span><br><span class="line"><span class="comment">#print(txt_info)</span></span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">cityList=[]</span><br><span class="line"><span class="keyword">for</span> info <span class="keyword">in</span> txt_info:</span><br><span class="line">    info=info.split(<span class="string">&quot;=&quot;</span>)</span><br><span class="line">    cityList.append(city(info[<span class="number">0</span>],<span class="built_in">eval</span>(info[<span class="number">1</span>])))</span><br></pre></td></tr></table></figure><p>可视化地图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">x_list=[]</span><br><span class="line">y_list=[]</span><br><span class="line">txt_list=[]</span><br><span class="line"><span class="keyword">for</span> tmp <span class="keyword">in</span> cityList:</span><br><span class="line">    txt_list.append(tmp.name)</span><br><span class="line">    x_list.append(tmp.coordination[<span class="number">0</span>])</span><br><span class="line">    y_list.append(tmp.coordination[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#type(txt_list[1])</span></span><br><span class="line"><span class="comment">#可视化</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.figure(dpi=<span class="number">300</span>,figsize=(<span class="number">8</span>,<span class="number">8</span>))</span><br><span class="line">plt.scatter(x_list, y_list)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(y_list)):</span><br><span class="line">    plt.annotate(txt_list[i], xy = (x_list[i], y_list[i]), xytext = (x_list[i]+<span class="number">1</span>, y_list[i]+<span class="number">1</span>)) <span class="comment"># 这里xy是需要标记的坐标，xytext是对应的标签坐标</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>​<br><img src="F:\人工智能导论\搜索算法实验\罗马尼亚度假问题_files\罗马尼亚度假问题_5_0.png" alt="png"><br>​    </p><p>导入城市之间的相连信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">file3=<span class="string">&quot;./citymap.txt&quot;</span></span><br><span class="line">f = <span class="built_in">open</span>(file3, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">info=f.read()</span><br><span class="line">f.close()</span><br><span class="line"><span class="comment">#info</span></span><br><span class="line"><span class="comment">#读取相邻节点</span></span><br><span class="line">f = <span class="built_in">open</span>(file3, <span class="string">&#x27;r&#x27;</span>)<span class="comment">#存相邻节点</span></span><br><span class="line">line = f.readline() </span><br><span class="line"><span class="keyword">while</span> line:</span><br><span class="line">    tmp_list=line.replace(<span class="string">&quot;\n&quot;</span>,<span class="string">&quot;&quot;</span>).split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">    tmpobject = [x <span class="keyword">for</span> x <span class="keyword">in</span> cityList <span class="keyword">if</span> x.name == tmp_list[<span class="number">0</span>]][<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(tmp_list),<span class="number">2</span>):</span><br><span class="line">        tmpobject.nextcity.append(neighbour(tmp_list[i],<span class="built_in">eval</span>(tmp_list[i+<span class="number">1</span>])))</span><br><span class="line">    line = f.readline() <span class="comment"># 读取下一行</span></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><p>清除状态函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">clearState</span>(<span class="params">citylist</span>):</span><br><span class="line">    <span class="keyword">for</span> city <span class="keyword">in</span> citylist:</span><br><span class="line">        tmp=city.nextcity</span><br><span class="line">        <span class="keyword">for</span> nei <span class="keyword">in</span> tmp:</span><br><span class="line">            nei.state=<span class="literal">False</span></span><br><span class="line">clearState(cityList)</span><br></pre></td></tr></table></figure><p>利用dfs找到一个解就返回</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">record.append(&quot;Arad&quot;)</span><br><span class="line">disrecord.append(0)</span><br><span class="line">#dfs(&quot;Arad&quot;,&quot;Bucharest&quot;)</span><br><span class="line">dfs(&quot;Arad&quot;,&quot;Bucharest&quot;)</span><br></pre></td></tr></table></figure><p>修改起始和终点时<br>首先改变append中的城市名<br>其次更改dfs中的城市名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">clearState(cityList)</span><br><span class="line">st = time.clock()</span><br><span class="line">record=[]</span><br><span class="line">disrecord=[]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">begin,end</span>):<span class="comment">#寻找一个符合要求的路径</span></span><br><span class="line">    <span class="keyword">if</span> begin==end:</span><br><span class="line">        <span class="comment">#print(&quot;!&quot;*100)</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    currNeighbours = [x <span class="keyword">for</span> x <span class="keyword">in</span> cityList <span class="keyword">if</span> x.name == begin][<span class="number">0</span>].nextcity</span><br><span class="line">    <span class="keyword">for</span> curr <span class="keyword">in</span> currNeighbours:</span><br><span class="line">        <span class="keyword">if</span> end <span class="keyword">in</span> record:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> curr.state==<span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            curr.state=<span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> curr.name <span class="keyword">in</span> record:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment">#print(&quot;现在插入&quot;,curr.name)</span></span><br><span class="line">            record.append(curr.name)</span><br><span class="line">            disrecord.append(curr.dist)</span><br><span class="line">            dfs(curr.name,end)</span><br><span class="line">            <span class="keyword">if</span> end <span class="keyword">in</span> record:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            record.pop(-<span class="number">1</span>)</span><br><span class="line">            disrecord.pop(-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> currNeighbours[-<span class="number">1</span>].state==<span class="literal">True</span>:</span><br><span class="line">        record.pop(-<span class="number">1</span>)</span><br><span class="line">        disrecord.pop(-<span class="number">1</span>)</span><br><span class="line">        dfs(record[-<span class="number">1</span>],end)</span><br><span class="line">record.append(<span class="string">&quot;Arad&quot;</span>)</span><br><span class="line">disrecord.append(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#dfs(&quot;Arad&quot;,&quot;Bucharest&quot;)</span></span><br><span class="line">dfs(<span class="string">&quot;Arad&quot;</span>,<span class="string">&quot;Bucharest&quot;</span>)</span><br><span class="line">cost = time.clock()-st</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;路径&quot;</span>,record)</span><br><span class="line"><span class="built_in">print</span>(disrecord)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;路径总长度&quot;</span>,<span class="built_in">sum</span>(disrecord))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;运行时间：&quot;</span>,cost)</span><br></pre></td></tr></table></figure><pre><code>路径 [&#39;Arad&#39;, &#39;Zerind&#39;, &#39;Oradea&#39;, &#39;Sibiu&#39;, &#39;Rimnicu&#39;, &#39;Pitesti&#39;, &#39;Bucharest&#39;][0, 75, 71, 151, 80, 97, 101]路径总长度 575运行时间： 0.00020789999999999998</code></pre><p>利用dfs寻找所有的解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">record.append(&quot;Arad&quot;)#如果起始值是什么就填什么</span><br><span class="line">disrecord.append(0)</span><br><span class="line">#dfs(&quot;Arad&quot;,&quot;Bucharest&quot;)</span><br><span class="line">dfs(&quot;Arad&quot;,&quot;Sibiu&quot;)</span><br></pre></td></tr></table></figure><p>操作同上</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">clearState(cityList)</span><br><span class="line">st = time.clock()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">finalRecord=[]</span><br><span class="line">finalDist=[]</span><br><span class="line">record=[]</span><br><span class="line">disrecord=[]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">begin,end</span>):</span><br><span class="line">    <span class="keyword">if</span> begin==end:</span><br><span class="line">        finalRecord.append(record[:])</span><br><span class="line">        finalDist.append(disrecord[:])</span><br><span class="line">        <span class="comment">#print(&quot;!&quot;*100)</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    currNeighbours = [x <span class="keyword">for</span> x <span class="keyword">in</span> cityList <span class="keyword">if</span> x.name == begin][<span class="number">0</span>].nextcity</span><br><span class="line">    <span class="keyword">for</span> curr <span class="keyword">in</span> currNeighbours:</span><br><span class="line">        <span class="keyword">if</span> curr.state==<span class="literal">True</span> <span class="keyword">or</span> curr.name <span class="keyword">in</span> record:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            curr.state=<span class="literal">True</span></span><br><span class="line">            <span class="comment">#print(&quot;现在插入&quot;,curr.name)</span></span><br><span class="line">            record.append(curr.name)</span><br><span class="line">            disrecord.append(curr.dist)</span><br><span class="line">            dfs(curr.name,end)</span><br><span class="line">            <span class="comment">#print(&quot;现在弹出   &quot;,record[-1],&quot;   距离：&quot;,disrecord[-1])</span></span><br><span class="line">            curr.state=<span class="literal">False</span></span><br><span class="line">            record.pop(-<span class="number">1</span>)</span><br><span class="line">            disrecord.pop(-<span class="number">1</span>)</span><br><span class="line"><span class="comment">#     if currNeighbours[-1].state==True and currNeighbours[-1].name in record:</span></span><br><span class="line"><span class="comment">#         #print(&quot;!!!!!!!!!!!!现在弹出   &quot;,record[-1],&quot;   距离：&quot;,disrecord[-1])</span></span><br><span class="line"><span class="comment">#         record.pop(-1)</span></span><br><span class="line"><span class="comment">#         disrecord.pop(-1)</span></span><br><span class="line"><span class="comment">#         dfs(record[-1],end)</span></span><br><span class="line">record.append(<span class="string">&quot;Arad&quot;</span>)</span><br><span class="line">disrecord.append(<span class="number">0</span>)</span><br><span class="line">dfs(<span class="string">&quot;Arad&quot;</span>,<span class="string">&quot;Bucharest&quot;</span>)</span><br><span class="line"><span class="comment"># dfs(&quot;Arad&quot;,&quot;Sibiu&quot;)</span></span><br><span class="line">cost = time.clock()-st</span><br><span class="line"><span class="comment"># print(finalRecord)</span></span><br><span class="line"><span class="comment"># print(finalDist)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;DFS所有可行路径：&quot;</span>)</span><br><span class="line">sumdis=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(finalRecord)):</span><br><span class="line">    <span class="built_in">print</span>(finalRecord[i])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;该路径长度：&quot;</span>,<span class="built_in">sum</span>(finalDist[i]))</span><br><span class="line">    sumdis.append(<span class="built_in">sum</span>(finalDist[i]))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span>*<span class="number">100</span>)</span><br><span class="line">minindex=sumdis.index(<span class="built_in">min</span>(sumdis))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最短路径是：&quot;</span>,finalRecord[minindex])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;长度为：&quot;</span>,sumdis[minindex])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;运行时间：&quot;</span>,cost)</span><br></pre></td></tr></table></figure><pre><code>DFS所有可行路径：[&#39;Arad&#39;, &#39;Zerind&#39;, &#39;Oradea&#39;, &#39;Sibiu&#39;, &#39;Rimnicu&#39;, &#39;Pitesti&#39;, &#39;Bucharest&#39;]该路径长度： 575----------------------------------------------------------------------------------------------------[&#39;Arad&#39;, &#39;Zerind&#39;, &#39;Oradea&#39;, &#39;Sibiu&#39;, &#39;Rimnicu&#39;, &#39;Craiova&#39;, &#39;Pitesti&#39;, &#39;Bucharest&#39;]该路径长度： 762----------------------------------------------------------------------------------------------------[&#39;Arad&#39;, &#39;Zerind&#39;, &#39;Oradea&#39;, &#39;Sibiu&#39;, &#39;Fagaras&#39;, &#39;Bucharest&#39;]该路径长度： 607----------------------------------------------------------------------------------------------------[&#39;Arad&#39;, &#39;Timisoara&#39;, &#39;Lugoj&#39;, &#39;Mehadia&#39;, &#39;Drobeta&#39;, &#39;Craiova&#39;, &#39;Pitesti&#39;, &#39;Rimnicu&#39;, &#39;Sibiu&#39;, &#39;Fagaras&#39;, &#39;Bucharest&#39;]该路径长度： 1119----------------------------------------------------------------------------------------------------[&#39;Arad&#39;, &#39;Timisoara&#39;, &#39;Lugoj&#39;, &#39;Mehadia&#39;, &#39;Drobeta&#39;, &#39;Craiova&#39;, &#39;Pitesti&#39;, &#39;Bucharest&#39;]该路径长度： 733----------------------------------------------------------------------------------------------------[&#39;Arad&#39;, &#39;Timisoara&#39;, &#39;Lugoj&#39;, &#39;Mehadia&#39;, &#39;Drobeta&#39;, &#39;Craiova&#39;, &#39;Rimnicu&#39;, &#39;Sibiu&#39;, &#39;Fagaras&#39;, &#39;Bucharest&#39;]该路径长度： 1030----------------------------------------------------------------------------------------------------[&#39;Arad&#39;, &#39;Timisoara&#39;, &#39;Lugoj&#39;, &#39;Mehadia&#39;, &#39;Drobeta&#39;, &#39;Craiova&#39;, &#39;Rimnicu&#39;, &#39;Pitesti&#39;, &#39;Bucharest&#39;]该路径长度： 838----------------------------------------------------------------------------------------------------[&#39;Arad&#39;, &#39;Sibiu&#39;, &#39;Rimnicu&#39;, &#39;Pitesti&#39;, &#39;Bucharest&#39;]该路径长度： 418----------------------------------------------------------------------------------------------------[&#39;Arad&#39;, &#39;Sibiu&#39;, &#39;Rimnicu&#39;, &#39;Craiova&#39;, &#39;Pitesti&#39;, &#39;Bucharest&#39;]该路径长度： 605----------------------------------------------------------------------------------------------------[&#39;Arad&#39;, &#39;Sibiu&#39;, &#39;Fagaras&#39;, &#39;Bucharest&#39;]该路径长度： 450----------------------------------------------------------------------------------------------------最短路径是： [&#39;Arad&#39;, &#39;Sibiu&#39;, &#39;Rimnicu&#39;, &#39;Pitesti&#39;, &#39;Bucharest&#39;]长度为： 418运行时间： 0.0004011999999997684</code></pre><p>利用BFS求全局最小解</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">clearState(cityList)</span><br><span class="line">st = time.clock()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">BFS</span>(<span class="params">begin,end</span>):</span><br><span class="line">    finalRecord=[]</span><br><span class="line">    finalDist=[]</span><br><span class="line">    record=[]</span><br><span class="line">    disrecord=[]</span><br><span class="line">    record.append([begin])</span><br><span class="line">    disrecord.append([<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(record)!=<span class="number">0</span>:</span><br><span class="line">        tmprecord=record.pop(<span class="number">0</span>)</span><br><span class="line">        tmpdis=disrecord.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> end <span class="keyword">in</span> tmprecord:</span><br><span class="line">            finalRecord.append(tmprecord[:])</span><br><span class="line">            finalDist.append(tmpdis[:])</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        currcity=tmprecord[-<span class="number">1</span>]<span class="comment">#当前扩展的节点</span></span><br><span class="line">        currNeighbours = [x <span class="keyword">for</span> x <span class="keyword">in</span> cityList <span class="keyword">if</span> x.name == currcity][<span class="number">0</span>].nextcity</span><br><span class="line">        <span class="keyword">for</span> nei <span class="keyword">in</span> currNeighbours:</span><br><span class="line">            <span class="keyword">if</span> nei.name <span class="keyword">in</span> tmprecord:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            tmprecord.append(nei.name)</span><br><span class="line">            tmpdis.append(nei.dist)</span><br><span class="line">            record.append(tmprecord[:])</span><br><span class="line">            disrecord.append(tmpdis[:])</span><br><span class="line">            tmprecord.pop(-<span class="number">1</span>)</span><br><span class="line">            tmpdis.pop(-<span class="number">1</span>)</span><br><span class="line"><span class="comment">#     print(finalRecord)</span></span><br><span class="line"><span class="comment">#     print(finalDist)</span></span><br><span class="line"><span class="comment">#     print(len(finalRecord))</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;BFS所有可行路径：&quot;</span>)</span><br><span class="line">    sumdis=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(finalRecord)):</span><br><span class="line">        <span class="built_in">print</span>(finalRecord[i])</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;该路径长度：&quot;</span>,<span class="built_in">sum</span>(finalDist[i]))</span><br><span class="line">        sumdis.append(<span class="built_in">sum</span>(finalDist[i]))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span>*<span class="number">100</span>)</span><br><span class="line">    minindex=sumdis.index(<span class="built_in">min</span>(sumdis))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;最短路径是：&quot;</span>,finalRecord[minindex])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;长度为：&quot;</span>,sumdis[minindex])</span><br><span class="line">        </span><br><span class="line">BFS(<span class="string">&quot;Arad&quot;</span>,<span class="string">&quot;Bucharest&quot;</span>)</span><br><span class="line">cost = time.clock()-st</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;运行时间：&quot;</span>,cost)</span><br></pre></td></tr></table></figure><pre><code>BFS所有可行路径：[&#39;Arad&#39;, &#39;Sibiu&#39;, &#39;Fagaras&#39;, &#39;Bucharest&#39;]该路径长度： 450----------------------------------------------------------------------------------------------------[&#39;Arad&#39;, &#39;Sibiu&#39;, &#39;Rimnicu&#39;, &#39;Pitesti&#39;, &#39;Bucharest&#39;]该路径长度： 418----------------------------------------------------------------------------------------------------[&#39;Arad&#39;, &#39;Zerind&#39;, &#39;Oradea&#39;, &#39;Sibiu&#39;, &#39;Fagaras&#39;, &#39;Bucharest&#39;]该路径长度： 607----------------------------------------------------------------------------------------------------[&#39;Arad&#39;, &#39;Sibiu&#39;, &#39;Rimnicu&#39;, &#39;Craiova&#39;, &#39;Pitesti&#39;, &#39;Bucharest&#39;]该路径长度： 605----------------------------------------------------------------------------------------------------[&#39;Arad&#39;, &#39;Zerind&#39;, &#39;Oradea&#39;, &#39;Sibiu&#39;, &#39;Rimnicu&#39;, &#39;Pitesti&#39;, &#39;Bucharest&#39;]该路径长度： 575----------------------------------------------------------------------------------------------------[&#39;Arad&#39;, &#39;Zerind&#39;, &#39;Oradea&#39;, &#39;Sibiu&#39;, &#39;Rimnicu&#39;, &#39;Craiova&#39;, &#39;Pitesti&#39;, &#39;Bucharest&#39;]该路径长度： 762----------------------------------------------------------------------------------------------------[&#39;Arad&#39;, &#39;Timisoara&#39;, &#39;Lugoj&#39;, &#39;Mehadia&#39;, &#39;Drobeta&#39;, &#39;Craiova&#39;, &#39;Pitesti&#39;, &#39;Bucharest&#39;]该路径长度： 733----------------------------------------------------------------------------------------------------[&#39;Arad&#39;, &#39;Timisoara&#39;, &#39;Lugoj&#39;, &#39;Mehadia&#39;, &#39;Drobeta&#39;, &#39;Craiova&#39;, &#39;Rimnicu&#39;, &#39;Pitesti&#39;, &#39;Bucharest&#39;]该路径长度： 838----------------------------------------------------------------------------------------------------[&#39;Arad&#39;, &#39;Timisoara&#39;, &#39;Lugoj&#39;, &#39;Mehadia&#39;, &#39;Drobeta&#39;, &#39;Craiova&#39;, &#39;Rimnicu&#39;, &#39;Sibiu&#39;, &#39;Fagaras&#39;, &#39;Bucharest&#39;]该路径长度： 1030----------------------------------------------------------------------------------------------------[&#39;Arad&#39;, &#39;Timisoara&#39;, &#39;Lugoj&#39;, &#39;Mehadia&#39;, &#39;Drobeta&#39;, &#39;Craiova&#39;, &#39;Pitesti&#39;, &#39;Rimnicu&#39;, &#39;Sibiu&#39;, &#39;Fagaras&#39;, &#39;Bucharest&#39;]该路径长度： 1119----------------------------------------------------------------------------------------------------最短路径是： [&#39;Arad&#39;, &#39;Sibiu&#39;, &#39;Rimnicu&#39;, &#39;Pitesti&#39;, &#39;Bucharest&#39;]长度为： 418运行时间： 0.0014346000000005077</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getdis</span>(<span class="params">city1,city2</span>):<span class="comment">#获得两城市之间的直线距离,传的是元组</span></span><br><span class="line">    <span class="keyword">return</span> math.sqrt((city1[<span class="number">0</span>]-city2[<span class="number">0</span>])**<span class="number">2</span>+(city1[<span class="number">1</span>]-city2[<span class="number">1</span>])**<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#想为Dijkstra重新设计一个数据结构，发现neighbour刚好满足！</span></span><br><span class="line"><span class="comment"># class neighbour(object):#邻居</span></span><br><span class="line"><span class="comment">#     def __init__(self,name,dist):</span></span><br><span class="line"><span class="comment">#         self.name=name</span></span><br><span class="line"><span class="comment">#         self.dist=dist</span></span><br><span class="line"><span class="comment">#         self.state=False #是否已遍历    </span></span><br><span class="line"><span class="comment">#print(getdis((1,2),(2,3)))</span></span><br></pre></td></tr></table></figure><p>Dijkstra求最短路径</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">st = time.clock()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Dijkstra</span>(<span class="params">begin,end</span>):</span><br><span class="line">    recordlist=[]</span><br><span class="line">    <span class="comment">#初始化recordlist</span></span><br><span class="line">    <span class="keyword">for</span> city <span class="keyword">in</span> cityList:</span><br><span class="line">        recordlist.append(neighbour(city.name,<span class="number">1e3</span>))</span><br><span class="line">    curr = [x <span class="keyword">for</span> x <span class="keyword">in</span> recordlist <span class="keyword">if</span> x.name == begin][<span class="number">0</span>]</span><br><span class="line">    curr.dist=<span class="number">0</span></span><br><span class="line"><span class="comment">#     for rr in recordlist:</span></span><br><span class="line"><span class="comment">#         print(rr.name,rr.dist)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#print(curr.name)</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(recordlist)):</span><br><span class="line">        <span class="comment">#寻找最短且未打标记的路径</span></span><br><span class="line">        mindis=<span class="number">1e3</span></span><br><span class="line">        mincity=<span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> city <span class="keyword">in</span> recordlist:</span><br><span class="line">            <span class="keyword">if</span> city.state==<span class="literal">False</span>:</span><br><span class="line">                <span class="keyword">if</span> city.dist&lt;mindis:</span><br><span class="line">                    mindis=city.dist</span><br><span class="line">                    mincity=city.name</span><br><span class="line">        <span class="keyword">if</span> mincity==end:<span class="comment">#如果已经找到就直接退出#利用栈的结构，将结果输出</span></span><br><span class="line">            printlist=[]</span><br><span class="line">            printlist.append(mincity)</span><br><span class="line">            tmpfinal=[x <span class="keyword">for</span> x <span class="keyword">in</span> recordlist <span class="keyword">if</span> x.name == mincity][<span class="number">0</span>]</span><br><span class="line">            finalmindis=tmpfinal.dist</span><br><span class="line">    <span class="comment">#             while</span></span><br><span class="line">    <span class="comment">#             print(&quot;最短路径&quot;,printlist)</span></span><br><span class="line">            <span class="keyword">while</span> tmpfinal.name!=begin:</span><br><span class="line">                printlist.append(tmpfinal.beforcity)</span><br><span class="line">                tmpfinal=[x <span class="keyword">for</span> x <span class="keyword">in</span> recordlist <span class="keyword">if</span> x.name == tmpfinal.beforcity][<span class="number">0</span>]          </span><br><span class="line">            <span class="comment">#print(&quot;找到了！&quot;)</span></span><br><span class="line">            printlist=<span class="built_in">list</span>(<span class="built_in">reversed</span>(printlist))</span><br><span class="line">            <span class="built_in">print</span>(printlist)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;长度为：&quot;</span>,finalmindis)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment">#print(&quot;当前扩展节点&quot;,mincity)</span></span><br><span class="line">            curr = [x <span class="keyword">for</span> x <span class="keyword">in</span> recordlist <span class="keyword">if</span> x.name == mincity][<span class="number">0</span>]</span><br><span class="line">            curr.state=<span class="literal">True</span></span><br><span class="line">            currNeighbours = [x <span class="keyword">for</span> x <span class="keyword">in</span> cityList <span class="keyword">if</span> x.name == mincity][<span class="number">0</span>].nextcity</span><br><span class="line">            <span class="keyword">for</span> tmpneighbour <span class="keyword">in</span> currNeighbours:</span><br><span class="line">                tmpnei= [x <span class="keyword">for</span> x <span class="keyword">in</span> recordlist <span class="keyword">if</span> x.name == tmpneighbour.name][<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">if</span> tmpnei.state==<span class="literal">False</span> <span class="keyword">and</span> curr.dist+ tmpneighbour.dist &lt; tmpnei.dist:</span><br><span class="line">                    tmpnei.dist=curr.dist+ tmpneighbour.dist</span><br><span class="line">                    tmpnei.beforcity=mincity</span><br><span class="line">                    <span class="comment">#print(tmpnei.name)</span></span><br><span class="line"><span class="comment">#         for rr in recordlist:</span></span><br><span class="line"><span class="comment">#             print(rr.name,rr.dist,rr.state)</span></span><br><span class="line"><span class="comment">#        print(&quot;-&quot;*20)</span></span><br><span class="line">                 </span><br><span class="line">            </span><br><span class="line">Dijkstra(<span class="string">&quot;Arad&quot;</span>,<span class="string">&quot;Bucharest&quot;</span>)</span><br><span class="line">cost = time.clock()-st</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;运行时间：&quot;</span>,cost)</span><br></pre></td></tr></table></figure><pre><code>[&#39;Arad&#39;, &#39;Sibiu&#39;, &#39;Rimnicu&#39;, &#39;Pitesti&#39;, &#39;Bucharest&#39;]长度为： 418运行时间： 0.0009341000000002708</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#手写一个优先队列，库函数的不能满足要求</span></span><br><span class="line"><span class="comment"># q=PriorityQueue()</span></span><br><span class="line"><span class="comment"># q.put((2,&#x27;a&#x27;))</span></span><br><span class="line"><span class="comment"># q.put((2.22,&#x27;b&#x27;))</span></span><br><span class="line"><span class="comment"># q.put((1,&#x27;c&#x27;))</span></span><br><span class="line"><span class="comment"># while not q.empty():</span></span><br><span class="line"><span class="comment">#     next_item=q.get()</span></span><br><span class="line"><span class="comment">#     print(next_item)</span></span><br><span class="line"><span class="comment"># print(&#x27;-&#x27;*10)</span></span><br><span class="line"><span class="comment"># print(q.get())</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">st = time.clock()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">astar</span>(<span class="params">begin,end</span>):</span><br><span class="line">    recordlist=[]</span><br><span class="line">    <span class="comment">#初始化recordlist</span></span><br><span class="line">    <span class="keyword">for</span> city <span class="keyword">in</span> cityList:</span><br><span class="line">        recordlist.append(neighbour(city.name,<span class="number">1e4</span>,city.coordination))</span><br><span class="line">    finalpoint=[x <span class="keyword">for</span> x <span class="keyword">in</span> recordlist <span class="keyword">if</span> x.name == end][<span class="number">0</span>].point<span class="comment">#记录目标终点的坐标</span></span><br><span class="line">    curr = [x <span class="keyword">for</span> x <span class="keyword">in</span> recordlist <span class="keyword">if</span> x.name == begin][<span class="number">0</span>]</span><br><span class="line">    curr.dist=<span class="number">0</span></span><br><span class="line">    curr.predict=getdis(curr.point,finalpoint)</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(recordlist)):</span><br><span class="line">        <span class="comment">#寻找最短且未打标记的路径</span></span><br><span class="line">        currmincity=<span class="literal">None</span></span><br><span class="line">        <span class="comment">#先对队列进行排序</span></span><br><span class="line">        recordlist.sort(key=<span class="keyword">lambda</span> x:x.predict)</span><br><span class="line">        <span class="keyword">for</span> city <span class="keyword">in</span> recordlist:</span><br><span class="line">            <span class="keyword">if</span> city.state==<span class="literal">False</span>:</span><br><span class="line">                    currmincity=city</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> currmincity.name==end:<span class="comment">#如果已经找到就直接退出#利用栈的结构，将结果输出</span></span><br><span class="line">            printlist=[]</span><br><span class="line">            printlist.append(currmincity.name)</span><br><span class="line">            finalmindis=currmincity.dist</span><br><span class="line">            tmpfinal=currmincity</span><br><span class="line">            <span class="keyword">while</span> tmpfinal.name!=begin:</span><br><span class="line">                printlist.append(tmpfinal.beforcity)</span><br><span class="line">                tmpfinal=[x <span class="keyword">for</span> x <span class="keyword">in</span> recordlist <span class="keyword">if</span> x.name == tmpfinal.beforcity][<span class="number">0</span>]          </span><br><span class="line">            <span class="comment">#print(&quot;找到了！&quot;)</span></span><br><span class="line">            printlist=<span class="built_in">list</span>(<span class="built_in">reversed</span>(printlist))</span><br><span class="line">            <span class="built_in">print</span>(printlist)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;长度为：&quot;</span>,finalmindis)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment">#print(&quot;当前扩展节点&quot;,mincity)</span></span><br><span class="line">            curr = currmincity</span><br><span class="line">            curr.state=<span class="literal">True</span></span><br><span class="line">            currNeighbours = [x <span class="keyword">for</span> x <span class="keyword">in</span> cityList <span class="keyword">if</span> x.name == currmincity.name][<span class="number">0</span>].nextcity</span><br><span class="line">            <span class="keyword">for</span> tmpneighbour <span class="keyword">in</span> currNeighbours:</span><br><span class="line">                tmpnei= [x <span class="keyword">for</span> x <span class="keyword">in</span> recordlist <span class="keyword">if</span> x.name == tmpneighbour.name][<span class="number">0</span>]</span><br><span class="line">                newpredict=getdis(tmpnei.point,finalpoint)</span><br><span class="line">                <span class="keyword">if</span> tmpnei.state==<span class="literal">False</span> <span class="keyword">and</span> curr.dist+ tmpneighbour.dist+ newpredict &lt; tmpnei.predict:</span><br><span class="line">                    tmpnei.predict=curr.dist+ tmpneighbour.dist+ newpredict</span><br><span class="line">                    tmpnei.dist=curr.dist+ tmpneighbour.dist</span><br><span class="line">                    tmpnei.beforcity=currmincity.name</span><br><span class="line">astar(<span class="string">&quot;Arad&quot;</span>,<span class="string">&quot;Bucharest&quot;</span>)    </span><br><span class="line">cost = time.clock()-st</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;运行时间：&quot;</span>,cost)     </span><br></pre></td></tr></table></figure><pre><code>[&#39;Arad&#39;, &#39;Sibiu&#39;, &#39;Rimnicu&#39;, &#39;Pitesti&#39;, &#39;Bucharest&#39;]长度为： 418运行时间： 0.0006135999999994368</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 最短路径，DFS，BFS，Dijkstra,罗马尼亚度假问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++STL</title>
      <link href="/2022/11/23/C-STL/"/>
      <url>/2022/11/23/C-STL/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>图床搭建＋utools</title>
      <link href="/2022/11/23/%E5%9B%BE%E5%BA%8A%E6%90%AD%E5%BB%BA%EF%BC%8Butools/"/>
      <url>/2022/11/23/%E5%9B%BE%E5%BA%8A%E6%90%AD%E5%BB%BA%EF%BC%8Butools/</url>
      
        <content type="html"><![CDATA[<p>刚接触markdown的小伙伴一定曾苦于如何在md里面插入图片，可以插入本地图片，也可以直接放图片的uri。插入本地图片固然方便，可一旦照片移动了，或者md文件移动了，那么照片便可能不能正常显示了，有什么好的解决方法吗？</p><p>下面利用github建一个图床，利用utools进行图片管理（也可以使用picgo这一开源软件，但utools个人觉得更方便一些）</p><h1 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h1><p>　图床一般是指储存图片的服务器，有国内和国外之分。国外的图床由于有空间距离等因素决定访问速度很慢影响图片显示速度。国内也分为单线空间、多线空间和cdn加速三种。</p><p>　　图床其实可以从字面意思上来理解，就是让图片睡觉的床。就是让你上传图片并能够分享到互联网的网站。其实就是专门用来存放图片，同时允许你把图片对外连接的网上空间，不少图床都是免费的。但是免费的基本上后来都挂了，找不回来的图片可悲惨了。<a href="https://www.cncytc.com/article_1235.html">上述句子摘自</a></p><p>所以最好自己利用gitthub搭建一个</p><p>首先新建一个仓库</p><p>然后点击头像，里面的settings，如图</p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16691971338911669197133697.png" style="zoom:50%;" /><p>之后点击末尾的开发者设置</p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16691982484931669198248410.png" style="zoom:33%;" /><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16691972727441669197272203.png"></p><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16691973687601669197368717.png"></p><p>这样就生成了token，点击复制，要保存下来，因为只出现一次。</p><p>下面我们就要在utools里面设置了</p><h1 id="utools"><a href="#utools" class="headerlink" title="utools"></a>utools</h1><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16691974257431669197425404.png" style="zoom:33%;" /><p>下载图床这个插件</p><p>进入设置，如下图操作</p><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/1669198631395image-20221123180102250.png"></p><p>点击箭头就成功了！不要点修复！修复不知道有啥用</p><p>我们剪切板里面有一张图，则直接打开utool，按ctrl+v敲回车就行了</p><p>要用时，再打开图床，点击需要拷贝的格式，可以是html,md粘贴到md里面就行了。</p><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/1669198658392image-20221123180327163.png"></p><p>可能要注意的点：</p><p>一个仓库存放的图片不要超过500mb，据说大了会被清理，没有遇到过</p><p>图片本质是存在github仓库里面的，国内可能无法正常显示，要用一定的方法上网。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>github pages绑定域名</title>
      <link href="/2022/11/23/github-pages%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D/"/>
      <url>/2022/11/23/github-pages%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>爱折腾的小笨蛋一个啊~</p><p>一次偶然的机会，购买了一个域名，就想着能不能把它和之前的github pages 绑定起来</p><p>上学期就学过计算机网络，成绩也还理想，但终究是纸上知识，实践起来才知道计网学得连门都没有入😅，所以重庆某大学啥时候把1.5w每年的学费退一下？</p><p>趁还记得操作，把踩过的坑都记录一下，因为每踩一个坑都要查询很久，真的很锻炼心态。前人栽树后人乘凉，希望我的一些记录对你有帮助。（图床可能国内较卡，如果学校有GitHub加速应该可以显示）</p><h1 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h1><p><a href="https://www.idcspy.com/namesilo-22746.html">参考网站</a></p><p><a href="www.namesilo.com">namesilo</a></p><p>这是我购买域名的地址，国外的，dddd，不像国内那么麻烦，价格便宜，续费也简单，不坑，盲选就行。</p><p>注册的时候<font color='red'>记住你的用户名</font>，因为登陆时不能用邮箱（除非你后期允许用邮箱）</p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16691726479231669172647225.png" style="zoom:33%;" /><p>如果忘了用户名，点击username retrieval，他会发邮箱重新</p><p>傻乎乎用邮箱当用户名就会这样：</p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16691728409201669172840407.png" style="zoom:33%;" align="left"/><p>购买域名就是选一个域名，然后填一堆信息，购买就行，如果贵了就在名字后面加数字，我的名字拼音就比较贵，10$+起步，焯，不得已加了点数字让价格变成1.88$</p><p>好了假设你已经购买好域名</p><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16691729939261669172993021.png"></p><p>先update</p><p>如图（一共有两个圈要去操作）</p><p><span id="anchor"></span></p><img src="C:\Users\12498\AppData\Roaming\Typora\typora-user-images\image-20221123112015382.png" alt="image-20221123112015382" style="zoom:50%;" /><p>删除所有已经有的信息，最后如图所示</p><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16691732619241669173261773.png"></p><p>接下来要用到cloudflare</p><h1 id="cloudflare"><a href="#cloudflare" class="headerlink" title="cloudflare"></a>cloudflare</h1><p>首先注册一个然后登录</p><img src="C:\Users\12498\AppData\Roaming\Typora\typora-user-images\image-20221123112200325.png" alt="image-20221123112200325" style="zoom:50%;" /><p>我已经绑好了，第一次操作直接add site就行，我就直接点击这个active的框框</p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16691737869271669173786462.png" style="zoom:67%;" /><p>点击dns</p><p>然后将两个value，添加到name servise  <a href="#anchor">要填的地方</a></p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16691741889241669174188235.png" style="zoom:50%;" /><p>将四个ip添加进去，那个name自己定就行，注意是A类</p><h1 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h1><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16691742959321669174295161.png"></p><p>进入github对应仓库</p><p>点击settings</p><img src="C:\Users\12498\AppData\Roaming\Typora\typora-user-images\image-20221123113344739.png" alt="image-20221123113344739" style="zoom:50%;" /><p>填入自己的域名，比如我购买的是liyifan001.top，我添加了4个ip，名字是blog，那么我要填的就是blog.liyifan001.top</p><p>这时候应该就可以了</p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16691745199561669174519916.png" style="zoom:67%;" /><p>点击visit site</p><p>如果失败了请接着看我踩过的坑：</p><p>用cloudflare时，我喜欢折腾点了很多设置</p><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16691746839241669174683019.png"></p><p>首先我们要清除所有内容，如图所示</p><p>之后再visit site</p><p>这时候大概率会出现</p><p>反复重定向错误</p><p>傻乎乎的我照着网上的建议，清除了所有cookie，然而并没有什么作用，不对，其实是有作用的，我需要在所有已经登录的网站上重新登录一遍，真的会谢！</p><p>按f12进入开发工具，点击network</p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16691749149191669174914843.png" style="zoom:50%;" /><p>其实在不停301，像抽了一样</p><p>这时候，我们要进到cloudflare</p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16691750120141669175011957.png" style="zoom:33%;" /><p>将灵活改成完全</p><p>这时候应该就可以了！</p><p>点击查看网站</p><p>发现域名绑定成功！</p><h1 id="后续网站更新"><a href="#后续网站更新" class="headerlink" title="后续网站更新"></a>后续网站更新</h1><p>我主要用这个做博客玩</p><p>我发现每次更新仓库之后，网址都打不开了，</p><p>显示404，github page not found</p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16691751689221669175168697.png" style="zoom:33%;" /><p>不要慌张，其实再去pages重填一下域名就行。</p><p>但这样真的很麻烦，有没有什么避免重复劳动的操作？</p><p>其实我点了save之后，原来的仓库里面会出现CNAME这个文件，它里面只有一行，就是自己要绑定的域名</p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16691753539171669175353208.png" style="zoom:33%;" /><p>也就是说我只要每次更新仓库，仓库里面有CNAME就行了</p><p>我用到是hexo</p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16691754379191669175437256.png" style="zoom:33%;" /><p>只需要将CNAME文件放进source文件夹就可以了</p><p>谢谢阅读！</p><h1 id="一些用到的与计算机网络相关的知识"><a href="#一些用到的与计算机网络相关的知识" class="headerlink" title="一些用到的与计算机网络相关的知识"></a>一些用到的与计算机网络相关的知识</h1><h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><p><a href="https://zhuanlan.zhihu.com/p/93705326#:~:text=CND%E5%8A%A0%E9%80%9F%E4%B8%BB%E8%A6%81%E6%98%AF%E5%8A%A0%E9%80%9F%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%EF%BC%8C%E5%A6%82%E7%BD%91%E7%AB%99%E4%B8%8A%E9%9D%A2%E4%B8%8A%E4%BC%A0%E7%9A%84%E5%9B%BE%E7%89%87%E3%80%81%E5%AA%92%E4%BD%93%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%BC%95%E5%85%A5%E7%9A%84%E4%B8%80%E4%BA%9BJs%E3%80%81css%E7%AD%89%E6%96%87%E4%BB%B6%E3%80%82,CND%E5%8A%A0%E9%80%9F%E9%9C%80%E8%A6%81%E4%BE%9D%E9%9D%A0%E5%90%84%E4%B8%AA%E7%BD%91%E7%BB%9C%E8%8A%82%E7%82%B9%EF%BC%8C%E4%BE%8B%E5%A6%82100%E5%8F%B0CDN%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%86%E5%B8%83%E5%9C%A8%E5%85%A8%E5%9B%BD%E8%8C%83%E5%9B%B4%EF%BC%8C%E4%BB%8E%E4%B8%8A%E6%B5%B7%E8%AE%BF%E9%97%AE%EF%BC%8C%E4%BC%9A%E4%BB%8E%E6%9C%80%E8%BF%91%E7%9A%84%E8%8A%82%E7%82%B9%E8%BF%94%E5%9B%9E%E8%B5%84%E6%BA%90%EF%BC%8C%E8%BF%99%E6%98%AF%E6%A0%B8%E5%BF%83%E3%80%82">知乎参考</a></p><p>CDN全称<font color='red'>Content Delivery Network</font>，即<font color='yellow'>内容分发网络</font>。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够<font color='green'>实时</font>地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息<font color='cornflowerblue'>将用户的请求重新导向离用户最近的服务节点上</font>。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。</p><p>CDN加速主要是加速静态资源，如网站上面上传的图片、媒体，以及引入的一些Js、css等文件。</p><p>CDN加速需要依靠各个网络节点，例如100台CDN服务器分布在全国范围，从上海访问，会从最近的节点返回资源，这是核心。</p><p>cloudflare关于CDN的解释：</p><p>内容传递网路（CDN） 是指一组分布在不同地理位置的伺服器，协同工作以提供网际网路内容的快速交付。</p><p>CDN 允许快速传输载入网际网路内容所需的资源，包括HTML 页面、javascript 档、样式表、图像和视讯。CDN 服务已得到不断普及。如今，大多数web 流量都通过CDN 提供服务，包括来自Facebook、Netflix 和亚马逊等主要网站的流量。</p><p>正确设定的CDN 也能协助保护网站，对抗常见的恶意攻击，例如分散式阻断服务(DDOS) 攻击。</p><p>核心理念，就是将内容缓存在终端用户附近。</p><p>CDN&#x3D;更智能的镜像+缓存+流量导流</p><p><a href="https://zhuanlan.zhihu.com/p/52362950">知乎参考</a></p><h2 id="域名（Domain-Name）"><a href="#域名（Domain-Name）" class="headerlink" title="域名（Domain Name）"></a>域名（Domain Name）</h2><p>域名的出现解决了记忆困难的问题，这个是你不再需要去记那么难记的IP地址，你只需要记住<a href="http://baidu.com这种便于人类记忆的字母数字组合的域名.就好比你给每个手机号备注名字一样,也是为了方便记忆./">http://baidu.com这种便于人类记忆的字母数字组合的域名。就好比你给每个手机号备注名字一样，也是为了方便记忆。</a></p><h3 id="域名解析类型"><a href="#域名解析类型" class="headerlink" title="域名解析类型"></a>域名解析类型</h3><p><a href="https://developer.aliyun.com/article/331012">摘录网站</a></p><p>（原文见阿里社区）</p><p>A记录、CNAME、MX记录、NS记录、TTL、TXT记录</p><p>A记录就是服务器的IP,域名绑定A记录就是告诉DNS,当你输入域名的时候给你引导向设置在DNS的A记录所对应的服务器。 简单的说，A记录是指定域名对应的IP地址</p><p>NS记录是指定由哪个DNS服务器解析你的域名</p><p>MX记录 MX（Mail Exchanger）记录是邮件交换记录，它指向一个邮件服务器，用于电子邮件系统发邮件时根据收信人的地址后缀来定位邮件服务器。例如，当Internet上的某用户要发一封信给 <a href="mailto:&#117;&#x73;&#x65;&#114;&#64;&#x6d;&#121;&#100;&#x6f;&#x6d;&#97;&#x69;&#110;&#x2e;&#x63;&#x6f;&#109;">&#117;&#x73;&#x65;&#114;&#64;&#x6d;&#121;&#100;&#x6f;&#x6d;&#97;&#x69;&#110;&#x2e;&#x63;&#x6f;&#109;</a> 时，该用户的邮件系统通过DNS查找mydomain.com这个域名的MX记录，如果MX记录存在， 用户计算机就将邮件发送到MX记录所指定的邮件服务器上。 </p><p><strong>CNAME记录</strong> CNAME（Canonical Name ）别名记录，允许您将多个名字映射到同一台计算机。通常用于同时提供WWW和MAIL服务的计算机。例如，有一台计算机名为 “host.mydomain.com”（A记录），它同时提供WWW和MAIL服务，为了便于用户访问服务。可以为该计算机设置两个别名（CNAME）：WWW和MAIL， 这两个别名的全称就“<a href="http://www.mydomain.com”和“mail.mydomain.com”,实际上他们都指向/">www.mydomain.com”和“mail.mydomain.com”，实际上他们都指向</a> “host.mydomain.com”。 </p><p>TTL（Time-To-Live）原理：TTL是IP协议包中的一个值，它告诉网络路由器包在网络中的时间是否太长而应被丢弃。有很多原因使包在一定时间内不能被传递到目的地。例如，不正确的路由表可能导致包的无限循环。一个解决方法就是在一段时间后丢弃这个包，然后给发送者一个报文，由发送者决定是否要重发。TTL的初值通常是系统缺省值，是包头中的8位的域。TTL的最初设想是确定一个时间范围，超过此时间就把包丢弃。</p><h2 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h2><p><a href="https://www.runoob.com/http/http-status-codes.html">菜鸟教程</a></p><table><thead><tr><th align="left">分类</th><th align="left">分类描述</th></tr></thead><tbody><tr><td align="left">1**</td><td align="left">信息，服务器收到请求，需要请求者继续执行操作</td></tr><tr><td align="left">2**</td><td align="left">成功，操作被成功接收并处理</td></tr><tr><td align="left">3**</td><td align="left">重定向，需要进一步的操作以完成请求</td></tr><tr><td align="left">4**</td><td align="left">客户端错误，请求包含语法错误或无法完成请求</td></tr><tr><td align="left">5**</td><td align="left">服务器错误，服务器在处理请求的过程中发生了错误</td></tr></tbody></table><table><thead><tr><th>301</th><th>Moved Permanently</th><th align="left">永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</th></tr></thead><tbody><tr><td></td><td></td><td align="left"></td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>软件需求分析复习整理</title>
      <link href="/2022/11/21/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/"/>
      <url>/2022/11/21/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="第0章-引言"><a href="#第0章-引言" class="headerlink" title="第0章 引言"></a>第0章 引言</h1><h2 id="项目失败或严重超支的8个最重要原因中有5个都与需求相关："><a href="#项目失败或严重超支的8个最重要原因中有5个都与需求相关：" class="headerlink" title="项目失败或严重超支的8个最重要原因中有5个都与需求相关："></a>项目失败或严重超支的8个最重要原因中有5个都与需求相关：</h2><ol><li>需求不完整</li><li>缺乏用户的参与</li><li>用户期望不实际</li><li>需求和需求规格说明的变更</li><li>提供许多不必要的功能。</li></ol><h2 id="“软件需求分析”："><a href="#“软件需求分析”：" class="headerlink" title="“软件需求分析”："></a>“软件需求分析”：</h2><p>就是对需要解决的问题进行详细分析</p><p>弄清楚需要解决的问题，开发人员才能顺利开发出用户真正需要的软件。</p><p>如果一味追求进度，而忽略软件需求分析，很可能南辕北敏，开发变得毫无意义。</p><p>“软件需求分析”：是连接开发人员和用户之间的重要纽带。只有真正理解用户的需求，才能设计出用户所需要的软件。</p><p>“软件需求分析”：</p><p>就是分析软件用户的需求是什么。</p><p>如果投入大量的人力、物力、财力、时间，开发出的软件却没人要，那所有的投入都是徒劳。</p><p>如果费了很大的精力，开发一个软件系统，最后却不满足用户的要求，从而要重新开发过，这种返工是让人痛心疾首的。</p><p>总之，软件需求问题不仅关系到软件项目开发的成功，也关系到软件产业的发展，更关系到各行各业信息化目标的实现。</p><p>解决软件需求问题已成为软件领域刻不容缓的任务。</p><h1 id="第1章-软件需求概述"><a href="#第1章-软件需求概述" class="headerlink" title="第1章  软件需求概述"></a>第1章  软件需求概述</h1><p>软件需求的好坏直接关系到软件的成功与否。</p><p>客户提出的需求是软件系统的源头，它定义了软件系统的意图和目的。</p><p>如果需求遗漏或完成得不好，不管系统多么完美，系统也是失败的。</p><p>为了得到有效的需求，需要采用有效的方法与用户广泛地交流。</p><h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><p>① 用户解决问题或达到目标所需的条件或权能。</p><p>② 系统或系统部件要满足合同、标准、规范或其他正式规定文档所需具有的条件或权能。</p><p>③ 一种反映上面两种所描述的条件或权能的文档说明。</p><h2 id="基本原则："><a href="#基本原则：" class="headerlink" title="基本原则："></a>基本原则：</h2><p>1）并没有一个清晰、毫无歧义性的“需求”术语存在，真正的“需求”实际上在人们的脑海中。</p><p>2）定义问题，而不是解决方案。</p><p>3）定义系统，而不是项目。需求定义了系统需要做什么：它们是一组目标。</p><p>4）区分正式和非正式部分。</p><p>5）避免重置。</p><p>6）保持每个需求定义的大小在合适的范围内是良好的做法。</p><h2 id="软件需求的层次："><a href="#软件需求的层次：" class="headerlink" title="软件需求的层次："></a>软件需求的层次：</h2><ol><li>业务需求（Business Requirement ）</li><li>用户需求（User Requirement）</li><li>软件需求（Software Requirement）</li></ol><h3 id="业务需求："><a href="#业务需求：" class="headerlink" title="业务需求："></a>业务需求：</h3><p>是从业务角度描述的，是指导软件开发的高层需求。</p><p>业务需求的目标体现在两个方面：</p><p>1）问题：解决企业运行过程中遇到的问题。</p><p>2）机会：抓住外部环境变化所带来的机会，以便为企业带来新的发展。</p><p>业务需求：是从各个不同的人那里收集来的，它们包括主办者、客户、支付或采购软件产品者、开发公司的高级管理人员等。</p><p>业务需求：阐明产品的高层次概念和产品的主要业务内容。</p><p>业务需求：说明客户、公司和想从该系统获利的风险承担者或从系统中取得结果的用户所要求的目标。</p><p>业务需求：为后继工作建立了一个指导性的框架。</p><h3 id="用户需求："><a href="#用户需求：" class="headerlink" title="用户需求："></a>用户需求：</h3><p>是指描述的是用户使用软件需要完成什么任务。</p><p>用户需求：是在业务需求基础上进行用户访谈、调查，对用户使用的场景进行整理，从而建立用户角度的需求。</p><p>用户需求具有两个方面的特点：</p><p>1）零散：用户会给出不同角度、不同层面、不同粒度的用户需求。</p><p>2）存在矛盾：由于用户的层次不同，导致需求的片面性，甚至在不同用户之间会有不同的观点。</p><h3 id="软件需求："><a href="#软件需求：" class="headerlink" title="软件需求："></a>软件需求：</h3><p>是需求分析与建模的产物。</p><p>软件需求：必须根据用户需求来考虑，并要与业务需求所设定的目标相一致。</p><p>用户需求：具有零散、存在矛盾的特点。</p><p>  —— 因此，需求分析人员还需要对其进行分析、提炼、整理，从而生成指导开发的、更精确的软件需求。</p><h2 id="软件需求可以分为："><a href="#软件需求可以分为：" class="headerlink" title="软件需求可以分为："></a>软件需求可以分为：</h2><ul><li>功能需求（Functional Requirement）</li><li>非功能需求（Non-Functional Requirement）</li><li>设计约束</li></ul><h3 id="功能需求："><a href="#功能需求：" class="headerlink" title="功能需求："></a>功能需求：</h3><p>是一个系统必须提供的活动和服务描述。</p><p>功能需求：定义了开发人员必须实现的软件功能，使得用户能完成他们的任务，从而满足业务需求。</p><p>开发人员根据功能需求来设计软件以实现必需的功能。</p><p>功能需求：描述软件系统所应具有的外部行为，它在开发、测试、质量保证、项目管理以及相关项目功能中都将起到重要的作用。</p><h3 id="非功能需求："><a href="#非功能需求：" class="headerlink" title="非功能需求："></a>非功能需求：</h3><p>描述了系统展现给用户的行为和执行的操作等。</p><p>非功能需求：包括外部界面的具体细节、性能要求及质量属性。</p><p>非功能需求：是产品必须具备的品质，它们可以让产品更具有吸引力、易于使用、快速、可靠或者安全。</p><p>非功能需求：通常并不改变产品的功能。</p><p>一般来说，不管增加多少的质量属性，功能需求都会保持不变，功能需求和非功能需求是相辅相成密不可分的。</p><p>非功能需求：经常被忽略，因为它们不易被发现，发现后不易表达、实现以及测试。</p><p>在系统实现过程中，有时候满足非功能需求往往比满足功能需求更为重要。</p><h3 id="设计约束："><a href="#设计约束：" class="headerlink" title="设计约束："></a>设计约束：</h3><p>是指对开发人员在软件产品设计和构造上的限制，产品必须遵从的标准、规范和合约。</p><p>设计约束：包括：非技术因素的技术选型、预期的软硬件环境和预期的使用环境三大类型。</p><p>技术开发团队在决定架构、选择技术时，会受到企业实际的软硬件环境的影响，如果忽略了这个方面的因素会给项目带来一些不必要的麻烦。因此，在需求人员整理需求时，应该将这些预期的软硬件环境描述出来。</p><p> 实现有效的需求工程过程可以让组织受益匪浅。减少开发后期以及整个维护过程中不必要的返工，并可带来极大的回报。</p><h2 id="高质量软件需求的可以带来好处："><a href="#高质量软件需求的可以带来好处：" class="headerlink" title="高质量软件需求的可以带来好处："></a>高质量软件需求的可以带来好处：</h2><ul><li>减少需求的缺陷</li><li>减少开发过程中的返工</li><li>减少不必要的特性</li><li>降低改进成本</li><li>加快开发进度</li><li>提高沟通效率</li><li>控制需求范围的改变</li><li>项目更有序</li><li>对系统测试的评估更准确</li><li>10）提高客户和开发人员的满意度</li></ul><h2 id="需求陈述的特点："><a href="#需求陈述的特点：" class="headerlink" title="需求陈述的特点："></a>需求陈述的特点：</h2><ol><li><h3 id="完整性"><a href="#完整性" class="headerlink" title="完整性"></a>完整性</h3><ul><li>每一项需求都必须完整地描述即将交付使用的功能。</li><li>它必须包含开发人员设计和实现这项功能需要的所有信息</li></ul></li><li><h3 id="正确性"><a href="#正确性" class="headerlink" title="正确性"></a>正确性</h3><ul><li>每一项需求都必须准确地描述将要开发的功能。</li><li>如果一项软件需求与其相对应的系统需求发生冲突就是不正确的。</li><li>只有用户代表才能决定用户需求的正确性。</li></ul></li><li><h3 id="可行性"><a href="#可行性" class="headerlink" title="可行性"></a>可行性</h3><ul><li>需求必须能够在系统及其运行环境的已知能力和约束条件内实现，因此，由开发人员来进行可行性检查，判断技术上能够实现哪些需求，或者什么功能需要额外的成本才能实现。</li></ul></li><li><h3 id="必要性"><a href="#必要性" class="headerlink" title="必要性"></a>必要性</h3><ul><li><p>每一项需求记录的功能都必须是用户的真正需要，或者是为符合外部系统需求或某一标准而必须具备的功能。</p></li><li><p>每项需求都必须来源于有权定义需求的一方。对每项需求都必须追溯至特定的客户需求的来源。</p></li></ul></li><li><h3 id="有优先次序"><a href="#有优先次序" class="headerlink" title="有优先次序"></a>有优先次序</h3><ul><li>为每一项功能需求、特性或用例指定一个实现优先级，以表明它在产品的某一版本中的重要程度。</li><li>如果把所有的需求都看作同样重要，那么项目管理者在开发或节省预算或调度中就丧失控制自由度。</li></ul></li><li><h3 id="无歧义"><a href="#无歧义" class="headerlink" title="无歧义"></a>无歧义</h3><ul><li>一项需求对所有读者应该只有一种一致的解释，由于自然语言极易导致二义性，所以尽量把每项需求用简洁明了的用户的语言表达出来。</li><li>避免二义性的有效方法包括对需求文档的正规审查、编写测试用例、开发原型以及设计特定的方案脚本。</li></ul></li><li><h3 id="可验证性"><a href="#可验证性" class="headerlink" title="可验证性"></a>可验证性</h3><ul><li>检查一下每项需求是否能通过设计测试用例或其它的验证方法，如用演示、检测等方法来确定产品是否确实按需求实现了。</li><li>如果需求不可验证，则确定其实施是否正确就成为主观臆断，而非客观分析了。</li><li>一份前后矛盾，不可行或有二义性的需求也是不可验证的。</li></ul></li></ol><h2 id="需求规格说明的特点："><a href="#需求规格说明的特点：" class="headerlink" title="需求规格说明的特点："></a>需求规格说明的特点：</h2><h3 id="1）完整性"><a href="#1）完整性" class="headerlink" title="1）完整性"></a>1）完整性</h3><p>不能遗漏任何需求或必要的信息。</p><p>需求遗漏问题很难被发现，因为它们并没有列出来，着重于用户任务而不是系统功能会有助于避免遗漏需求。</p><h3 id="2）一致性"><a href="#2）一致性" class="headerlink" title="2）一致性"></a>2）一致性</h3><p>需求的一致性是指需求不会与同一类型的其他需求或更高层次的业务、系统或用户需求发生冲突。</p><p>必须在开发前解决需求不一致的问题。只有经过调查才能知道需求正确与否。</p><h3 id="3）可修改性"><a href="#3）可修改性" class="headerlink" title="3）可修改性"></a>3）可修改性</h3><p>必须能够对SRS作必要的修订，并可以为每项需求维护修改的历史记录。</p><p>这要求对每项需求进行唯一标识，与其他需求分开表述，从而能够明确地提及它。</p><p>每项需求只能在SRS中出现一次。</p><p>如果有重复的需求，很容易因为只修改其中一项而产生不一致。</p><h3 id="4）可跟踪性"><a href="#4）可跟踪性" class="headerlink" title="4）可跟踪性"></a>4）可跟踪性</h3><p>需求如果是可跟踪的，就能找到它的来源、它对应的设计单元、实现它的源代码以及用于验证其是否被正确实现的测试用例。</p><p>可跟踪的需求都有一个固定的标识符对其唯一标识。</p><h2 id="需求与其他软件项目过程的关系"><a href="#需求与其他软件项目过程的关系" class="headerlink" title="需求与其他软件项目过程的关系"></a>需求与其他软件项目过程的关系</h2><p>软件需求阶段在系统开发的整个生命周期中处于最基础、最重要的位置。</p><p>只有在需求分析工作做得比较扎实到位，文档经过开发方与用户方的充分参与、查验、修改、完善，才能为设计实施迈出坚实的一步。</p><p>软件需求活动用于软件项目的初始阶段，它的结果接着用于开发的下一个阶段，即设计阶段。</p><p>随着更强调迭代的方法学的出现，需求活动的使用被扩展到每一个开发迭代过程中，而且需求分析和设计的界限也变得模糊。</p><p>软件需求阶段是以真实世界建模为对象，并找出系统要处理什么的过程。</p><p>此阶段需要把一组复杂的需求分解为基本元素和关系，之后的解决方案建立在这些元素和关系的基础之上。</p><p>此阶段的结果是生成软件需求规格说明。</p><p>根据项目的大小不同，需求规格说明的详细程度各异，但是即使是最小的项目，也应该有某种成文的需求规格说明供开发团队使用。</p><p>需求过程中最为困难工作是编写详细技术需求，这包括所有面向用户、面向机器和其他软件系统的接口等。</p><p>这个过程一旦做错，将最终给系统带来极大损害，并且以后再对它进行修改也极为困难。</p><p><img src="/.imgs%E5%9B%BE%E7%89%871.png" alt="img"></p><h2 id="需求与各过程间的关系"><a href="#需求与各过程间的关系" class="headerlink" title="需求与各过程间的关系"></a>需求与各过程间的关系</h2><h3 id="（1）需求与制订项目计划关系"><a href="#（1）需求与制订项目计划关系" class="headerlink" title="（1）需求与制订项目计划关系"></a>（1）需求与制订项目计划关系</h3><p>需求是制订项目计划的<strong>基础</strong>，开发资源和进度安排的预估都要建立在对最终产品的真正理解之上。</p><p>项目计划所指出的所有希望特性不可能在允许的资源和时间内完成，因此，需要缩小项目范围或采用版本计划对功能特性进行选择。</p><h3 id="（2）需求与项目跟踪和控制关系"><a href="#（2）需求与项目跟踪和控制关系" class="headerlink" title="（2）需求与项目跟踪和控制关系"></a>（2）需求与项目跟踪和控制关系</h3><p>在项目实施过程中，<strong>要监控每项需求的状态</strong>，以便项目管理者能发现设计和验证是否达到预期的要求。</p><p>如果没有达到，管理者通常请求变更控制过程来进行范围的缩减。</p><h3 id="（3）需求与变更控制关系"><a href="#（3）需求与变更控制关系" class="headerlink" title="（3）需求与变更控制关系"></a>（3）需求与变更控制关系</h3><p>在需求编写成文档并制订基线以后，所有后续的变更都应通过确定的变更控制过程来进行。</p><h3 id="（4）需求与系统测试关系"><a href="#（4）需求与系统测试关系" class="headerlink" title="（4）需求与系统测试关系"></a>（4）需求与系统测试关系</h3><p>用户需求和功能需求是系统测试的重要参考。</p><p>如果未清楚说明产品在多种多样条件下的期望行为，系统测试者将很难确定正确的测试内容。</p><p>系统测试是一种方法，可以验证计划中所列的功能是否按预期要求实现了。</p><p>测试也验证了用户任务是否能正确执行。</p><h3 id="5）需求与用户编制文档关系"><a href="#5）需求与用户编制文档关系" class="headerlink" title="5）需求与用户编制文档关系"></a>5）需求与用户编制文档关系</h3><p><strong>软件需求是编写文档的重要参考</strong>，低质量和拖延的需求会给编写用户文档带来极大的困难，需求文档是所有设计、实现工作的基础。</p><h3 id="（6）需求与构造过程关系"><a href="#（6）需求与构造过程关系" class="headerlink" title="（6）需求与构造过程关系"></a>（6）需求与构造过程关系</h3><p>构成软件项目的主要产品是交付可执行软件，而不是需求说明文档。</p><p>要根据功能需求来确定设计模块，而模块又要作为编写代码的依据。</p><p>采用设计评审的方法来确保设计正确地反映了所有的需求。而代码的单元测试能确定是否满足了设计规格说明和相关的需求。</p><h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a><strong>本章小结</strong></h2><p>（1）软件需求的定义：给出了几种主要的软件需求定义和软件需求定义的一些基本原则。</p><p>（2）需求的层次：需求包括三个不同的层次，它们是：业务需求、用户需求和软件需求</p><p>（3）软件需求的分类：软件需求可以分为：功能需求、非功能需求和设计约束三种类型。</p><p>（4）高质量软件需求的好处及好的软件需求具有的特点。</p><p>（5）需求与其他软件项目过程的关系。</p><h1 id="第2章-用户眼中的软件需求"><a href="#第2章-用户眼中的软件需求" class="headerlink" title="第2章 用户眼中的软件需求"></a>第2章 用户眼中的软件需求</h1><p>软件需求来源于用户，用户是能够直接或间接从软件产品中获益的个人或组织。</p><p>软件用户可能提出需求、出钱、选择、说明、使用或者接收软件产品的输出。</p><h2 id="用户”是一种泛称，它可细分为："><a href="#用户”是一种泛称，它可细分为：" class="headerlink" title="用户”是一种泛称，它可细分为："></a>用户”是一种泛称，它可细分为：</h2><ul><li>“客户”（customer） 掏钱买软件产品的用户称为客户；</li><li>“最终用户”（the end user）真正操作软件产品的用户叫最终用户。</li><li>“间接用户”（或称为关系人）。既不掏钱买该软件产品，也不使用该软件，但是它可能对软件产品有很大的影响。<ul><li>例如：财务软件，开发商在把“财务软件”卖给客户之前，必须得到国家财政部的批准。否则，即使该软件的功能是完美的，但却被政府认为是非法的。所以，国家财政部就是所有财务软件的间接用户。</li><li>又例如：市面上流通的信息安全软件、杀病毒软件必须得到国家公安部的批准，否则不能销售</li></ul></li></ul><p>优秀的软件产品建立在优秀的需求基础上，而高质量的需求来源于用户与开发者之间的有效沟通与合作。</p><p>协同合作要想取得成果，需要所有人员都清楚自己的需要，理解并尊重其他合作者的需求。</p><p>通常用户与开发者要建立合作伙伴关系。</p><h2 id="十项软件客户权利清单"><a href="#十项软件客户权利清单" class="headerlink" title="十项软件客户权利清单"></a>十项软件客户权利清单</h2><ol><li>要求需求分析员使用客户的语言进行交流</li><li>要求需求分析员了解客户的业务和目标</li><li>要求需求分析员用适合的形式记录需求</li><li>要求需求分析员解释需求过程生成的所有工作结果</li><li>要求需求分析员和开发人员尊重客户，并以合作和专业的态度与客户进行互动。</li><li>要求需求分析员和开发人员为需求和产品实现提供思路和备用方案</li><li>要求开发人员实现能让产品使用起来更容易、更有趣的特性</li><li>调整需求，便于重用已有的软件组件</li><li>在提出需求变更时，获得对变更的成本、影响及二者权衡关系的真实评估</li><li>获得满足功能和质量要求的系统，这些要求必须事先告知开发人员并征得其同意</li></ol><h2 id="十项客户的需求义务清单"><a href="#十项客户的需求义务清单" class="headerlink" title="十项客户的需求义务清单"></a>十项客户的需求义务清单</h2><ol><li>为需求分析员和开发人员讲解业务并定义业务术语</li><li>提供需求，阐明需求，通过与开发人员的交互将需求充实完善</li><li>对系统需求的描述必须详细、准确</li><li>需要时，及时对需求做出决定</li><li>尊重开发人员对需求成本和可行性的评估</li><li>与开发人员协作，为功能需求、系统特性和用例设置优先级</li><li>审阅需求文档，评估原型</li><li>发现需要变更需求时，及时与开发人员沟通</li><li>按照开发组织的变更控制过程提出需求变更</li><li>尊重需求分析员在需求工程中使用的过程</li></ol><h2 id="对需求达成一致"><a href="#对需求达成一致" class="headerlink" title="对需求达成一致"></a>对需求达成一致</h2><p>对在建产品的需求达成一致或是在某部分达成一致是客户和开发人员关系的核心。</p><p>涉及的多个角色应形成如下共识：</p><ul><li>客户承认需求描述了他们的需要。</li><li>开发人员承认理解需求，并且认为它们是可实现的。</li><li>测试人员承认需求是可验证的。</li><li>管理层承认需求可以达成他们的业务目标。</li></ul><h1 id="第3章-需求工程"><a href="#第3章-需求工程" class="headerlink" title="第3章  需求工程"></a><strong>第3章  需求工程</strong></h1><p>需求工程分为：需求开发和需求管理两部分。</p><p>需求分析是需求开发的其中一个环节，确立了需求工程与软件工程是同等重要的观念。</p><p>需求工程：是确保软件需求质量的。</p><p>软件工程：是确保软件开发质量的。</p><p>一个软件项目要想成功，必须握有需求工程和软件工程这两把利剑在手。</p><p>需求工程：是随着计算机的发展而发展的。</p><p>在计算机发展的初期，软件规模不大，软件开发所关注的是代码编写，软件需求很少受到重视。</p><p>随着软件系统规模的扩大，软件需求分析与定义在整个软件开发与维护过程中越来越重要，直接关系到软件的成功与否。</p><p>人们逐渐认识到软件需求活动不再仅限于软件开发的最初阶段，它贯穿于系统开发的整个生命周期。</p><p>需求工程：是用已证实有效的技术和方法进行需求分析、确定客户需求、帮助分析人员理解问题，并定义目标系统的所有外部特征的一门学科。</p><p>需求工程：通过合适工具和记号，描述待开发系统及其行为特征和相关约束，形成需求文档，并对用户不断变化的需求演进给予支持。</p><p>需求工程：可分为：系统需求工程和软件需求工程。</p><p>系统需求工程，将软件需求开发和系统需求开发结合起来，在系统工程的开始阶段起到重要的作用。</p><p>软件需求工程，是一门分析并记录软件需求的学科，它把系统需求分解成一些主要的子系统和任务，把这些子系统或任务分配给软件，并通过一系列重复的分析、设计、比较研究、原型开发，把这些系统需求转换成软件的需求描述和性能参数。</p><p>需求工程定义：</p><p>Davis的定义：“直到(但不包括）把软件分解为实际架构组建之前的所有活动”，即软件设计之前的一切活动。</p><p>Brays的定义：认为需求工程是“对问题域及需求做调查研究和描述，设计满足系统的特性，并用文档给予说明。这个定义明确指出了需求工程的任务就是获取、分析和表达软件的需求”</p><p>HerbKrasner（赫克拉斯纳）定义了五阶段生命周期：</p><ol><li>需求定义和分析</li><li>需求决策</li><li>形成需求规格</li><li>需求实现与验证</li><li>需求演进管理</li></ol><p>需求工程：主要是抽取需求、模拟和分析需求、传递需求、认可需求和进化需求。</p><p>需求工程的定义：主要是抽取需求、模拟和分析需求、传递需求、认可需求和进化需求。每个活动都有它基本的动机、任务和结果，也有各自的困难所在。</p><p>需求工程的组成：需求开发和需求管理两部分。</p><p>Ø需求开发包括：需求获取、需求分析、形成需求规格、需求确认。</p><p>Ø需求管理包括：需求变更控制、版本控制、需求跟踪、需求状态跟踪。</p><p>初始循环</p><p>脉络循环</p><p>细节循环</p><h1 id="第四章-需求获取"><a href="#第四章-需求获取" class="headerlink" title="第四章 需求获取"></a>第四章 需求获取</h1><p>需求获取阶段的任务：就是获取用户的需求信息。</p><p>需求获取：是软件需求的早期活动，也是十分重要的一步。</p><p>由于需求获取是软件开发中最困难、最关键、最易出错和最需要交流的活动，故其只能通过用户与需求分析员之间进行高度的合作和交流才能成功。</p><h2 id="需求获取阶段的活动可分为："><a href="#需求获取阶段的活动可分为：" class="headerlink" title="需求获取阶段的活动可分为："></a>需求获取阶段的活动可分为：</h2><ol><li>确定需求开发计划</li><li>确定项目的目标和范围</li><li>确定调研对象</li><li>需求信息收集</li></ol><p>需求开发计划的任务：是确定需求开发的实施步骤，给出收集需求活动的具体安排和进度。</p><p>软件需求：是分析、理解和描述用户的需求，着重于软件系统“做什么”，而不是如何实现软件系统。</p><p>为了保证软件需求有充分的时间和经费，在安排软件需求的实施步骤、收集需求活动的进度时，只能考虑与需求开发相关的工作。</p><p>否则，将会导致软件需求花费的时间过长、成本过高，不利于有效地进行软件需求的活动。</p><p>在安排进度时，应考虑困难性和灵活性。</p><p>例如：在收集用户需求的活动中，由于用户可能出差或开会，不一定能保证在规定的时间内进行交流，因此，需要与用户预约时间，及时调整时间和计划。</p><p>此外，书写和整理需求规格说明也是需花费时间的，故在安排进度和时间时应予以考虑。</p><p>项目目标和范围的基本任务是：</p><p>—— 根据项目目标把项目相关人员定位到一个共同的和明确的方向上，并决定软件系统的范围。</p><p>项目的目标主要包括：</p><p>—— 项目开发的目的和意义，以及软件系统应实现的业务需求。</p><p>项目的范围：</p><p>—— 是指软件系统具体应包括和不应包括的部分，以及软件系统所涉及的各个方面。</p><p>如：计算机硬件和其他软件系统等，即软件系统在一个完善的环境中最终具有的功能。</p><p>项目的业务需求代表了需求层次中最高层的需求，为软件系统定义了作用的范围。</p><h2 id="需求信息的类型"><a href="#需求信息的类型" class="headerlink" title="需求信息的类型"></a>需求信息的类型</h2><ol><li>业务需求<ol><li>描述用户或开发机构，通过产品可获得的利益和利润。</li><li>以及与产品相关的发展规划等方面的信息。</li></ol></li><li>用例说明</li><li>业务规则。有关业务过程的操作原则。</li><li>功能需求。定义了系统应该做什么，它们是软件需求规格说明的一部分。</li><li>性能需求</li><li>外部接口需求</li><li>约束<ol><li>约束：是指一些合理限制设计者和程序员选择的条件。</li><li>约束：必须写入软件需求规格说明。</li><li>施加不必要的约束，将妨碍提出一个好的解决方案，将会降低利用现有商业化软件集成解决方案的能力，</li><li>一定的约束有助于提高产品质量。</li></ol></li><li>数据定义<ol><li>当客户描述一个数据项，或一个复杂的业务数据结构的格式、允许值或默认值时，就是在进行数据定义。</li><li>把这些集中在一个数据词典中，作为项目参与者在整个项目的开发和维护中的主要参考文档。</li></ol></li><li>解决方案<ol><li>如果一个客户描述了用户与系统交互的特定方法，使系统产生一系列活动，这时，就是在听取建议性的解决方案，而不是需求。</li></ol></li></ol><h2 id="需求收集中应注意的问题"><a href="#需求收集中应注意的问题" class="headerlink" title="需求收集中应注意的问题"></a>需求收集中应注意的问题</h2><ol><li>应能适当地调整收集范围<ul><li>在收集需求的开始，需求分析员并不知道用户需求量的大小，可以根据系统的范围适当扩大收集范围。</li><li>收集的范围不能过于扩大，因为范围扩大，收集的需求有些可能不是真正的需求，将导致分析员要花费大量的精力和时间，来理解和分析这些需求。</li><li>收集的范围也不能太小，否则有些重要需求会被遗漏或排除在外。</li></ul></li><li>弄清楚用户所做的假设和冲突。<ul><li>尽量把用户所做的假设解释清楚，特别是发生冲突的部分。这就需要根据用户的信息去理解。</li><li>以明确用户没有表达清楚的需求。</li></ul></li><li>理解用户的思维过程、专业知识和术语。<ul><li>尽量理解用户的思维过程，特别是尽量熟悉和掌握用户具有的一些专业知识和术语。</li></ul></li><li>避免受不熟悉细节的影响。</li><li>避免讨论一些具体的解决方案。</li><li>需求收集工作的结束。<ul><li>如何决定收集工作的结束，并没有一个简单和严格的标准，需根据实际情况进行判断。</li><li>eg<ul><li>用户不可能再提供更多新的需求信息。</li><li>用户重复提出以前已提出的需求信息。</li><li>与用户的讨论开始进入设计方面的工作。</li><li>需求分析员本身已提不出更多的问题。</li><li>安排收集工作的结束时间已到。</li></ul></li></ul></li><li>非功能需求的确定<ul><li>非功能需求：是衡量软件能否良好运行的定性指标。</li><li>非功能需求：也是非常重要的。</li><li>可靠性、可扩展性、安全性、互操作性、易使用性、可维护性、用户界面友好等。</li><li>必须根据用户对系统的期望来确定非功能需求。</li></ul></li><li>收集非功能需求的一些方法：<ol><li>将不同用户类代表，提出的可能很重要的非功能需求进行综合，并根据其中的每个需求设计出许多方法，然后，根据用户的回答，使这些需求更明确。</li><li>需求分析员与用户一起对每一个非功能需求，制定可测试和可验证的具体标准。如果这些需求缺乏评价标准，就无法说明开发出的软件系统是否已满足这些需求。</li><li>设计与非功能需求相冲突的假设示例，利用反例来提示用户。</li></ol></li></ol><h2 id="需求获取方法"><a href="#需求获取方法" class="headerlink" title="需求获取方法"></a>需求获取方法</h2><ol><li>面向目标的方法<ul><li>目标是用户所期望达到的目的。</li><li>层次性是目标的一个重要特征。</li><li>从高层来说，目标是抽象的问题描述。</li><li>从底层来说，则是具体的实现方式，即技术需求描述。</li><li>这有利于需求的逐步精化，通过需求对高层目标的可追溯性，建立起软件需求与业务目标的关系。</li><li>因此，面向目标方法不仅被用来进行需求获取、分析，还被应用于需求协商等领域。</li></ul></li><li>面向目标的方法的优点有：<ol><li>容易理解和交流，可以保证需求的完整性、避免无关的需求。</li><li>目标本身所具有的层次关系，使得需求文档更加结构化，增强了可读性。</li><li>有助于将软件需求与业务环境联系起来，有助于解决多视点之间的冲突。</li><li>由于目标方法可以将稳定的需求和经常变化需求区分开，有利于需求的管理。</li></ol></li><li>基于场景的方法<ul><li>基于场景的方法：是通过应用环境的某一特定情景的描述，来阐述用户的需求。</li><li>由于这一方法非常便于涉众之间的交流，并且提供了一种将需求与实际经验相结合的机制，因此，对于需求的获取和确认有很大的帮助。</li><li>基于场景的方法：目前应用最广泛的一种就是基于用例的方法。<ul><li>用例是从用户的观点、以交互的方式，对于系统的行为特征进行的描述，而场景一般认为是用例的一个实例。</li></ul></li></ul></li><li>面向视点的方法<ul><li>视点是对于涉众局部观察角度的一种抽象。</li><li>在多视点需求工程中，需求分析人员从一组涉众处获取各局部需求，并将其进行整合。</li><li>多视点需求工程方法认为，需求之间的冲突往往是由于涉众视点不同所导致的。</li><li>因此，完整、一致地发现和集成视点，是获得高质量需求的关键。</li><li>多视点方法适应于涉众视角的局部性和分布性特征，反映各种涉众的需求。</li></ul></li><li>基于知识的方法<ul><li>软件开发是一个知识密集型的活动，知识在其中起到关键的作用。</li><li>基于知识的方法的出发点，是希望利用历史项目中，积累的经验或领域分析的结果，来帮助人们理解和获取需求。</li><li>事实上，大多数的需求获取方法，都或多或少地用到这一类方法。</li></ul></li><li>面向方面的方法<ul><li>面向方面的软件开发：是使横切关注点更好地分离的一种技术。</li><li>在面向方面的编程中，对于“横切”给出这样的定义：如果被构建的两个属性，必须以不同的方式构造，但它们之间又需要被协同，那么它们彼此横切。</li><li>把问题分解为更小的部分，称为关注点分离。</li><li>通过对关注点的分离，有助于从不同角度对软件系统进行理解、维护和扩展。</li><li>面向方面的方法：在近年来被提出，并受到了研究者的重视。</li><li>通常将功能需求作为一组基础，而将非功能需求作为方面级的需求。</li><li>面向方面的方法：从编程方法发展而来，它的基本思想和多视角的方法有相似之处，目前，较为成功的应用主要集中在需求的实现。</li><li>由于需求之间的关系往往错综复杂，因此，对横切需求的识别仍然是一个难题。</li></ul></li></ol><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><h3 id="需求获取阶段的任务："><a href="#需求获取阶段的任务：" class="headerlink" title="需求获取阶段的任务："></a>需求获取阶段的任务：</h3><p>—— 就是获取用户的需求信息。通过用户与需求分析员之间进行高度的合作和交流才能成功。</p><h3 id="需求开发计划："><a href="#需求开发计划：" class="headerlink" title="需求开发计划："></a>需求开发计划：</h3><p>—— 需求开发计划的任务：是确定需求开发的实施步骤，给出收集需求活动的具体安排和进度。</p><h3 id="项目的目标和范围"><a href="#项目的目标和范围" class="headerlink" title="项目的目标和范围"></a>项目的目标和范围</h3><p>—— 项目的目标主要包括： 项目开发的目的和意义，以及软件系统应实现的业务需求。</p><p>—— 项目的范围： 是指软件系统具体应包括和不应包括的部分，以及软件系统所涉及的各个方面。</p><h3 id="需求调研对象：主要是：用户"><a href="#需求调研对象：主要是：用户" class="headerlink" title="需求调研对象：主要是：用户"></a>需求调研对象：主要是：用户</h3><p>根据用户的某些方面将用户分类：</p><p>根据用户所在的部门和职责分类。</p><p>   —— 如：计划部门、销售部门、财务部门等。</p><p>根据用户使用系统的频繁度和优先级等分类。</p><p>根据用户掌握的计算机知识和使用计算机的熟练程度分类。</p><p>根据直接使用和非直接使用软件系统的情况分类。</p><h3 id="确定需求来源"><a href="#确定需求来源" class="headerlink" title="确定需求来源"></a>确定需求来源</h3><p>典型的软件需求来源有以下几方面：</p><p>1）直接和间接使用软件系统的用户。</p><p>2）系统需求规格说明。</p><p>3）市场调研和用户问卷调查。</p><p>4）已开发出的和待开发的同类软件系统的描述和文档。</p><p>5）人工系统中存在的问题报告。</p><p>6）观察正在工作的用户。</p><p>7）用户工作内容的分析。</p><h3 id="需求调研的三个步骤："><a href="#需求调研的三个步骤：" class="headerlink" title="需求调研的三个步骤："></a>需求调研的三个步骤：</h3><p>1）向掌握“全局”的负责人调研</p><p>2）向部门负责人调研</p><p>3）向业务人员调研</p><h3 id="明确需求信息的决策者"><a href="#明确需求信息的决策者" class="headerlink" title="明确需求信息的决策者"></a>明确需求信息的决策者</h3><p>决策者能根据具体情况，对存在问题需求信息做出决定。</p><p>决策者并不是固定不变的，而是根据实际中可能发生的具体问题来确定。</p><h3 id="需求信息收集面临的困难"><a href="#需求信息收集面临的困难" class="headerlink" title="需求信息收集面临的困难"></a>需求信息收集面临的困难</h3><p>需求信息收集并不是件容易的工作，需求分析员要与用户进行充分的交流，听取用户对软件系统的看法和意见。</p><p>但在与用户交流的过程中并非是十分顺利的，特别是需要用户花费时间来讲解他们的业务流程和工作内容。</p><h3 id="需求信息收集的方式。"><a href="#需求信息收集的方式。" class="headerlink" title="需求信息收集的方式。"></a>需求信息收集的方式。</h3><p>1）座谈会的方式</p><p>2）书面咨询的方式</p><p>3）利用用例表示方法</p><h3 id="需求信息的类型有9种。"><a href="#需求信息的类型有9种。" class="headerlink" title="需求信息的类型有9种。"></a>需求信息的类型有9种。</h3><p>1.业务需求</p><p>2.用例说明</p><p>3.业务规则</p><p>4.功能需求</p><p>5.性能需求</p><p>6.外部接口需求</p><p>7.约束</p><p>8.数据定义</p><p>9.解决方案</p><h3 id="需求收集中应注意的一些问题："><a href="#需求收集中应注意的一些问题：" class="headerlink" title="需求收集中应注意的一些问题："></a>需求收集中应注意的一些问题：</h3><p>1）应能适当地调整收集范围。</p><p>2）尽量把用户所做的假设解释清楚，特别是发生冲突的部分。这就需要根据用户的信息去理解，以明确用户没有表达清楚的需求。</p><p>3）尽量理解用户的思维过程，特别是尽量熟悉和掌握用户具有的一些专业知识和术语。</p><p>4）在收集需求信息时，应尽量避免受不熟悉细节的影响。</p><p>5）应尽量避免讨论一些具体的解决方案，因为需求阶段的工作，是要弄清楚软件系统做什么，而不是怎么做。</p><p>6）需求收集工作的结束。</p><h3 id="非功能需求：-1"><a href="#非功能需求：-1" class="headerlink" title="非功能需求："></a>非功能需求：</h3><p>非功能需求：是衡量软件能否良好运行的定性指标。</p><p>如：可靠性、可扩展性、安全性、互操作性、易使用性、可维护性、用户界面友好等。</p><h3 id="收集非功能需求使用的3种方法："><a href="#收集非功能需求使用的3种方法：" class="headerlink" title="收集非功能需求使用的3种方法："></a>收集非功能需求使用的3种方法：</h3><p>将重要非功能需求进行综合，并根据其中的每个需求设计出许多方法，根据用户的回答，使这些需求更明确。</p><p>方法2：需求分析员与用户一起对每一个非功能需求，制定可测试和可验证的具体标准。</p><p>方法3：设计与非功能需求相冲突的假设示例，利用反例来提示用户。</p><h3 id="需求获取方法：有5种"><a href="#需求获取方法：有5种" class="headerlink" title="需求获取方法：有5种"></a>需求获取方法：有5种</h3><ol><li>面向目标的方法</li><li>基于场景的方法</li><li>面向视点的方法</li><li>基于知识的方法</li><li>面向方面的方法</li></ol><h1 id="第5章-需求分析"><a href="#第5章-需求分析" class="headerlink" title="第5章 需求分析"></a>第5章 需求分析</h1><h2 id="需求分析的任务"><a href="#需求分析的任务" class="headerlink" title="需求分析的任务"></a>需求分析的任务</h2><p>通过需求获取阶段的工作，软件开发人员从用户处收集到大量的需求信息。</p><p>这些需求信息并不完全都是真正的需求。</p><p>需求分析的<strong>基本任务</strong>：就是<strong>分析和综合</strong>已收集到的需求信息。</p><p><em>分析</em>：在于透过现象看本质，找出这些需求信息间的内在联系和可能的矛盾。</p><p><em>综合</em>：就是去掉那些非本质的信息，找出解决矛盾的方法，并建立系统的逻辑模型。</p><p><strong>具体地说</strong>，需求分析的基本任务：就是<strong>提炼、分析和仔细审查已收集到的需求信息</strong>，找出真正的和具体的需求，以确保所有项目相关人员都明白其含义。</p><p>在分析过程中，通过建立软件系统的逻辑模型，发现或找出需求信息中存在的冲突、遗漏、错误或含糊问题等。</p><p>需求分析阶段工作结果：是获得高质量的具体软件需求。</p><p>需求分析的<strong>具体工作包括</strong>：</p><ul><li>建立系统关联图；</li><li>分析需求的可行性；</li><li>构建用户分析原型；</li><li>确定需求的优先级；</li><li>需求建模；</li><li>建立数据词典。</li><li>对于较为简单的系统，确定需求优先级等工作可以考虑不施行。</li></ul><h2 id="系统关联图的建立"><a href="#系统关联图的建立" class="headerlink" title="系统关联图的建立"></a>系统关联图的建立</h2><p>在需求获取阶段，首先确定收集需求信息的范围，提高需求获取效率，把项目相关人员定位到一个共同的、明确的方向上。</p><p><strong>建立系统关联图：主要是根据需求获取阶段确定的系统范围，用图形表示系统与外部实体间的关联。</strong></p><p><em>关联图：就是用于描述系统与外部实体间的<strong>界限和接口</strong>的模型，而且明确通过接口的信息流和物质流</em></p><p>关联图的建立：</p><ul><li>把整个要开发的系统表示为一个椭圆，椭圆内标识系统的名字。</li><li>用箭头表示系统与外部实体间的关系和信息流向。</li><li>用矩形框表示系统外部实体。</li></ul><p>关联图：不明确描述系统的内部过程和数据。</p><p>EG</p><p>某培训中心的主要工作是为本行业在职人员提供课程培训服务。有兴趣的本行业职工可以通过电子邮件、信函等报名、选修或注销课程，或询问课程计划等。培训中心收取一定的培训费用，学费可以用现金或支票形式支付。</p><p>该系统应具有记录和分类由电子邮件或信函表达的信息，处理报名、询问、注销和付款，以及输出回答信息的功能。</p><p>该系统外的实体主要是学员和系统的操作员等。</p><p>系统的关联图，如图所示。</p><p><img src="/.imgs2.png"></p><p>建立关联图的目的：是项目相关人员一开始不必去考虑太多的细节，而是把注意力集中在软件系统的接口方面。</p><ul><li>即系统的输入&#x2F;输出上，从而确定系统的界限，并为分折用户需求提供很好的依据，特别是在功能需求方面。</li></ul><p>关联图：以图形方式表示系统的范围，使得项目相关人员更易于理解和审查。</p><p>如果某些需求不可实施，例如：开发环境的支持，或技术实现有困难，或处理效率较低等，都应尽早与用户讨论和协商。</p><p>分析需求可行性的基本任务：是在允许的成本和性能要求以及系统的范围内，分析每项需求得以实施的可能性。</p><p>分析需求可行性的目的：在于明确与每项需求相关联的风险，包括：一些与其它方面的冲突、对外部环境的依赖和某些技术的障碍等。</p><p>分析需求可行性：是一项困难的工作，不存在对所有类型的需求都适用的分析方法。</p><p>分析需求可行性：需要与有经验的开发人员共同分析。</p><p>对于要开发的软件系统，由于涉及不可知因素，进行需求可行性分析，有助于避免后期开发过程中的一些问题。</p><p>与高风险相关的需求，最有可能导致软件开发工作的失败。</p><h2 id="考虑的风险类型"><a href="#考虑的风险类型" class="headerlink" title="考虑的风险类型"></a>考虑的风险类型</h2><ol><li>性能风险：实现这项需求，可能导致整个系统性能的下降。</li><li>安全风险：实现这项需求，可能导致无法满足整个系统的安全需求。</li><li>过程风险：实现这项需求，可能导致需要对常规的开发过程做修改。</li><li>实现技术风险：实现这项需求，可能需要使用不熟悉的实现技术。</li><li>数据库风险：实现这项需求，可能导致系统不支持的非标准数据。</li><li>日程风险：实现这项需求，可能遇到技术困难，并危及系统原定的开发日程。</li><li>外部接口风险：实现这项需求，可能涉及外部接口。</li><li>稳定风险：这项需求可能是易变的，将导致开发过程的重大变动。</li></ol><p>在实际工作中，通常使用定性的方法。</p><p>如：分类为：</p><ul><li>“高”</li><li>“中”</li><li>“低”</li></ul><h2 id="建立用户分析原型"><a href="#建立用户分析原型" class="headerlink" title="建立用户分析原型"></a>建立用户分析原型</h2><p>在需求建模前，需要澄清一些不能确定的或含糊的需求，尽早使这些需求能完整和清楚地表达出来。</p><p>创建用户分析原型的基本任务：是对于软件开发人员或用户不能明确化的需求，通过建立相应的用户分析原型，然后，评估该原型，使得项目相关人员能更好理解所要解决的问题。</p><p>用户分析原型：是指一个可能的局部实现，而不是整个系统，这样可使许多概念和可能发生的事更为直观明了。</p><h2 id="需求优先级分析"><a href="#需求优先级分析" class="headerlink" title="需求优先级分析"></a>需求优先级分析</h2><p>划分需求优先级可以帮助项目相关人员判断系统的核心需求，并有助于项目相关人员集中于重点问题的交流和协商，特别是涉及需求风险分析的时候。</p><p>需求优先级之间的关联，可以帮助软件开发人员决定软件体系结构，还可以帮助解决可能发生的设计冲突。</p><p>软件开发人员可以根据需求优先级，权衡合理的项目范围和进度安排、预算、人力资源以及质量目标的要求。</p><p>实现权衡的方法是，当接受一个新的高优先级的需求或者项目发生环境变化时，删除低优先级的需求，或者将其推迟到下一版本去实现。</p><p>在需求获取的理想情况下，开发人员应在客户表达需求时，由用户决定需求的重要性，标上需求的优先级。</p><p>如果单独让用户来决定需求的优先级是很难做到的，在众多具有不同期望的用户之间，达到一致意见就更难了。</p><p>优先级的分配，应当由软件开发人员和项目相关人员共同完成，最好是在做了一些初始的分析工作后，再进行需求优先级的分配。</p><p>在很多情况下，对同一需求，不同的项目相关人员会分配不同的优先级。</p><p>这可能反映了实际的需要，也可能只是简单地反映了不同项目相关人员各自的理解。</p><p>因此，必须消除这些差异，并在分配的每一类优先级的含义上达成一致意见。</p><h2 id="需求建模"><a href="#需求建模" class="headerlink" title="需求建模"></a>需求建模</h2><p>需求建模：就是导出目标系统的逻辑模型或需求模型，以明确目标系统“做什么”的问题。</p><p>目标系统：是指待开发的软件系统。</p><p>在已知需求的可行性以及各个需求明确以后，为了更好地理解需求，特别是复杂系统的需求，软件开发人员应从不同的角度，抽象出目标系统的特性，</p><p>使用精确的方法构造系统的模型，验证模型是否满足用户的需求，并在设计过程中，逐渐把与实现相关的细节加进模型，直至最终用程序实现模型。</p><p>模型，就是为了理解事物而对事物作出的一种抽象，是对事物的一种无歧义的书面描述。</p><p>模型：可由文本、图形符号或数学符号以及组织这些符号的规则组成。</p><p>需求建模，就是把由文本表示的需求和由图形或数学符号表示的需求结合起来，绘制出对目标系统的完整性描述，以检测软件需求的一致性、完整性和错误等。</p><p>利用图形表示需求，有助于增强项目相关人员对需求的理解，对于某些类型的信息。</p><p>图形表示方式可以使项目相关人员之间减轻语言和词汇方面的负担。</p><p>建立需求模型的目的：是为了增强对用自然语言描述的需求规格说明的理解，而不是替换它。</p><p>在需求建模中，使用什么方法取决于建模的目的、时间和应用领域等。</p><h3 id="常见的需求分析方法有"><a href="#常见的需求分析方法有" class="headerlink" title="常见的需求分析方法有"></a>常见的需求分析方法有</h3><ol><li>结构化分析方法（Structured Analysis, SA）</li><li>面向对象方法</li><li>面向问题域的分析方法</li><li>面向特征的需求分析方法</li><li>基于本体的需求分析方法</li><li>面向多视点的需求分析方法</li></ol><h2 id="数据词典"><a href="#数据词典" class="headerlink" title="数据词典"></a>数据词典</h2><h3 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a>定义：</h3><p>目标系统中使用的所有数据元素和结构的含义、类型、数量值、精度及允许取值范围的共享数据仓库。</p><h3 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h3><p>是确保软件开发人员使用统一的数据定义，可提高需求分析、设计、实现和维护过程中的可跟踪性。</p><p>为避免冗余和不一致性，每个项目建立一个独立的数据词典，而不是在每个需求出现的地方定义每个数据项。</p><p>数据词典：把不同的需求文档和需求模型紧密地结合到一起。</p><p>数据词典中的每个数据项对应一项记录，并根据实际情况使用简单的符合予以定义</p><h2 id="Summary-1"><a href="#Summary-1" class="headerlink" title="Summary:"></a>Summary:</h2><p>1）需求分析的任务：</p><p>就是分析和综合已收集到的需求信息。</p><p>分析：在于透过现象看本质，找出这些需求信息间的内在联系和可能的矛盾。</p><p>综合：就是去掉那些非本质的信息，找出解决矛盾的方法，并建立系统的逻辑模型。</p><p>（2）关联图：</p><p>就是用于描述系统与外部实体间的界限和接口的模型，而且明确通过接口的信息流和物质流。</p><p>（1）分析需求可行性的基本任务：</p><p>是在允许的成本和性能要求以及系统的范围内，分析每项需求得以实施的可能性。</p><p>（2）这项工作的目的：</p><p>在于明确与每项需求相关联的风险，包括：一些与其它方面的冲突、对外部环境的依赖和某些技术的障碍等。</p><p>（3）在需求分析中应考虑的风险类型：</p><p>性能风险、安全风险、过程风险、实现技术风险、</p><p>数据库风险、日程风险、外部接口风险、稳定风险</p><p>（1）用户分析原型：</p><p>用户分析原型：是指一个可能的局部实现，而不是整个系统，这样可使许多概念和可能发生的事更为直观明了。</p><p>（2）划分需求优先级</p><p>可以帮助项目相关人员判断系统的核心需求，并有助于项目相关人员集中于重点问题的交流和协商。</p><p>（3）需求建模</p><p>就是导出目标系统的逻辑模型或需求模型，以明确目标系统“做什么”的问题。</p><p>（4）数据词典</p><p>是定义目标系统中使用的所有数据元素和结构的含义、类型、数量值、精度及允许取值范围的共享数据仓库。</p><h1 id="第6章-需求建模方法与技术"><a href="#第6章-需求建模方法与技术" class="headerlink" title="第6章  需求建模方法与技术"></a>第6章  需求建模方法与技术</h1><p>需求建模：是根据待开发软件系统的需求，利用某种建模方法建立该系统的逻辑模型。</p><p>也称为：需求模型或分析模型。</p><p>帮助软件开发人员检测软件需求的一致性、完全性、二义性和错误等。</p><p>在软件的实际开发中，为了表达和描述软件需求，软件开发人员使用不同的建模方法，来建立软件需求模型。</p><p>这些建模方法的作用、范围和特点不同，因此，在使用中是有所区别的。</p><h2 id="需求建模方法具备的共同特点："><a href="#需求建模方法具备的共同特点：" class="headerlink" title="需求建模方法具备的共同特点："></a>需求建模方法具备的共同特点：</h2><p>1）提供描述手段</p><p>开发一个软件系统涉及许多人，开发人员之间如何有效地进行交流是项目成功的关键之一。</p><p>在开发过程中，每个开发人员都必须将工作的结果以一定的形式记录下来，采用什么样的描述形式，对人员间的交流和继续进行下一步工作是非常重要的。</p><p>需求建模方法应该规定描述模型的手段，这包括要记录什么内容以及用什么符号来表达等。</p><p>2）提供基本步骤</p><p>开发一个软件系统，特别是大型复杂系统，要考虑的问题很多，如果同时处理这些问题，就会束手无策或者造成混乱。</p><p>正确解决问题的方法是，将问题按先后次序进行分解，每一步集中精力解决某个问题，直至所有问题被解决为止。</p><p>因此，需求建模方法需要规定基本实施步骤，确定每一步的目的，要产生什么样的结果，每步中要注意哪些概念，以及完成该步的工作需要掌握哪些必要的信息等。</p><p>在需求建模方法中，主要使用的描述手段和技术是：自然语言、图形符号语言和形式语言等。</p><h2 id="常见的软件需求模型包括"><a href="#常见的软件需求模型包括" class="headerlink" title="常见的软件需求模型包括:"></a>常见的软件需求模型包括:</h2><p>数据流图（DFD）</p><p>实体关系图（ERD）</p><p>状态转换图（STD）</p><p>用例图</p><p>类图</p><p>活动图</p><p>时序图</p><p>事件-响应表</p><table><thead><tr><th>词语类型</th><th>示 例</th><th>分析模型的组件</th></tr></thead><tbody><tr><td>名词</td><td>人员、组织机构、软件系统、数据元素、已经存在的对象</td><td>·外部实体、数据库或者数据流（数据流图，DFD）  ·参与者（用例图）  ·实体或者实体属性（实体-关系图，ERD）  ·通道（时序图）  ·带状态的对象（状态转换，STD）</td></tr><tr><td>动词</td><td>行为、用户或者系统所做的事情、能够发生的事件</td><td>·处理（数据流图，DFD）  ·处理步骤（时序图）  ·用例（用例图）  ·关系（实体-关系图，ERD）  ·转换（状态转换图，STD）  ·活动（活动图）  ·事件（事件-响应表）</td></tr><tr><td>条件</td><td>条件逻辑的陈述，如if&#x2F;then</td><td>·判定条件（决策树、决策表或者活动图）  ·分支（时序图或者活动图）</td></tr></tbody></table><h3 id="数据流图"><a href="#数据流图" class="headerlink" title="数据流图"></a>数据流图</h3><p>（Data Flow Diagram ,简称：DFD）</p><p>数据流图：用于标识一个系统中的加工处理、系统所操作的数据集合或者物理介质以及在处理、存储和系统外部之间的数据流。</p><p>数据流图：指明系统中数据是如何流动和变换的，以及描述使数据流进行变换的功能。</p><p>数据流图：是用来描绘软件系统逻辑模型的图形工具，它描绘信息和数据从输入到输出过程中，所经历的一系列变换。</p><p>数据流图：一般在软件生命周期的早期阶段开始进行分析，在软件生命周期后续阶段不断改进、完善和细化。</p><p>数据流图：非常适用于事务处理系统和其他偏重功能性的应用系统。</p><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16682551691331668255168835.png"></p><p>数据流图的绘制</p><p>一般情况下，应该遵守“由外向里”的原则。</p><p>即先确定系统的边界或范围，再考虑系统的内部，先画数据处理的输入和输出，再画数据处理内部。</p><p>也就是：</p><p>先全局，后局部；</p><p>先整体，后细节；</p><p>先抽象，后具体。</p><p>在图书预订系统中，书店向顾客发放订单，顾客将所填订单交由系统处理，系统首先依据图书目录对订单进行检查，并对合格订单进行处理，处理过程中，根据顾客情况和订单数目，将订单分为：优先订单与正常订单两种，随时处理优先订单，定期处理正常订单。最后，系统根据所处理的订单，进行汇总，并按出版社要求发给出版社。</p><p>第1步，画出顶层数据流图。</p><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16682552621251668255261204.png"></p><p>第2步，逐层分解加工，绘制1层数据流图。</p><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16682553101281668255309986.png"></p><p>第3步，绘制2层数据流图。</p><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16682553851221668255384615.png"></p><h3 id="实体-关系图"><a href="#实体-关系图" class="headerlink" title="实体-关系图"></a>实体-关系图</h3><p>（Entity Relation Diagram，简称为：E-R图）</p><p>实体-关系图的组成元素</p><p>实体-关系图：主要包含：实体、关系和属性，它创建了软件的数据模型。</p><p>实体：是现实世界中客观存在的，而且，可以相互区别的事物或活动的抽象。如：人、汽车、商品、职工等；</p><p>属性：是描述实体或关系中的一种特征。</p><p>一个实体或关系通常具有多个特征，需要多个相应属性来描述。如：学生的属性，包括：学号、姓名、性别、年龄等。</p><p>绘制实体-关系图：</p><p>用矩形表示实体，在框内写上实体名；</p><p>用椭圆形表示实体的属性，并用无向边把实体和属性连接起来；</p><p>用菱形表示实体间的关系，在菱形框内写上关系名，用无向边分别把菱形框与有关实体连接起来，在无向边旁注明关系的类型。</p><p>实体-关系图（Entity Relation Diagram，简称为：E-R图）</p><p>“学生实体和班级实体”的实体-关系图。</p><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16682556291221668255628262.png"></p><h3 id="状态转换图"><a href="#状态转换图" class="headerlink" title="状态转换图"></a>状态转换图</h3><p>（Status Transfer Diagram，简称为：STD）</p><p>状态转换图：是用于指明系统在外部事件作用下，将会如何动作，表明了系统的各种状态，以及各种状态间的转换。</p><p>状态转换图：还指明了作为特定事件的结果，系统将做哪些动作。</p><p>状态转换图的组成元素</p><p>状态转换图：由状态、事件和转换组成。</p><ul><li>状态：是任何可以被观察到的系统行为模式，一个状态代表系统的一种行为模式。<ul><li>状态主要有：初态（即：开始状态），终态（即：最终状态）和中间状态。<ul><li>初态：用实心圆表示。</li><li>终态：用一对同心圆（内圆为实心圆）表示。</li><li>中间状态：用圆角矩形表示，可以用两条水平横线，把它分成上、中、下3个部分。上面部分为状态的名称，这部分是必须有的；中间部分为状态变量的名字和值，这部分是可选的；下面部分是活动表，这部分也是可选的。</li></ul></li></ul></li><li>事件：是在某个特定时刻发生的事情，它是对引起系统做动作或从一个状态转换到另一个状态的外界事件的抽象。<ul><li>事件：就是引起系统做动作或转换状态的控制信息。<ul><li>是用箭头上的标记表示，它是引起转换的消息。</li></ul></li></ul></li><li>转换：表示状态从一种状态变为另一种状态<ul><li>用两个状态之间带箭头的连线来表示，箭头指明了转换方向。</li></ul></li></ul><p>例题：“复印机控制软件”的状态转换图。状态：闲置状态、复印状态、缺纸状态、卡纸状态。事件：复印命令、完成复印命令、发现没纸、装满纸、发生卡纸故障、故障排除。</p><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16682558781351668255877501.png"></p><h3 id="用例图"><a href="#用例图" class="headerlink" title="用例图"></a>用例图</h3><p>用例图：是用来描述<strong>系统外部执行者</strong>与其<strong>交互用例之间</strong>的关系。</p><p>用例是<strong>系统开发者和用户反复讨论的结果</strong>，描述了<strong>开发者和用户对需求规格说明所达成的共识</strong>。</p><p>用例描述了对目标系统的功能需求，并把系统看作黑盒子，从外部行为者的角度来理解系统。</p><p>用例驱动了需求分析之后各阶段的开发工作，从而影响到开发过程的各个阶段。</p><p>用例图是进行需求分析和建立系统功能模型的强有力工具。</p><p>用例图的主要元素是：系统、用例、行为者以及用例之间的关系。</p><p>例如，自动售货机系统的用例图。</p><p>自动售货机系统的用例图。</p><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16682560991251668256098456.png"></p><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p>类是：对一组对象的描述，这些对象具有相似的属性、操作、关系和行为。</p><p>类图：描述类及类与类之间的静态关系。</p><p>类图：不仅定义软件系统中的类，描述类与类之间的关系，它还表示类的内部结构（即：类的属性和操作）。</p><p>一个类可以出现在多个类图中，一个系统可以由多个类图来描述。</p><p>类图的表示符号</p><p>类图的符号是一个长方形，用两条横线把长方形分为上、中、下三个区域。这三个区域分别放类的名字、属性和操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">    class 动物</span><br><span class="line">    动物 : String 标签</span><br><span class="line">    动物 : 吃()</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">  class 银行账户</span><br><span class="line">  银行账户 : +String 户主</span><br><span class="line">  银行账户 : +BigDecimal 余额</span><br><span class="line">  银行账户 : +存(数量)</span><br><span class="line">  银行账户 : +取(数量)</span><br></pre></td></tr></table></figure><h3 id="活动图"><a href="#活动图" class="headerlink" title="活动图"></a>活动图</h3><p>活动图，用来描述<strong>用例中交错的各种流</strong>或者<strong>执行某个动作的执行者角色或者业务处理中的流程</strong>。</p><p>活动图：主要描述<strong>动作及动作的结果对象状态改变</strong>。</p><p>无须指明任何事件，只要源状态中的动作被执行了，活动图中的状态（称为动作状态）就自动开始转换。</p><p>活动图：描述交互的方式，它描述采取何种动作，动作的结果是什么（即：动作状态改变），何时发生，以及在何处发生。</p><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16682564111221668256411074.png"></p><h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><p>时序图：描述对象之间的动态交互关系，着重表现对象之间消息传递的时间顺序。</p><p>时序图有2个坐标轴：纵坐标表示时间、横坐标表示不同的对象。</p><p>注意：时序图通常有多个对象，体现对象间的时间顺序。</p><p>时序图中的对象：用一个矩形框表示，框内标有对象名，从表示对象的矩形框，向下的垂直虚线是对象的“生命线”，用于表示在某段时间内该对象的存在。</p><p>对象间的通信通过对象生命线之间的水平消息线来表示，消息箭头的形状表明消息的类型（有：同步、异步或简单）。</p><p>当收到消息时，接收对象立即开始执行活动。</p><p>即对象被激活</p><p>激活用对象生命线上的细长矩形框表示。</p><p>消息：通常用消息名和参数表来标识。</p><p>消息可以带有条件表达式，用于表示分支或决定是否发送消息。</p><p>如果用条件表达式表示分支，则会有若干个互斥的箭头，也就是说，在某一时刻仅可发送分支中的一个消息。</p><p>浏览时序图的方法是：</p><p>从上到下（即：按时间顺序）查看对象间交换的消息。</p><p>如图所示为时序图示例。</p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16682567711271668256770517.png" style="zoom:50%;" /><h3 id="决策表"><a href="#决策表" class="headerlink" title="决策表"></a>决策表</h3><p>决策表：是分析和表达多逻辑条件下，执行不同操作情况的工具。</p><p>决策表：分为四个部分</p><p>左上部列出所有条件</p><p>左下部是所有可能做的动作</p><p>右上部是表示各种条件组合的一个矩阵</p><p>右下部是和每种条件组合相对应的动作。</p><p>决策表通常有四个部分组成：</p><p>① 条件桩（Condition Stub）：列出了问题的所有条件。通常认为列出的条件的次序无关紧要。</p><p>② 动作桩（Action Stub）：列出了问题规定可能采取的操作。这些操作的排列顺序没有约束。</p><p>③ 条件项（Condition Entry）：列出针对它左列条件的取值。在所有可能情况下的真假值。</p><p>④ 动作项（Action Entry）：列出在条件项的各种取值情况下应该采取的动作。</p><p>行李费算法的决策表。</p><p>条件项：国内乘客、头等舱、残疾乘客、行李重量</p><p>动作项：列出了不同行李重量可能采取的操作</p><p>右侧上部和下部：各种条件组合和每种条件组合相对应的动作。</p><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16682569271221668256926721.png"></p><p>决策表的建立步骤：</p><p>① 确定规则的个数，假如有n个条件，每个条件有两个取值（0，1）,故有2的n次方种规则。</p><p>② 列出所有的条件桩和动作桩。</p><p>③ 填入条件项。</p><p>④ 填入动作项。得到初始决策表。</p><p>⑤ 简化、合并相似规则（相同动作）。</p><p>决策表的优点：</p><p>1）能够将复杂的问题按照各种可能的情况全部列举出来，简明并避免遗漏。因此，利用决策表能够设计出完整的测试用例集合。</p><p>2）在一些数据处理问题中，某些操作的实施依赖于多个逻辑条件的组合，即：针对不同逻辑条件的组合值，分别执行不同的操作。决策表很适合于处理这类问题。</p><h3 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h3><p>决策树的概念</p><p>决策树：适合描述问题处理中具有多个判断，而且每个决策与若干条件有关。</p><p>决策树：是决策表的变种，也能清晰地表示复杂的条件组合与应做的动作之间的对应关系。</p><p>决策树的形式简单到不需任何说明，一眼就可以看出其含义，因此，易于掌握和使用。</p><p>行李费算法的决策树</p><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16682571361211668257135662.png"></p><p>决策树的优点</p><p>优点：在控制层级的基础上，构造简单，表示方法直观，易于理解。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>描述的每一个需求建模方法都有其优点和不足。</p><p>没有哪一个图形化模型能够充分描述系统的每个方面。</p><p>这些模型提供的描述也有重叠，所以我们也没有必要为项目创建所有的视图。</p><p>比如，如果创建了实体关系图和数据字典，很可能就没有必要再创建类图。</p><h2 id="Summary-2"><a href="#Summary-2" class="headerlink" title="Summary"></a>Summary</h2><p>需求建模方法具备的共同特点：</p><p>1）提供描述手段</p><p>2）提供基本步骤</p><p>常见的软件需求模型包括：</p><p>数据流图（DFD）</p><p>实体关系图（ERD）</p><p>状态转换图（STD）</p><p>用例图</p><p>类图</p><p>活动图</p><p>时序图</p><p>事件-响应表</p><p>数据流图：</p><p>数据流图：用于标识一个系统中的加工处理、系统所操作的数据集合或者物理介质以及在处理、存储和系统外部之间的数据流。</p><p>数据流图由四种基本符号组成：</p><p>“箭头”表示：数据流，</p><p>“圆角矩形”表示：数据处理或加工</p><p>“双线”表示：数据存储</p><p>“矩形框”表示：外部实体</p><p>实体-关系图：</p><p>实体-关系图，包含：实体、关系和属性。</p><p>实体：是现实世界中客观存在的，而且，可以相互区别的事物或活动的抽象。</p><p>属性：是描述实体或关系中的一种特征。一个实体或关系通常具有多个特征，需要多个相应属性来描述。</p><p>关系：现实世界中事物内部以及事物之间的联系，在软件系统中反映为实体内部的关系和实体之间的关系。</p><p>实体之间的关系有三类：一对一关系（1:1）、一对多关系（1:n）和 多对多关系（m:n）</p><p>用例图：是用来描述系统外部执行者与其交互用例之间的关系。</p><p>（2）类是：对一组对象的描述，这些对象具有相似的属性、操作、关系和行为。</p><p>（3）活动图，用来描述用例中交错的各种流或者执行某个动作的执行者角色或者业务处理中的流程。</p><p>（4）时序图：描述对象之间的动态交互关系，着重表现对象之间消息传递的时间顺序。</p><p>决策表：</p><p>决策表：是分析和表达多逻辑条件下执行不同操作的情况的工具。</p><p>决策表：分为四个部分，其左上部列出所有条件，左下部是所有可能做的动作，右上部是表示各种条件组合的一个矩阵，右下部是和每种条件组合相对应的动作。</p><p>决策树：</p><p>决策树：适合描述问题处理中具有多个判断，而且每个决策与若干条件有关。</p><p>决策树：是决策表的变种，也能清晰地表示复杂的条件组合与应做的动作之间的对应关系。</p><h1 id="第7章-需求文档"><a href="#第7章-需求文档" class="headerlink" title="第7章  需求文档"></a><strong>第7章  需求文档</strong></h1><h2 id="需求文档在需求工程中的位置"><a href="#需求文档在需求工程中的位置" class="headerlink" title="需求文档在需求工程中的位置"></a>需求文档在需求工程中的位置</h2><p>软件文档：是软件产品的重要组成部分，对于开发人员、项目管理人员以及软件用户都是十分重要的辅助工具。</p><p>软件文档定义清晰、维护及时，能够帮助开发人员理解需求、顺畅沟通，帮助项目管理人员了解进度、加强管理，帮助软件用户更好地使用和维护软件。</p><p>常用的软件文档主要包括：可行性研究报告、项目开发计划、需求文档、概要设计文档、详细设计文档、测试文档、项目开发总结报告、用户手册和操作手册等。</p><p>需求文档：是其中最重要的软件文档之一。</p><p>需求文档：使得开发人员、项目管理人员和软件用户对软件的初始规定达成共识，并使之成为整个开发工作的基础。</p><p>需求工程是一个不断反复的需求定义、需求分析、文档记录、需求演进的过程，并最终在验证的基础上得到需求基线。</p><p><em>需求是软件产品的根源，需求工作的优劣对软件产品影响最大。</em></p><p><em>就像一条河流，如果源头被污染了，那么整条河流也就被污染了。</em></p><h2 id="需求文档与需求工程中各阶段的关系"><a href="#需求文档与需求工程中各阶段的关系" class="headerlink" title="需求文档与需求工程中各阶段的关系"></a>需求文档与需求工程中各阶段的关系</h2><p>如图所示</p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16682609193551668260919301.png" style="zoom:50%;" /><ul><li><p>需求获取：当我们和客户合作时，我们会问一些问题，取得他们所提供的信息。</p></li><li><p>需求分析：分析获取的信息以理解它们，并把它们分成不同的类别，同时把客户需求同可能的软件需求联系起来。</p></li><li><p>需求文档：即，软件需求规格说明。</p></li><li><p>需求验证：可以让客户代表评审软件需求规格说明，并纠正存在的错误。</p></li><li><p>这四个过程相互迭代，贯穿着需求开发整个阶段。</p></li></ul><p>需求文档：</p><ul><li><p>是在整个需求开发过程中逐步完成，并完善。</p></li><li><p>经过评审后的需求文档，是经过迭代式的需求开发工作后最终形成的成果。</p></li><li><p>是需求管理的主要对象，也是设计文档、开发文档、测试文档等编写的重要依据。</p></li></ul><h2 id="需求文档的作用有以下几方面："><a href="#需求文档的作用有以下几方面：" class="headerlink" title="需求文档的作用有以下几方面："></a>需求文档的作用有以下几方面：</h2><ol><li><p>规范的文档可以拓展人脑的知识记忆能力。</p><p>人脑的记忆力总是有限的，获取的信息会随着时间慢慢消退。</p><p>大量临时记录的文档，如果不及时进行整理，在下次阅读时很难再回忆起当时要表达的知识，容易造成歧义。</p><p>规范的文档可以解决这些问题。</p></li><li><p>编制需求文档的过程，是需求分析员更理解问题的过程，使文档表达的知识更准确、更清晰。</p></li><li><p>定义清晰、正确、规范的需求文档为开发人员、项目管理人员和软件用户提供相对稳定的可阅读资料。</p></li><li><p>通过编制需求文档，可以尽早发现需求错误，提高项目开发效率。</p><p>错误在整个项目开发过程中有放大效应，因此，编制需求文档的过程，也是进一步明确和完善系统需求的过程。</p><p>通过减少需求错误从而尽可能地降低项目返工成本，保证项目按期完成。</p></li><li><p>需求文档能够促进软件开发过程的规范化，也为开发团队建立了经验模型和可复用知识库。</p><p>如果需求分析员在项目未完成时离开了开发团队，通过需求文档记录了他们的工作，智力资产不会被带走。</p><p>如果有新员工加人项目开发团队，也可以通过阅读文档，尽快地融人团队中。</p><p>如果要进行项目二次开发，或者有类似的项目，则通过文档获得可复用知识模型，可以加快项目开发进度。</p></li><li><p>需求文档可以作为项目开发方和软件客户之间的有关软件系统的协议基准，可以使用它作为合同协议的重要组成部分。使开发方和软件客户对系统目标达成一致。</p></li><li><p>需求文档可以作为软件成本估算和项目开发进度安排的重要依据，从而使整个项目开发计划的制订更为合理。</p></li></ol><h2 id="对待需求文档的两种不同观点："><a href="#对待需求文档的两种不同观点：" class="headerlink" title="对待需求文档的两种不同观点："></a>对待需求文档的两种不同观点：</h2><p>一种观点，是过分强调文档，一味追求文档的厚度、完整性，甚至花很长时间去美化文档，不断更新一些不重要的文档细节，从而导致花费大量时间编制和维护文档，反而降低了软件开发效率。</p><p>另一种观点，则是完全不重视文档，认为文档的编写只是一个形式化的过程，为节约时间，根本不重视文档的书写风格和表达方式，在实际开发过程中也基本不使用文档，这种观点将导致文档的作用得不到体现，和没有使用文档的开发，效果相差无几。</p><p>科学的态度应该是：</p><ul><li><p>充分重视文档的实效，而非形式，不要过于强调“文档量”。</p></li><li><p>而要注重文档内容和文档中文字、图表的表达，使文档能够准确、简洁、清晰的表达系统需求信息。</p></li><li><p>使文档能够被项目管理人员、开发人员和软件客户共同接受。</p></li></ul><h2 id="在编写需求文档时，应遵循如下的基本原则："><a href="#在编写需求文档时，应遵循如下的基本原则：" class="headerlink" title="在编写需求文档时，应遵循如下的基本原则："></a>在编写需求文档时，应遵循如下的基本原则：</h2><p>（1）在可能的情况下，需求文档应该由软件开发方和软件客户联合起草。</p><p>由于用户通常对软件设计和开发过程了解较少，</p><p>软件开发方通常对客户从事的领域了解较少，对于客户的问题和意图也不甚清楚。</p><p>（2）需求文档编写应适应文档的读者。</p><p>需求文档的读者主要是项目管理人员、开发人员和软件客户，其中开发人员主要包括系统设计人员、程序员、测试人员、文档编写人员。</p><p>只有充分了解读者对文档的需求，才能编写出一份好的技术性文档。</p><p>（3）需求文档的表达方式依赖于内容。</p><p>需求文档的表达方式可以划分为：自然语言、图形化模型和形式化规格描述3种。</p><p>在大多数情况下中，仍然采用自然语言表达为主，图形化模型表达为辅的文档表达方式，在少量对描述精确性要求很高的文档中，采用形式化描述方式。</p><p>（4）需求文档编写应有必要的重复，并不断完善。</p><p>为了保证读者能够正确理解文档内容，或提醒用户关注重点内容，在文档中应有必要的重复，但要注意不是简单的重复，而是不断的完善。</p><p>（5）需求文档编写应具有一定的灵活性。</p><p>主要表现如下。</p><p>1）文档的详细程度应具有一定的灵活性。</p><p>基于相同模版的需求文档，可能只有几页，也可能是上百页。</p><p>详细程度取决于任务的规模、复杂性和项目管理人员对软件开发过程及运行环境所需要的详细程度的判断。</p><p>2）文档可以扩展与合并，文档中所有的章节都可以进一步细分或缩并，以适应实际需要。</p><p>3）文档应能够对需求变更进行有效的管理和控制。</p><p>用户需求的变化、市场需求的变化、系统变化、工作环境的变化，以及由于对原有需求的误解或需求分析不充分而存在的需求Bug都有可能导致需求变更。</p><p>因此，文档应能够灵活地处理需求变更。</p><p>（6）采用原型法，渐进式开发需求文档。</p><p>人们总是希望一开始就能将整个软件系统的需求确定下来，但在实际项目中却很难达到这一目标。</p><p>为降低需求风险，提高软件开发效率，可以采用原型法，渐进式编写需求文档。</p><p>常用的编写需求文档的方法有：</p><p>自然语言</p><p>图形化模型</p><p>形式化规格描述</p><h2 id="常用的编写需求文档的方法有："><a href="#常用的编写需求文档的方法有：" class="headerlink" title="常用的编写需求文档的方法有："></a>常用的编写需求文档的方法有：</h2><ol><li><p>自然语言</p><p>自然语言：是使用结构合理的自然语言来表述需求。</p><p>自然语言：不管对于写的人还是看的人，都是一个很容易接受的方法，一直以来这都是描述需求的首选方法。</p><p>自然语言优点：易于编写、易于阅读，不要求掌握特定的技能。</p><p>自然语言缺点：不够严谨，歧义性强，表述力差，对于复杂问题的描述就更为明显，往往需要很大的篇幅来解释。</p><p>因此，需要尽可能采用结构化文本来组织。</p></li><li><p>图形化模型   —— “一图抵千言”</p><p>图形化模型：在表述时能够给读者提供更强的视觉效果，同时能够使问题更加聚焦。</p><p>图形化模型：在日常的交流中，经常会在纸上绘制一些非标的示意图，以更好地完成沟通。</p><p>图形化模型优点：就是前面提到的可视性、聚焦性。</p><p>图形化模型缺点：要求编写和阅读的人都能够正确地理解模型，而且并不是所有的信息都是可以用模型表示的。</p><p>因此，对于一个软件需求文档而言，是不可能只有图形化模型、没有任何文字表述的。</p></li><li><p>形式化方法描述</p><p>形式化方法描述：比图形化模型更高一些。对于逻辑性很强、精度要求很高的场合，形式化方法描述就是一种不错的选择。</p><p>形式化方法描述优点：是严谨、精确。</p><p>形式化方法描述：缺点：是编写和阅读的人都会感到很困难，容易产生理解歧义。</p></li><li><p>需求文档编写方法的选择：</p><p>1）以自然语言为主，而以图形化模型为辅，需要的地方少量使用形式化方法描述。</p><p>这是现在最常见的组合形式，对于绝大多数信息系统、软件产品而言都是十分适合的方法。</p><p>2）以图形化模型为主，而以自然语言作为补充，需要的地方少量使用形式化方法描述。</p><p>3）以形式化规格语言为主，而以图形化模型为辅，并以自然语言为补充。</p><p>适用于质量要求很高的领域，例如：航天、军工中的一些重要软件系统。</p></li></ol><p>软件需求规格说明，也称为：功能规格说明、需求协议及系统规格说明。</p><p>软件需求规格说明：精确地阐述一个软件系统必须提供的功能、性能及它所要求考虑的限制条件。</p><p>软件需求规格说明：不仅是系统测试和用户手册的编写基础，也是各子系统计划、设计、编码的基础。</p><p>软件需求规格说明：应尽可能完整地描述系统预期的外部行为和用户可视化行为。</p><h2 id="编写需求规格说明步骤："><a href="#编写需求规格说明步骤：" class="headerlink" title="编写需求规格说明步骤："></a>编写需求规格说明步骤：</h2><p>1）整理所有已经通过审核的各阶段工作文档，这些文档虽然是阶段性的，但一定是经过审核准确的，对于每一个审核的局部文档都要给出版本号。</p><p>2）制订一个结构完成的需求规格说明模板，并给需求规格说明模板一个版本号，同时要制订一个需求规格说明的编写规范。</p><p>3）按照需求规格说明模板和编写规范依据整理的各阶段文档成果进行编写，编写时一定要注意前后一致性原则。</p><p>4）软件需求规格说明书编写成员进行自检和互检，最终形成一个提交需求验证的软件需求规格说明文档。</p><p>常用的标识方法有以下几种：</p><p>1）序列号法</p><p>序列号法：是一种最简单的方法，就是给每个需求一个唯一的序列号，如UR-1 , SRS13 , FR-1等。</p><p>当一个新的需求进来时，再依序给它分配一个序列号，序列号的前缀代表需求类型，</p><p>由于序号不能重用，当有一个需求被纳人进来时，其原先占有的序列号并不能释放出来，容易造成序列号断号。</p><p>序列号法：不能提供任何相关需求在逻辑上或层次上的区别，而且标识中不含有与需求内容相关的信息。</p><p>2）层次化编码</p><p>层次化编码：是一种常用的方法。如：软件需求规格说明中的4.1，下一层标识号是4.1.1等。</p><p>层次化编码中的数字越多，则表示需求越详细，号数越多的说明它是最底层的需求。</p><p>层次化编码：简单且紧凑，利用文档工具可以实现层次号的自动变更，它很方便地显示了一个需求的层次构成。</p><p>层次化编码： 不含需求的内容信息，而且如果有其他地方引用，当变动时引用部分要做相应的修改。</p><p>3）层次化文本标签</p><p>层次化的文本标签是结构化的、具有语义上的含义。</p><p>层次化文本标签：不受增加和减少或移动的影响。</p><p>层次化文本标签：但要定义好层次化文本标签要比层次化数字标识难得多。</p><p>处理不完整性</p><p>在编写需求规格说明时，一定会遇到缺少特定的需求信息，或认为原有过程化需求文档有不正确的地方，则使用一种TBD ，即待确定的标记来标识这些不确定的需求。</p><p>并将TBD的地方记录在一个TBD问题列表中，该列表有TBD编号、问题内容、责任人、解决时间、解决状态，这个表将有助于跟踪这个文档的编写。</p><p>TBD问题列表将作为需求规格说明文档的附录。</p><p>要把最终的软件需求规格说明移交给软件开发组时，必须解决所有的TBD问题。</p><h2 id="软件需求规格说明模板"><a href="#软件需求规格说明模板" class="headerlink" title="软件需求规格说明模板"></a>软件需求规格说明模板</h2><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16682618521221668261851542.png"></p><p>1.引言</p><p>引言：提供了一个概述，帮助于读者理解软件需求规格说明的组织方式和使用方式。</p><p>引言：主要包括：目标、文档约定、读者对象和阅读建议、项目范围及参考文献。</p><p>1.1 目标</p><p>在文档中说明软件或应用程序的需求，包括：修订或者发行版本号。</p><p>如果该软件需求规格说明只与整个系统的一部分有关系，那么，就只需确定这一部分或子系统。</p><p>1.2 文档约定</p><p>描述编写文档时所采用的所有标准或印刷上的约定。</p><p>包括：文本样式、强调形式或具有特殊意义的表示符号。</p><p>1.3 读者对象和阅读建议</p><p>列举软件需求规格说明面向的不同读者对象。</p><p>描述软件需求规格说明中其余部分的内容及其组织结构。</p><p>就每一类读者最合适以什么顺序来阅读该文档提出建议。</p><p>1.4 项目范围</p><p>提供对指定的软件及其作用的简短描述。</p><p>把软件与用户或公司目标相关联，把软件与业务目标和策略相关联。</p><p>如果可以得到单独的前景和范围文档，那么应该引用它，而不要直接将其内容复制到这里。</p><p>如果是说明改进产品的增量发布的软件需求规格说明，那么应该包括它自己的范围声明，作为长期战略的产品前景的一个子集。</p><p>1.5参考资料</p><p>列举编写软件需求规格说明时所参考的所有文档或其他资源。</p><p>如果可能的话，使用超文本链接。</p><p>2.总体描述</p><p>2.1 产品前景</p><p>描述产品的背景和起源。</p><p>说明该产品是否是产品系列中的下一个成员，是否是成熟系统的下一版本，是现有应用程序的升级产品还是是一个全新的产品。</p><p>2.2 产品特性</p><p>列出产品所具有的主要特性或者产品可实现的重要功能。</p><p>在此只需要提供一个总体概括即可。</p><p>2.3 用户类及其特征</p><p>确定我们能预料到的有可能使用该产品的各种用户类。</p><p>描述他们的相关特征。</p><p>2.4 运行环境</p><p>描述软件的运行环境，包括：硬件平台、操作系统和版本，以及用户、服务器和数据库的地理位置</p><p>2.5 设计和实现上的约束</p><p>描述限制开发人员进行有效选择的所有因素，以及每一种约束的基本原理。</p><p>2.6 用户文档</p><p>列出将要交付的用户文档组件以及可执行软件，可以包括用户手册、联机帮助和教程。</p><p>确定所有要求的文档交付格式、标准或工具。</p><p>2.7 假设和依赖</p><p>假设是这样一种声明，在缺少证据或不确定的情况下先相信它是真的。</p><p>如果假设不正确、不一致或被更改，那么就可能会产生问题。</p><p>有些假设将会转化为项目风险。</p><p>3.系统特性</p><p>模板是根据系统特性来组织的，它只是安排功能性需求的一种可能的方式。</p><p>其他可以选择的方式还包括按照用例、操作模式、刺激、响应、对象类或功能层次结构等。</p><p>正确的选择并不是惟一的，但我们应该选择一种使读者易于理解产品预期功能的组织方法</p><p>3.1 系统特性X</p><p>仅用简短的词语说明特性的名称，例如“3.1 拼写检查”。</p><p>对每一个系统特性都要重复 3.x.1一3.x.3 这几个部分。</p><p>3.x.1 描述优先级</p><p>提供对该特性的简短描述，并指出该特性的优先级是高、中或低</p><p>3.x.2 激励&#x2F;响应序列</p><p>列出输入激励序列（如：用户操作、来自外部设备的信号或其他触发器）和系统响应序列，系统响应序列定义这一特性的行为。</p><p>这些激励与用例最初的对话步骤或者与外部系统事件相对应。</p><p>3.x.3 功能性需求</p><p>逐项列出与该特性相关的详细功能性需求。</p><p>这些是必须提交给用户的软件功能，使用户可以执行该特性的服务或者完成一个用例。</p><p>描述产品如何响应可预知的出错条件以及如何响应非法输入或操作。</p><p>唯一地标识每个功能性需求。</p><p>4.外部接口需求</p><p>这部分所提供信息是为了保证系统与用户、与外部硬件或软件元素之间的正常通信。</p><p>如果一个复杂系统有多个组成部分，则应创建一个独立的接口规范说明或者系统架构规范说明。</p><p>主要包括：用户界面、硬件接口、软件接口和通信接口。</p><p>4.1 用户界面</p><p>描述系统所需的每个用户界面的逻辑特征或屏幕模型，以便与需求的另一个视图进行交流。</p><p>而不能将用户界面的设计细节写入软件需求规格说明中。</p><p>4.2 硬件接口</p><p>描述系统中软件和硬件组件之间每一接口的特征。</p><p>这种描述可能包括支持的设备类型、软件和硬件之间的数据和控制交互以及所用的通信协议等。</p><p>4.3 软件接口</p><p>描述该产品与其他软件组件之间的连接，这些组件包括数据库、操作系统、工具、库和集成的商业组件等。</p><p>声明在软件组件之间交换消息、数据和控制项的目的。</p><p>描述外部软件组件所需的服务，以及组件间通信的本质。</p><p>确定将在软件组件之间共享的数据。</p><p>4.4 通信接口</p><p>描述产品将使用的所有通信功能的需求，包括电子邮件、Web浏览器、网络通信协议和电子表格等。</p><p>定义所有相关的消息格式。</p><p>规定通信安全或加密问题、数据传输速率和同步通信机制等。</p><p>5.其他非功能性需求</p><p>5.1 性能需求</p><p>声明各种系统操作特定的性能需求，并解释其原理以指导开发人员做出合理的设计选择。</p><p>5.2 防护性需求</p><p>这部分声明与产品使用过程中可能发生的损失、破坏或危害相关的需求。</p><p>定义必须采取的安全保护措施或动作，还有那些必须避免的可能危险的动作。</p><p>明确产品必须遵循的安全标准、策略或规则。</p><p>5.3 安全性需求</p><p>指定与安全性、完整性或保密性问题相关的所有需求，这些问题影响对产品的访问、使用以及产品所创建或使用的数据的保护。</p><p>确定产品必须遵守的所有安全或保密策略或规则。</p><p>5.4 软件质量属性</p><p>声明对用户或开发人员至关重要的其他产品质量特征。</p><p>这些特征必须是明确的、定量的和可验证的。</p><p>应该指明各种属性的相对优先级。</p><p>6.其他需求</p><p>定义在此软件需求规格说明中其他部分未出现的所有其他需求。</p><p>例如：国际化需求及法律上的需求。</p><p>如果不需要添加任何其他需求，就省略这一部分。</p><p>7.附录</p><p>附录A：术语表</p><p>定义读者需要了解的所有专门术语，以便他们能够正确地理解软件需求规格说明。</p><p>附录B：分析模型</p><p>这一部分是可选的，包括或指向相关的分析模型。</p><p>例如：数据流图、类图、状态转换图、实体-关系图等。</p><p>附录C：待确定问题的清单</p><p>这一部分列出了有待于解决的需求问题。</p><p>这一部分并不是软件需求规格说明所必需的。</p><h2 id="Summary-3"><a href="#Summary-3" class="headerlink" title="Summary"></a>Summary</h2><p>需求文档：是其中最重要的软件文档之一。</p><p>需求开发，包括：</p><p>需求获取</p><p>需求分析</p><p>需求文档</p><p>需求确认</p><p>需求文档的7个作用：</p><p>（1）规范的文档可以拓展人脑的知识记忆能力。</p><p>（2）编制需求文档的过程，是需求分析员更理解问题的过程，使文档表达的知识更准确、更清晰。</p><p>（3）定义清晰、正确、规范的需求文档为开发人员、项目管理人员和软件用户提供相对稳定的可阅读资料。</p><p>（4）通过编制需求文档，可以尽早发现需求错误，提高项目开发效率。</p><p>（5）需求文档能够促进软件开发过程的规范化，也为开发团队建立了经验模型和可复用知识库。</p><p>（6）需求文档可以作为项目开发方和软件客户之间的有关软件系统的协议基准，可以使用它作为合同协议的重要组成部分。使开发方和软件客户对系统目标达成一致。</p><p>（7）需求文档可以作为软件成本估算和项目开发进度安排的重要依据，从而使整个项目开发计划的制订更为合理。</p><p>编写需求文档的6个原则：</p><p>（1）在可能的情况下，需求文档应该由软件开发方和软件客户联合起草。</p><p>（2）需求文档编写应适应文档的读者。</p><p>（3）需求文档的表达方式依赖于内容。</p><p>（4）需求文档编写应有必要的重复，并不断完善。</p><p>（5）需求文档编写应具有一定的灵活性。</p><p>（6）采用原型法，渐进式开发需求文档。</p><p>需求文档的编写方法：</p><p>自然语言</p><p>图形化模型</p><p>形式化规格描述</p><p>需求文档编写方法的选择：</p><p>1）以自然语言为主，而以图形化模型为辅，需要的地方少量使用形式化方法描述。</p><p>2）以图形化模型为主，而以自然语言作为补充，需要的地方少量使用形式化方法描述。</p><p>3）以形式化规格语言为主，而以图形化模型为辅，并以自然语言为补充。</p><p>编写需求规格说明步骤：</p><p>（1）整理所有已经通过审核的各阶段工作文档。</p><p>（2）制订一个结构完成的需求规格说明模板，并给需求规格说明模板一个版本号。</p><p>（3）按照需求规格说明模板和编写规范依据整理的各阶段文档成果进行编写。</p><p>（4）软件需求规格说明书编写成员进行自检和互检。</p><p>常用的标识方法：</p><p>（1）序列号法</p><p>（2）层次化编码</p><p>（3）层次化文本标签</p><p>处理不完整性方法：</p><p>（1）使用：TBD ，即待确定的标记来标识这些不确定的需求。</p><p>（2）将有TBD的地方记录在一个TBD问题列表中。</p><p>（3） TBD问题列表将作为需求规格说明文档的附录。</p><p>（4）要把最终的软件需求规格说明移交给软件开发组时，必须解决所有的TBD问题。</p><p>软件需求规格说明模板：</p><p>当前常用的模板是IEEE标准830-1998的模板。</p><p>模板中的主要内容：</p><ol><li><p>引言</p></li><li><p>总体描述</p></li><li><p>系统特性</p></li><li><p>外部接口需求</p></li><li><p>其他非功能性需求</p></li><li><p>其他需求</p></li><li><p>附录</p></li></ol><h1 id="第8章-软件质量属性"><a href="#第8章-软件质量属性" class="headerlink" title="第8章   软件质量属性"></a>第8章   软件质量属性</h1><h2 id="质量属性的概念："><a href="#质量属性的概念：" class="headerlink" title="质量属性的概念："></a>质量属性的概念：</h2><p>系统的功能：是系统能够为用户提供帮助的第一要素。</p><p>成功的软件系统除了满足功能需求之外，还需要满足更多的要求。</p><p>系统的<strong>性能需求</strong>，包括：系统的易用性、运行速度、出错频率，以及处理异常情况的能力等。</p><p>这些特性合起来被称为：<strong>软件质量属性或质量因素</strong></p><p>它是<strong>系统非功能需求</strong>的一部分。</p><p>质量属性：也应该和功能需求一样得到足够的重视。</p><p>在决定系统的成功或失败的因素中，有时满足非功能属性往往比满足功能需求更为重要。</p><p>质量属性：对设计的影响很大。</p><p>质量属性：在软件设计中，对任何指定的功能都会有多种可选的方案，不同的方案选择产生不同的设计结果。</p><p>不同的方案之间却有着很大的区别，差异之处即在于拥有不同的质量属性。</p><p>不同的质量属性之间互有折中，很难会出现某一个设计方案的质量属性完全优于其他方案的情况。</p><p>因此，软件设计必须根据需求的质量属性在多种方案中，选择一个最优的方案。</p><p>如果不存在事先定义好的质量属性，设计方案的选择将完全没有依据，结果就很有可能导致软件不被用户接受。</p><p>在设计开始之初，就确定质量属性非常重要，而且对越复杂的系统越为重要。</p><p>质量属性：分类两类：</p><p>（1）根据质量属性能否在运行时进行识别。</p><p>（2）根据对用户和技术人员的重要性，分为：</p><p>对用户很重要的可见的质量属性</p><p>对技术人员有意义的质量属性</p><p>后者通过使系统易于更改、纠正和验证，并易于移植到新的平台上，间接地促进用户需要的满足。</p><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16685971558011668597155036.png"></p><p>理想情况下，每一个系统总是展示所有这些属性可能的最大值。</p><p>系统总是可用的，决不会崩溃，可以立即得出始终正确的运行结果，系统也总是直观且易于使用。</p><p>必须了解哪些属性对项目的成功至关重要。</p><p>根据这些基本属性来定义用户和开发人员的目标，从而使系统的设计人员能够做出合适的选择</p><h2 id="对用户重要的属性："><a href="#对用户重要的属性：" class="headerlink" title="对用户重要的属性："></a>对用户重要的属性：</h2><h3 id="可用性（Availability）"><a href="#可用性（Availability）" class="headerlink" title="可用性（Availability）"></a>可用性（Availability）</h3><p>可用性：用于衡量预定的可用时间，在这期间系统是真正可用并且是完全可操作的。</p><p>可用性：等于系统的平均无故障时间（简称：MTTF）除以平均无故障时间与故障发生后所用的故障修复时间（简称：MTTR）之和。</p><p>即：可用性 &#x3D; MTTF&#x2F;（MTTF+MTTR）</p><p>可用性，包括：可靠性、可维护性和完整性。</p><h3 id="有效性（Efficiency）"><a href="#有效性（Efficiency）" class="headerlink" title="有效性（Efficiency）"></a>有效性（Efficiency）</h3><p>有效性：用来衡量系统在利用处理器的处理能力、磁盘空间、内存或通信带宽等方面的表现如何。</p><p>有效性与性能相关，性能是另一类非功能性需求。</p><p>如果系统消耗了太多可用的资源，那么用户遇到的将是性能的下降，这是缺乏有效性的一个表现。</p><h3 id="灵活性（Flexibility）"><a href="#灵活性（Flexibility）" class="headerlink" title="灵活性（Flexibility）"></a>灵活性（Flexibility）</h3><p>灵活性，也称为：可扩充性、可扩展性。</p><p>灵活性：用来测量向系统中添加新功能的容易程度。</p><p>如果开发人员预料到要对系统进行扩展，那么他们可以选择使软件灵活性最高的设计方案。</p><p>灵活性：对以增量或迭代方式开发的系统是必不可少的，这些系统是通过一系列连续的发布版本或演化式原型而开发的。</p><h3 id="完整性（Integrity）"><a href="#完整性（Integrity）" class="headerlink" title="完整性（Integrity）"></a>完整性（Integrity）</h3><p>完整性：主要处理防止非法访问系统功能、防止数据丢失、保护软件免受病毒入侵以及保护输入到系统的数据的保密性和安全性等问题。</p><p>完整性需求不能容忍任何错误，陈述完整性需求时应使用含义明确的术语。</p><p>如：用户身份验证、用户特权级别、访问限制或者需要保护的精确数据。</p><h3 id="互操作性（Interoperability）"><a href="#互操作性（Interoperability）" class="headerlink" title="互操作性（Interoperability）"></a>互操作性（Interoperability）</h3><p>互操作性：表明了系统与其他系统交换数据和服务的难易程度。</p><p>为了评估互操作性，必须了解清楚用户使用其他哪些应用程序与本系统协同工作，还要了解清楚用户期望交换什么数据。</p><h3 id="可靠性（Reliability）"><a href="#可靠性（Reliability）" class="headerlink" title="可靠性（Reliability）"></a>可靠性（Reliability）</h3><p>可靠性：是软件无故障执行指定时间的概率。</p><p>健壮性有时可看成是可靠性的一部分。</p><p>衡量软件可靠性的方法，包括：正确执行操作所占的百分比和系统发生故障之前正常运行的平均时间长度。</p><p>具有高可靠性要求的系统，也应该设计得具有很高的可测试性，就可以轻松地发现损害系统可靠性的缺陷。</p><h3 id="健壮性（Robustness）"><a href="#健壮性（Robustness）" class="headerlink" title="健壮性（Robustness）"></a>健壮性（Robustness）</h3><p>健壮性：指的是当系统遇到非法的输入数据、相连接的软件组件或硬件组件的缺陷，以及预料不到的操作情况时，能继续正确运行功能的可能性。</p><p>健壮的软件：可以从发生问题的环境中自然地恢复过来，并且可以容忍用户所犯的错误。</p><p>当获取健壮性需求时，向用户询问系统可能遇到的错误条件，并且要了解用户期望系统如何响应。</p><h3 id="易用性（Usability）"><a href="#易用性（Usability）" class="headerlink" title="易用性（Usability）"></a>易用性（Usability）</h3><p>易用性：陈述了许多因素，用户经常将这些因素描述为“用户友好性”。</p><p>分析人员和开发人员不应该讨论友好的软件，而应该讨论将软件的使用设计得有效而不让人感到困惑。</p><p>易用性：包括：对于新用户或不常使用系统的用户在学习使用系统时的简易程度。</p><h2 id="对开发人员重要的属性"><a href="#对开发人员重要的属性" class="headerlink" title="对开发人员重要的属性"></a>对开发人员重要的属性</h2><h3 id="可维护性"><a href="#可维护性" class="headerlink" title="可维护性"></a>可维护性</h3><p>可维护性：表明了纠正缺陷或修改软件的简单程度，它取决于理解软件、更改软件和测试软件的简单程度。</p><p>可维护性：与灵活性和可测试性密切相关。</p><p>对那些将要频繁修订的系统和要快速生成的系统来说，可维护性的要求很高。</p><p>可以根据修复一个问题所花的平均时间和修复正确的百分比来衡量可维护性。</p><h3 id="可移植性"><a href="#可移植性" class="headerlink" title="可移植性"></a>可移植性</h3><p>可移植性：用来度量把一个软件从一种运行环境移植到另一种运行环境所需的工作量。</p><p>可移植性：对项目的成功来说，要么是无关紧要，要么是至关重要。</p><p>可移植性：目标应该确定系统中必须移植到其他环境的那一部分，并描述这些目标环境。</p><p>开发人员就能选择设计和编码方法以适当提高系统的可移植性。</p><h3 id="可重用性"><a href="#可重用性" class="headerlink" title="可重用性"></a>可重用性</h3><p>可重用性：是软件开发的一个长远目标。</p><p>可重用性：表明把一个软件组件用于其他应用程序所涉及的相关工作量。</p><p>比起创建一个打算只在一个应用程序中使用的组件，开发可重用软件的费用会大得多。</p><p>可重用软件必须模块化，文档齐全，不依赖于特定的应用程序和运行环境，并且具有通用性。</p><h3 id="可测试性"><a href="#可测试性" class="headerlink" title="可测试性"></a>可测试性</h3><p>可测试性：也称为：可验证性。</p><p>可测试性：指的是测试软件组件或集成系统以查找缺陷的简单程度。</p><p>如果系统中包含复杂的算法和逻辑，或包含复杂的功能性相互关系，那么对于可测试性的设计就很重要。</p><p>如果经常更改系统，那么可测试性也是很重要的，因为需要经常对系统进行回归测试，来判断更改是否破坏了任何原有的功能性。</p><h2 id="属性的折中方案"><a href="#属性的折中方案" class="headerlink" title="属性的折中方案"></a>属性的折中方案</h2><p>用户和开发人员必须确定，与其他属性相比哪些属性更为重要。</p><p>当制定决策时，必须始终遵照优先级顺序。</p><p>如图所示，描述了质量属性之间一些典型的相互关系。</p><p>当然我们也可能会遇到一些与此不一致的例外</p><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16685984267931668598426587.png"></p><p>单元格中的加号：表明单元格所在行的属性对其所在列的属性具有正面的影响。</p><ul><li>例如，增强软件组件可移植性的设计方法也可以使软件变得更加灵活，更易于与其他软件组件相连接，更易于重用，并且更易于测试。</li></ul><p>单元格中的减号：表明单元格所在行的属性对其所在列的属性具有负面的影响。</p><p>单元格为空则表明单元格所在行的属性对其所在列的属性几乎没有什么影响。</p><p>有效性对其他许多属性具有消极影响。</p><p>类似地，一些对易用性进行优化的系统，或具有灵活性、可重用性以及与其他软件组件或硬件组件进行互操作的系统，则要付出性能的代价。</p><p>如图所示中的矩阵并不是对称的，因为增加属性A对属性B所产生的影响与增加属性B对属性A所产生的影响并不一定是相同的。</p><ul><li>例如，图中表明设计系统时增加有效性并不一定对完整性产生任何影响。</li></ul><p>增加完整性却可能会损害有效性，因为系统必须通过更多层次的用户身份验证、加密、病毒扫描和数据检查技术。</p><p>为达到系统特性的最佳平衡，必须在需求获取阶段识别、指定相关的质量属性，并且为之确定优先级。</p><p>为项目定义重要的质量属性时，利用图可以防止发生与目标冲突的行为。</p><h2 id="性能需求"><a href="#性能需求" class="headerlink" title="性能需求"></a>性能需求</h2><p>性能需求：定义了系统必须多好和多快地完成专门的功能。</p><p>性能需求：包括：速度（例如，数据库响应时间）、吞吐量（例如，每秒钟处理的事务）、处理能力（例如，并发使用负载）和定时（例如，严格的实时要求）。</p><p>苛刻的性能需求，会对设计软件策略和选择硬件造成严重的影响，因此，定义的性能需求目标要适合于运行环境。</p><p>性能需求范例：</p><p>范例1：温度控制循环必须在80毫秒内完全执行。这里，“80毫秒”就是性能需求。</p><p>范例2：解释器每分钟应该至少解析5000条没有错误的语句。这里，“5000条”就是性能需求。</p><p>范例3：在通过50KBps的调制解调器与Internet相连的情况下，下载一个Web页面需要15秒或更短。这里，“15秒或更短”就是性能需求。</p><p>范例4：ATM自动拒员机系统对提款请求的身份认证不能超过10秒。这里，“10秒”就是性能需求。</p><h2 id="Summary-4"><a href="#Summary-4" class="headerlink" title="Summary"></a>Summary</h2><p>质量属性：</p><p>用于衡量系统性能的特性包括：系统的易用性、运行速度、出错频率，以及处理异常情况的能力等。</p><p>这些特性合起来被称为：软件质量属性或质量因素。</p><p>对用户重要的属性有：</p><p>可用性、有效性、灵活性、完整性、互操作性、可靠性、健壮性、易用性。</p><p>对开发人员重要的属性有：</p><p>可维护性、可移植性、可重用性、可测试性。</p><p>属性的折中方案</p><p>为达到系统特性的最佳平衡，必须在需求获取阶段识别、指定相关的质量属性，并且为之确定优先级。</p><p>性能需求</p><p>性能需求，定义了系统必须多好和多快地完成专门的功能。</p><p>性能需求，包括：速度（例如，数据库响应时间）、吞吐量（例如，每秒钟处理的事务）、处理能力（例如，并发使用负载）和定时（例如，严格的实时要求）。</p><h1 id="第9章-通过原型来减少风险"><a href="#第9章-通过原型来减少风险" class="headerlink" title="第9章   通过原型来减少风险"></a>第9章   通过原型来减少风险</h1><h2 id="为什么要建立原型？"><a href="#为什么要建立原型？" class="headerlink" title="为什么要建立原型？"></a>为什么要建立原型？</h2><p>因为预想一个未来的软件系统，并表达出系统需求是比较困难的，而通过制作软件原型，可以使需求更加真实，使用例更加生动，并且，可以减小在需求理解上的差异。</p><p>原型：可以把新系统的一个模型或一个部分摆在用户的面前，可以激活他们的思维，并促进需求对话。</p><p>对原型的早期反馈有助于涉众对理解系统需求达成共识，从而减小客户不满意的风险。</p><p>由于需求中仍然还会有对用户、对开发人员或者对这二者都不明确或不清晰的部分。</p><p>如果不解决这些问题，那么用户对系统的想像与开发人员对系统的理解会存在期望差距。</p><p>原型有多种含义，并且参与原型制作活动的人可以有完全不同的期望。</p><p>如：一个飞机原型实际上可能是真实飞机的雏形。</p><p>一个软件原型：仅仅是真实系统的一部分或一个模型，它可能根本不能完成任何有用的功能。</p><p>软件原型，可能是：</p><p>工作模型或静态设计</p><p>很详细的屏幕草图或简单草图</p><p>真实功能的可视化显示或一部分</p><h2 id="使用原型有3个主要目的："><a href="#使用原型有3个主要目的：" class="headerlink" title="使用原型有3个主要目的："></a>使用原型有3个主要目的：</h2><p>（1）明确并完善需求。</p><p>原型：作为一种需求工具。</p><p>原型：是对部分系统的初步实现，因为我们尚没有很好地了解该系统。</p><p>用户对原型的评估，可以指出需求中存在的问题。</p><p>这样可以在开发真正的系统之前，以低成本来解决这些问题。</p><p>（2）研究设计选择方案。</p><p>原型作为一种设计工具，涉众可以用它研究不同的用户交互技术，优化系统的易用性，并评估可能的技术方案。</p><p>原型能够通过有效的设计来演示需求的可行性。</p><p>（3）发展为最终系统。</p><p>原型作为一种构造工具，是系统一个最初子集的完整功能实现，通过一系列小规模的开发周期，我们可以完成整个系统的开发。</p><p>建立原型的主要原因：</p><p>是为了解决在系统开发早期阶段不能确定的一些问题。</p><p>利用这些不确定性，可以判断系统中哪些部分需要建立原型，以及希望从用户对原型的评估中获得什么信息。</p><p>原型：是发现并解决需求中的二义性和不完整性的很好的方法。</p><p>用户、管理人员和其他非技术人员发现：</p><p>当系统处于编写需求规格说明和设计阶段时，原型可以使他们更具体地思考问题</p><p>原型，尤其是直观的原型，比开发人员有时所使用的技术术语更易于理解。</p><h2 id="根据使用原型的目的不同，原型分为："><a href="#根据使用原型的目的不同，原型分为：" class="headerlink" title="根据使用原型的目的不同，原型分为："></a>根据使用原型的目的不同，原型分为：</h2><ol><li>水平原型和垂直原型</li><li>抛弃式原型和演化式原型</li><li>书面原型和电子原型</li></ol><h3 id="水平原型"><a href="#水平原型" class="headerlink" title="水平原型"></a>水平原型</h3><p>当人们谈到“软件原型”时，所想到的通常是一个可能的用户界面的水平原型。</p><ul><li><p>水平原型，也叫做：行为原型或演示性模型。</p></li><li><p>水平原型：主要描绘了用户界面的一部分。</p><ul><li>因为水平原型并不能深入到体系结构的所有层次，或者深入到系统的细节。</li></ul></li><li><p>通过水平原型，可以研究预期系统的一些特定行为，并达到完善需求的目的。</p></li><li><p>水平原型：有助于用户判断基于该原型的系统是否能完成任务。</p></li><li><p>水平原型：显示用户界面的屏幕外观，并允许这些屏幕之间进行某些导航，但只包含很少或根本就不包含真正的功能实现。</p></li><li><p>水平原型：能够演示用户以后可用的功能选项、用户界面的外观和感觉（如：颜色、布局、图形和控件），以及信息体系结构（如：导航结构）等。</p></li><li><p>虽然原型看起来似乎可以执行一些有意义的工作，但其实不然。</p></li><li><p>水平原型：常常只是使用户判断是否有遗漏、错误或不必要的功能。</p></li><li><p>有些原型，代表了开发人员对可能如何实现一个特定用例的一种观念。</p></li><li><p>用户对原型的评估，可以指出用例的其他实现方式、遗漏的交互步骤，或者其他异常情况。</p></li><li><p>当处理水平原型时，用户应该把注意力集中在概括性需求和工作流问题上，而不要被屏幕元素的精确外观所分心。</p></li><li><p>在此阶段，不要担心屏幕元素的精确位置、字体、颜色、图形或控件。</p></li><li><p>弄清了需求，并确定了界面的总体框架之后，再来研究用户界面的细节。</p></li></ul><h3 id="垂直原型"><a href="#垂直原型" class="headerlink" title="垂直原型"></a>垂直原型</h3><ul><li><p>垂直原型：也称为：结构化原型、概念的证明</p></li><li><p>垂直原型：在整个技术服务层上实现应用程序用户界面的一部分功能。</p></li><li><p>垂直原型的运作与所期望的真实系统的运作类似，因为它触及到了系统实现的所有层次。</p></li><li><p>如果不能确定所提议的架构方法是否可行和合理，或者如果我们想要优化算法、评估所提议的数据库架构或测试关键的定时需求。就可以开发一个垂直模型。</p></li><li><p>垂直原型：为使其结果有意义，通常在与系统类似的运行环境中，用生产工具来创建垂直原型。</p></li><li><p>垂直原型：常用于研究关键界面和定时需求，也常用在设计阶段以减小风险。</p></li></ul><h3 id="抛弃式原型和演化式原型"><a href="#抛弃式原型和演化式原型" class="headerlink" title="抛弃式原型和演化式原型"></a>抛弃式原型和演化式原型</h3><p>（1）抛弃式原型</p><p>在构造一个原型之前，需要做出一个明确的和经过分析的决策。</p><p>也就是在评估之后是将原型抛弃掉，还是将原型作为最终交付系统的一部分。</p><p>如果打算在原型达到预期目的以后将它抛弃掉，那么，就应该尽量花最小的代价，并尽可能快地创建该原型。</p><p>在此原型上付出的努力越多，项目的参与者就越不愿意将它抛弃掉。</p><p>要注意的是：</p><p>如果认为该原型有其优点，应该留着以备将来重用，那么也不一定非要将它抛弃掉。</p><p>不能将“抛弃式原型”整合到最终交付的系统中。</p><p>可能更愿意将它称为“非发布型原型”。</p><p>抛弃式原型：重点强调在健壮性、可靠性、性能和长期维护性等方面的快速实现和修改。</p><p>不允许将抛弃式原型中质量低的代码移植到最终系统中，否则，用户和维护人员将在系统生命周期中遭遇种种麻烦</p><p>当团队面临需求中的不确定性、二义性、不完整性或含糊性时。</p><p>最恰当的方法是建立一个抛弃式原型。</p><p>这样可以减少在继续开发时存在的风险。</p><p>抛弃式原型：可帮助用户和开发人员直观地了解需求可能如何实现，并发现需求中存在的漏洞。</p><p>抛弃式原型：可以使用户判断出这些需求是否可以使必要的业务过程运作起来。</p><p>不要过于详细地构建抛弃式原型，只要能够满足原型制作的目标就够了。</p><p>如图所示，描述了借助于抛弃式原型，从用例到详细的用户界面设计的一系列开发活动。</p><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16685999257921668599925429.png"></p><p>演化式原型</p><p>当随着时间的推移，需求越来越明确时，演化式原型为增量地构建系统奠定了坚实的结构基础。</p><p>演化式原型：是螺旋式软件开发生命周期模型和某些面向对象软件开发过程的一个组成部分。</p><p>与抛弃式原型快速、粗略的特点相比，演化式原型必须具有健壮性，代码质量从一开始就要达到系统的要求。</p><p>要完成相同的功能，构建演化式原型要比构建抛弃式原型所花的时间更多。</p><p>演化式原型：必须设计得易于进行扩展和频繁改进，开发人员必须重视软件体系结构和成熟的设计原则。</p><p>要得到高质量的演化式原型，并没有捷径可走。</p><p>应该将演化式原型的第1次增量作为一个试验性版本，用来实现需求中已经正确理解和稳定的部分。</p><p>根据用户验收测试和初次使用时发现的问题，在下一次迭代中对其进行修改，最终得到完整的系统，可以很快地将能够使用的功能交付给用户。</p><p>如果已经预料到系统以后还要进行扩展。</p><p>那么，就选择演化式原型。</p><p>如图所示，给出了综合使用各种原型的几种方法。</p><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16686000067931668600006239.png"></p><p>如表所示，概括地总结了抛弃式、演化式、水平和垂直原型的一些典型应用。</p><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16686000497931668600049221.png"></p><h3 id="书面原型和电子原型"><a href="#书面原型和电子原型" class="headerlink" title="书面原型和电子原型"></a>书面原型和电子原型</h3><p>（1）书面原型</p><p>书面原型：有时也称为“低保真原型”</p><p>书面原型：是一种成本低、速度快，且不涉及高深技术的方法。</p><p>书面原型：可以把一个系统的某部分，是如何实现的呈现在用户面前。</p><p>通过书面原型可以判断用户和开发人员对需求的理解是否一致。</p><p>书面原型：可以在代码编制之前，对可能的解决方案进行试验性和低风险的尝试。</p><p>书面原型：所涉及的工具仅仅是纸张、索引卡、粘贴便签和干净的塑料板等。</p><p>设计人员对屏幕布局进行构思，而不必关心布局中控件的精确位置和它们的外观。</p><p>当用户遍历一个评估场景时，一个人就可以充当计算机的角色。</p><p>用户说出他想在特定的屏幕上做什么来启动动作，模仿计算机的人就会把相应的纸张和索引卡拿给用户看，这些纸张和索引卡表示了用户采取这一动作时的外观显示。</p><p>用户就可以判断这是否确实是所期望的响应，并且还可以判断所显示的条目内容是否正确。</p><p>如果有错误，只需要用一张新纸或索引卡，重画一张就可以了。</p><p>书面原型：可以方便地实现快速迭代，而迭代对需求开发的成功与否起着至关重要的作用。</p><p>书面原型：也有助于开发团队管理客户的需求。</p><p>（2）电子原型</p><p>电子原型：就是一个基于计算机的可运行的原型。</p><p>构建一个抛弃式电子原型，可以使用以下工具：</p><ol><li><p>编程语言，例如：Visual Basic，IBM VisualAge Smalltalk和Delphi。</p></li><li><p>脚本语言，例如Perk Python和Rexx（雷克斯）。</p></li><li><p>商业原型制作工具箱、屏幕绘图器和图形用户界面生成器。</p></li><li><p>绘图工具，例如Visio和PowerPoint</p></li></ol><p>运用合适的工具，可以轻松地实现并修改用户界面组件，而不管隐藏在界面背后的代码效率高低。</p><p>如果创建一个演化式原型，那么必须从一开始就使用系统开发工具。</p><h2 id="Summary-5"><a href="#Summary-5" class="headerlink" title="Summary"></a>Summary</h2><p>建立原型的3个目的：</p><p>（1）明确并完善需求</p><p>（2）研究设计选择方案</p><p>（3）发展为最终系统</p><p>根据使用原型的目的不同，原型分为：</p><p>水平原型和垂直原型</p><p>抛弃式原型和演化式原型</p><p>书面原型和电子原型</p><p>水平原型：主要描绘了用户界面的一部分。</p><p>因为水平原型并不能深入到体系结构的所有层次，或者深入到系统的细节。</p><p>垂直原型：也称为：结构化原型、概念的证明</p><p>在整个技术服务层上实现应用程序用户界面的一部分功能。</p><p>建立水平原型目的：</p><p>研究预期系统的一些特定行。</p><p>显示用户界面的屏幕外观、屏幕之间的导航。</p><p>建立垂直原型目的：</p><p>确定所提议的架构方法是否可行和合理。</p><p>优化算法、评估所提议的数据库架构或测试关键的需求。</p><p>（1）抛弃式原型：</p><p>是在原型达到预期目的后，就将原型抛弃掉。</p><p>当团队面临需求中的不确定性、二义性、不完整性或含糊性时，最恰当的方法是建立一个抛弃式原型。</p><p>（2）演化式原型：</p><p>是增量地构建系统，是被开发系统的一个组成部分。</p><p>必须具有健壮性，代码质量从一开始就要达到系统的要求。</p><p>必须易于进行扩展和频繁改进。</p><p>开发人员必须重视软件体系结构和成熟的设计原则。</p><p>（1）书面原型</p><p>书面原型：有时也称为“低保真原型”</p><p>书面原型：是一种成本低、速度快，且不涉及高深技术的方法。</p><p>书面原型：所涉及的工具仅仅是纸张、索引卡、粘贴便签和干净的塑料板等。</p><p>（2）电子原型</p><p>电子原型：就是一个基于计算机的可运行的原型。</p><p>（1）原型评估：</p><p>可以从原型所针对的用例或功能中推导出评估脚本。</p><p>务必要通过合适的人从恰当的角度来评估原型。</p><p>要同时包括有经验的和经验不足的用户类代表。</p><p>（2）创建原型所带来的风险：</p><p>风险1：是项目相关人员看到一个正在运行的原型，从而得出系统几乎已经完成的结论。</p><p>风险2：是用户重点关注的是系统“如何做”的问题，他们关注用户界面的外观如何，以及如何操作这些界面。</p><p>风险3：是用户将根据原型的性能来推断最终系统的期望性能。</p><p>（3）建立有效原型应遵循的原则：</p><ol><li><p>应该在项目计划中包括创建原型的任务。安排好开发、评估和更改原型的时间进度和所需的资源。</p></li><li><p>创建原型之前，先要陈述每个原型的用途。</p></li><li><p>要计划开发多个原型，因为很少能一次便成功。</p></li><li><p>创建抛弃式原型时要用最少的投资开发出用于回答问题和解决需求不确定性的原型。</p></li><li><p>抛弃式原型中不应包括输入数据有效性检查、防御式编码技术、用于错误处理的代码或代码注释。</p></li><li><p>对于已经理解的需求不要建立原型，除非是要研究设计选择方案。</p></li><li><p>在原型显示和报告中使用看似真实的数据。</p></li></ol><h1 id="第10章-确定需求的优先级别"><a href="#第10章-确定需求的优先级别" class="headerlink" title="第10章  确定需求的优先级别"></a>第10章  确定需求的优先级别</h1><h2 id="为什么要设定需求优先级？"><a href="#为什么要设定需求优先级？" class="headerlink" title="为什么要设定需求优先级？"></a>为什么要设定需求优先级？</h2><p>对于每一个受资源限制的软件项目，都必须对要求的功能定义相对优先级。</p><p>设定优先级：有助于项目经理解决冲突、安排阶段性交付，并且做出必要的取舍。</p><p>当用户的期望很高，而且开发时间又很紧迫时，就必须确保在系统的尽早版本中，提供最重要的功能。</p><p>设定优先级：就是一种行之有效的方法，可以处理在资源有限的情况下，应该优先满足哪些需求。</p><p>为每一种功能建立相对优先级后，就可以规划软件的开发过程，以最低的成本提供最佳的系统。</p><p>项目经理必须根据时间进度、项目预算、人力资源以及质量目标等约束条件，权衡考虑，制定出合理的项目范围。</p><p>达到此目的的一种方法是：</p><p>当接受一个更重要的新需求或者项目的其他条件发生变化时，删除优先级低的需求。</p><p>或者把它们推迟到下一版本中实现。</p><p>如果用户并没有将他们的需求按重要性和紧迫性区分开，那么项目经理就必须自己做出决策。</p><p>很可能用户并不赞成项目经理所设定的优先级，这不足为奇。</p><p>用户必须指明哪些需求必须在最初版本中得到实现，哪些需求可以延期实现。</p><p>当有多个可用方案都可以实现一个成功的系统时，应尽早在项目中设定优先级，并且要定期查看它们。</p><p>如果用户并没有将他们的需求按重要性和紧迫性区分开，那么项目经理就必须自己做出决策。</p><p>很可能用户并不赞成项目经理所设定的优先级，这不足为奇。</p><p>用户必须指明哪些需求必须在最初版本中得到实现，哪些需求可以延期实现。</p><p>当有多个可用方案都可以实现一个成功的系统时，应尽早在项目中设定优先级，并且要定期查看它们。</p><p>2）优先级规则</p><p>用户对设定优先级的第1个反应是：</p><p>“所有功能我都需要，无论采用什么方式，只要实现它就行”</p><p>如果用户知道优先级低的需求可能不会实现，那么就很难说服用户讨论需求优先级。</p><p>有些开发人员更喜欢避开设定优先级，因为他们认为：</p><p>他们可以全部完成系统功能。</p><p>事实上，即便是一个中等规模的软件项目，也有好几十个用户需求和好几百个功能需求，多到难以通过分析进行统一归类。</p><p>项目中总有一些系统功能比其他的功能更为必要。</p><p>在项目接近尾声时，当开发人员抛弃掉一些不必要的功能，以保证按期交付一些重要功能的时候，这一特性体现得尤为明显。</p><p>如果在项目的早期阶段设定优先级，并随着用户偏好、市场状况和业务事件的变更而重新评估它们。</p><p>那么，项目团队就可以“好钢用在刀刃上”，合理地将时间花在价值最高的功能中。</p><p>如果某一功能己经实现得差不多了，才得出该功能并不需要的结论。</p><p>则会造成时间上的巨大浪费，同时，也会让人感到很沮丧。</p><p>如果让用户自己设定优先级。</p><p>那么，他们将把85%的需求设定为高优先级，10%的需求设定为中等优先级，5%的需求设定为低优先级。</p><p>这并没有给项目经理很多灵活性。</p><p>如果确实是几乎所有的需求都具有最高的优先级。</p><p>那么，项目就面临着不能完全获得成功的风险，因此，应该制定出相应的计划。</p><p>可以通过废除不必要的需求，并且简化那些过于复杂的需求，来对需求做出调整。</p><p>为了帮助用户代表确认哪些需求属于低优先级的需求，分析人员可以向他们询问如下几个问题：</p><ol><li><p>是否有其他方法可以满足这一需求?</p></li><li><p>如果忽略或推迟实现这一需求，其后果是什么?</p></li><li><p>如果不立即实现这一需求，那么对项目业务目标会有什么影响?</p></li><li><p>如果将这一需求推迟到下一版本中实现，用户为什么会不满意?</p></li></ol><p>在一个小型项目中，项目相关人员可以非正式地就需求的优先级达成共识。</p><p>对于大型项目或有争议的项目，则需要采用一种更加结构化的方法，这样在处理过程中，可以消除一些感情因素、政策因素以及推测。</p><p>人们提出许多分析上的和数学上的技术，用于辅助需求优先级的确定。</p><p>这些方法包括：建立每个需求的相对价值和相对成本。</p><p>优先级最高的需求是那些以最低的成本生产出最高的系统价值的需求。</p><h2 id="确定需求优先级的一些技术："><a href="#确定需求优先级的一些技术：" class="headerlink" title="确定需求优先级的一些技术："></a>确定需求优先级的一些技术：</h2><p>入选与落选</p><p>两两比较并排序</p><p>三层分级法</p><p>MoSCoW（莫斯科欧）排序法</p><p>在MoSCoW（莫斯科欧）优先级排序法中，四个大写字母代表在一个需求集合中四类可能的优先级类别，具体如下：</p><p>M字母，指的是：Must（必做）：需求必须满足，只有这样，解决方案才会被认为是成功的。</p><p>S字母，指的是：Should（应做）：需求很重要，并且如果可能，应当包含到解决方案中，但对于成功不是强制性的。</p><p>C字母，指的是：Could（可做）：想要但是可以推迟或者清除，只有当时间和资源都允许的时候才实现。</p><p>W字母，指的是：Won’t（不做）：表示这次不实现，但可能包含到未来的版本中。</p><p>对于如何通过比较其他需求来评级给定需求的优先级，MoSCoW（莫斯科欧）排序法并没有给出相关的依据。</p><p>MoSCoW（莫斯科欧）排序法：不关注时间，特别是需求被评定为“Won’t”时，极可能意味着“不在下个版本中做”，也可能意味着“永远不做”</p><p>设定优先级的一种方法是：</p><p>质量功能部署（简称：QFD）</p><p>质量功能部署：是将用户价值和所提议的系统功能相联系的一种综合方法。</p><p>在质量功能部署方法中，用户价值取决于两个方面：</p><p>一方面，如果实现了特定的系统特性，将为用户提供收益；</p><p>另一方面，如果不能实现系统特性，用户收益就要受到损害。</p><p>这个设定优先级的方法可适用于除了最高优先级之外的所有需求。</p><p>根据价值、成本和风险来设定优先级方法：</p><p>借鉴了质量功能部署的概念，对用户价值加以考虑。</p><p>即，考虑如果获得某个特定系统特性，会为用户提供什么收益，也考虑到如果没有那个特性，会带来什么损失。</p><p>在设定优先级的过程中典型的参与者有：</p><p>项目经理、用户代表和开发人员代表。</p><p>项目经理：负责整个过程，解决冲突，并且在必要的时候协调其他参与者的意见。</p><p>用户代表：可以提供受益和损失的程度。</p><p>开发人员代表：可以提供成本和风险程度。</p><p>根据价值、成本和风险来设定优先级，必须遵循如下8个步骤：</p><ul><li>步骤1：在表格中列出要设定优先级的所有特性、用例或功能需求。</li></ul><p>所有条目都必须在同一抽象级别上，不要把功能需求与系统特性混合在一起。</p><p>如果某些特性有逻辑上有联系，在分析中只要列出驱动较全面的项。如果有更多的项，那么就把相关的特性归成一类，并建立一个可管理的初始化列表。</p><p>如果需要的话，可以在更详细的级别上进行第二轮分析。</p><ul><li>步骤2：让用户代表来估计每一个特性提供给用户或业务的相关收益，并用1-9划分等级，1代表对任何人都没用的特性，9代表具有最大价值的特性。</li></ul><p>这些收益等级表明这些特性与系统业务需求的一致性。</p><ul><li>步骤3：估计出如果没有把某一特性包括到系统中，将会给用户或业务上带来的相对损失。</li></ul><p>仍然使用1-9划分等级，这里1代表即使不包括这一特性也无人会介意，9代表如果不包括这一特性将带来严重损失。</p><p>对于具有低收益低损失的需求只会增加费用，而不会增加价值；</p><p>步骤4：将表格中的“相对收益”和“相对损失”相加，并考虑权值，计算出每个特性的总价值。</p><p>即：总价值 &#x3D; 相对收益<em>收益权值 + 相对损失</em>损失权值</p><p>并计算出每个特性价值占总价值的百分比。</p><p>即：“价值%”一栏。</p><p>步骤5：让开发人员估计实现每个特性的相对成本，并计算出每个特性价值占总相对成本的百分比。</p><p>使用1-9来划分等级，1代表快速而容易，9代表费时又昂贵。</p><p>根据特性的复杂度、所需要的用户界面的实际情况、重用当前代码的潜在能力、所需的测试量和文档等等，开发人员可以估算出相对成本。</p><p>步骤6：让开发人员估计出与每个特性相关的技术风险或其他风险的相对程度，并计算出每个特性所产生的风险百分比。</p><p>技术风险：是指第1次尝试实现某个特性时，不能成功的概率。</p><p>使用1-9来划分等级，1表示可以轻松地实现编程，9表示需要重点关注其可行性、缺乏具有专门知识的人员，或者使用不成熟或不熟悉的工具和技术。</p><p>如果根本无需在分析中考虑风险，就把风险的权值设为0。</p><p>步骤7：把所有的估算值都填入表格之后，就可以利用优先级公式，计算出每一特性的优先级值。</p><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16686023507921668602350675.png"></p><p>步骤8：按计算出的优先级的降序排列表中的特性。处于列表最顶端的特性是价值、成本和风险之间的最佳平衡，因此，具有最高的优先级。</p><h1 id="Summary-6"><a href="#Summary-6" class="headerlink" title="Summary"></a>Summary</h1><p>设定需求优先级原因：</p><p>设定优先级有助于项目经理解决冲突、安排阶段性交付，并且做出必要的取舍。</p><p>为每一种功能建立相对优先级后，就可以规划软件的开发过程，以最低的成本提供最佳的系统。</p><p>分析人员可以向用户询问的几个问题：</p><ol><li><p>是否有其他方法可以满足这一需求?</p></li><li><p>如果忽略或推迟实现这一需求，其后果是什么?</p></li><li><p>如果不立即实现这一需求，那么对项目业务目标会有什么影响?</p></li><li><p>如果将这一需求推迟到下一版本中实现，用户为什么会不满意?</p></li></ol><p>确定需求优先级的技术，包括：</p><p>入选与落选</p><p>两两比较并排序</p><p>三层分级法</p><p>MoSCoW（莫斯科欧）排序法</p><p>设定优先级的质量功能部署方法：</p><p>质量功能部署（简称：QFD）</p><p>质量功能部署：是将用户价值和所提议的系统功能相联系的一种综合方法。</p><p>根据价值、成本和风险来设定优先级，有8个步骤。</p><p>以“化学品跟踪系统”的特性为例，介绍了根据价值、成本和风险来设定优先级的过程。</p><p>注意：</p><p>计算出来的优先级序列，只能作为一种指导策略的参考。</p><p>客户和开发者代表应该讨论，从而达成共识，并根据使用情况来校正。</p><p>可以适当调整每一因素的权值，直到所计算出的优先级序列与后来对测试集中需求的重要性评估相吻合为止。</p><p>在把需求优先级的设定，应以客观和分析为基础</p><h1 id="第11章-需求确认"><a href="#第11章-需求确认" class="headerlink" title="第11章   需求确认"></a>第11章   需求确认</h1><ul><li><p>需求确认：是指开发方和用户方共同对软件需求规格说明进行评审，双方对需求达成共识后作出承诺。</p></li><li><p>是需求开发的最后一个环节。可以通过内部评审、同行评审以及用户评审的方式来完成。</p></li><li><p>项目组内部评审或同行评审：主要是根据公司规范和评审人员本身的经验对需求分析中不明确、不合理、不符合逻辑、不符合规范的地方予以指正。</p></li><li><p>用户评审：主要是对描述的软件实现是否真正符合他们的需求，能否帮助他们解决问题等方面做出评定。</p></li><li><p>需求确认的目的：是要检验需求是否能够反映用户的意愿。是尽可能地发现需求里的错误，减少因后期修改需求错误所带来的损失。</p></li></ul><p>需求确认的提出：</p><h2 id="避免信息衰减的关键手段"><a href="#避免信息衰减的关键手段" class="headerlink" title="避免信息衰减的关键手段"></a>避免信息衰减的关键手段</h2><ol><li><p>文档</p><p>如果信息在传递的过程中仅靠口头传递，就难免发生遗忘、加工等情况。</p><p>因此，必须在这个过程中有效地利用文档，将达成共识的信息文档化。</p><p>但这种方法只是用来辅助沟通的，而不是代替沟通。</p></li><li><p>评审</p><pre><code> 评审：在很多人的脑海中就是得出一个通过与否的结论，这也是导致需求评审工作流于形式的罪魁祸首之一。  评审：是通过再次的审读，尽早地暴露出错误。  最简单、有效的评审：是在用户代表阐述了需求之后，需求分析员用自己的语言再复述一遍，以确保沟通没有失真。  评审的首要任务：是确认需求是否充分，并正确的反映了用户的需求。</code></pre></li></ol><p>需求确认：</p><p>首先需要用户来验证结构和文档化后的需求是否和他们的想法一致，是否把用户的真实意图描述清楚了，以保证需求本身的正确性。</p><p>对于后续设计开发阶段的人员也需要对需求进行评审，以保证需求的可实现性，确认需求描述是否清楚，是否是可以实现的，对于业务对象，流程和规则是否存在不可实现的模糊描述词语。</p><p>对于测试人员，则主要是确认需求是否是可测试的，是否在需求描述中存在不确定和不可测试的词语。</p><p>不仅仅是需求阶段对需求文档的评审，还需要关注设计，开发等各阶段对需求的实现情况的验证。指在需求规格说明完成之后，对需求规格说明文档进行的验证活动。是对需求的复查和审核，目的是发现需求中存在的错误，以便及时更正，避免在后期实施中修改造成大量的损失。</p><p>好的需求将会带来好的系统质量和用户满意度，降低系统后期维护和用户支持的费用。</p><h2 id="需求确认的任务："><a href="#需求确认的任务：" class="headerlink" title="需求确认的任务："></a>需求确认的任务：</h2><p>需求确认的活动确保以下几个方面的内容：</p><ol><li><p>软件需求规格说明是否正确描述了目标系统的行为和特征；</p></li><li><p>从系统需求、业务规则或其他来源中得到软件需求；</p></li><li><p>需求是完整的和高质量的；</p></li><li><p>所有人对需求的看法是一致的；</p></li><li><p>需求为进一步的软件开发和测试提供了足够的基础。</p></li></ol><p>需求确认的任务：就是要求各方人员从不同的技术角度对需求规格说明文档做出综合性评价。</p><h2 id="需求确认的内容："><a href="#需求确认的内容：" class="headerlink" title="需求确认的内容："></a>需求确认的内容：</h2><p>一般来说，从下述4个方面进行需求验证：</p><p>1）一致性：所有需求必须是一致的，任何一条需求不能和其他需求相矛盾。</p><p>2）完整性：需求必须是完整的，软件需求规格说明应包括用户需要的每一个功能和性能。</p><p>3）现实性：指定的需求在现有的硬件技术或软件技术的基础上应该是基本上可行的。</p><p>4）有效性：必须证明需求是正确有效的，确实能解决用户需求间的矛盾。</p><p>一般可根据软件系统的特点和用户的要求增加一些检验内容。</p><p>如：软件的可信特性，即安全性、可靠性、正确性以及系统的灵活性等。</p><p>验证需求规格说明的方法，除形式化方法外，大部分只能通过人工进行检测。</p><p>此外，部分项目相关人员也不愿意在需求确认方面花费时间。</p><p>形式化的验证方法主要使用数学方法：</p><p>即，将软件系统抽象为用数学符号表示的形式系统。</p><p>然后，通过推理和证明的方式来验证软件系统中的一些性质，如：完整性、一致性、可信特性等。</p><p>这种方法的好处：是严格和自动化。</p><p>这种方法的不足：是对数学基础的要求太高，难度较大。</p><p>通过人工进行检测的方式有很多，例如：需求评审。</p><p>这种方式就是让与项目相关的所有人员参加，并根据验证的内容人工评审软件需求规格说明文档。</p><p>另外，还可结合现有的一些软件技术，如：设计测试用例的方法等，对软件需求进行多方面的、有效的检验和测试</p><h2 id="需求评审方法"><a href="#需求评审方法" class="headerlink" title="需求评审方法"></a>需求评审方法</h2><p>需求评审：是由需求评审员对软件需求规格说明进行检查，以发现其所存在的问题。</p><p>通过对需求规格说明的评审，可以发现其中的不确定和二义性的要求等。</p><p>需求评审，可划分为：非正式评审和正式评审</p><p>非正式评审：由开发人员描述系统并征求意见。</p><p>包括：把工作系统分发给许多其他有关人员，粗略地看一看或走过场地检查。</p><p>非正式评审的好处：是能培养其他人对系统的认识，并可获得一些非结构化的反馈信息。</p><p>非正式评审的不足：是不够系统化和不彻底，或者在实施过程中不具有一致性，并且非正式评审不需要记录，完全可以根据个人爱好进行。</p><p><strong>非正式评审方法包括：</strong></p><p>——同级桌面检查：就是请一位同事检查系统</p><p>——轮查：就是同时请若干同事分别检查可交付的系统</p><p>——走查：作者向评审员描述系统，请求做出评论。</p><p>正式评审：由不同背景的审查人员组成小组，阅读需求规格说明文档，把其中的问题记录下来，再转送给软件开发人员。</p><p>正式评审：有专门的审查人员，正规的审查过程和步骤，审查人员有严格的分工和职责。</p><p>需求评审的组成人员</p><p>在需求正式评审过程中，应由具有不同背景的人组成一个小组，对需求规格说明文档进行评审。</p><p>审查人员由4个方面的人组成：</p><p>1）从事软件系统需求开发的相关人员。</p><p>这类人员主要是指编写需求规格说明的系统分析员及相应参与人员等。</p><p>2）具有需求分析经验和知识的人员，以及领域专家等。</p><p>这些人可以审查需求规格说明文档是否符合标准，是否存在错误等。</p><p>3）客户或用户代表。</p><p>这些人可以保证需求规格说明能正确地、完整地描述他们的需求。</p><p>4）软件开发人员，</p><p>如：设计人员、测试人员、项目经理等。这些人可以发现需求规格说明中存在的不可实现的、含糊或二义性等。</p><p><strong>审查人员的主要角色：</strong></p><p><strong>作者</strong>：编写正在被审查的需求规格说明文档的人，通常为系统分析员。</p><p>他们听取其他审查员的评论，并回答其他审查员提出的问题，但不参与讨论。</p><p><strong>调解员</strong>：审查的调解与主持人，通常为项目总负责人。</p><p>调解员与作者一起制定审查计划，协调审查期间的各种活动，以及推进审查工作的进行。</p><p><strong>读者</strong>：主要由审查员扮演，审查需求规格说明文档，并提出问题，以及自己的看法和理解。</p><p><strong>记录员</strong>：以标准的形式记录在审查中提出的问题和缺陷。</p><p>记录员必须仔细地整理自己所写的材料，以确保记录的正确性。</p><h2 id="需求评审的过程"><a href="#需求评审的过程" class="headerlink" title="需求评审的过程"></a>需求评审的过程</h2><p>规范的评审过程包括：规划、总体会议、会前准备、评审会议、返工、跟踪6个阶段。</p><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16686067658051668606765489.png"></p><p>1）规划</p><p>由作者和调解员对审查进行规划。</p><p>如：决定谁参加审查，审查之前应准备什么材料，审查会议的日程安排等。</p><p>2）总体会议</p><p>总体会议：可以为审查员提供了解会议的信息。</p><p>包括：要审查的材料背景，作者所做的假设和作者的特定审查目标。</p><p>如果所有的审查员对要审查的项目都很熟悉，那就可以省略本次会议。</p><p>3）准备</p><p>准备工作：做的好不好直接关系到评审会议的质量。</p><p>应为每位评审者提前提供相关资料，提供时间做相关阅读、查找错误。</p><p>评审者可将阅读时发现的文字、版面类的错误直接发给作者，无需在评审会议上讨论，以便节省会议时间，提高会议质量。</p><p>4）评审会议</p><p>在进行审查的过程中，审查员审查软件需求规格说明中的每一个需求。</p><p>当审查员提出可能的错误或其他问题时，记录员就记录这些内容，它们可以成为需求规格说明的作者的参考依据。</p><p>会议的目的是尽可能多地发现需求规格说明中的重大缺陷。</p><p>开审查会的时间不宜过长，如果需要更多的时间，就另外再安排一次会议。</p><p>5）返工</p><p>当发现需求规格说明中出现问题时，作者必须在审查会之后安排一段时间用于修改文档。</p><p>如果把不正确的需求拖延到以后修改，将十分费时。</p><p>马上修改可以解决二义性和消除模糊性，并为成功开发项目打下坚实的基础。</p><p>6）跟踪</p><p>当发现同一类错误多次出现在需求规格说明书中不同地方时，就会发现评审中提出的问题没有得到有效的解决。</p><p>因此，应对提出的问题是否解决进行跟踪、督促，避免同类问题再出现。</p><h2 id="需求评审面临的困难"><a href="#需求评审面临的困难" class="headerlink" title="需求评审面临的困难"></a>需求评审面临的困难</h2><p>当需求规格说明编写完成后，开发人员希望能尽快地开发软件系统。</p><p>认为需求评审工作是重要的。</p><p>但最重要的是后面的开发工作，从而导致需求评审成为“走过场”。</p><p>在需求评审工作中，一些常见的问题说明如下：</p><p>1）大型的需求文档</p><p>对于一个大的复杂软件系统，其需求规格说明往往有几百页，要审查这样的需求规格说明工作量是非常大的。</p><p>既使一个中型的需求规格说明，审查人员可能会认真地检查开始的部分，有耐心的人可能会审查到中间的部分，但无人可以坚持检查到最后。</p><p>这就导致忽略审查过程，而直接进入软件的开发工作。</p><p>对于上述问题的解决方案是：</p><p>可在强调评审工作重要性的基础上，采用多人分段审查的方式，让一些审查员，从文档的不同位置开始检查，以确保认真地检查其中的每一页，或者采取分组方式，不同组分别审查材料的不同部分。</p><p>2）庞大的审查小组</p><p>一个项目可能涉及许多的相关人员，如：用户、部门经理、销售部门等，他们都与需求相关。</p><p>这些人都可以成为需求评审员。</p><p>然而，评审小组过于庞大，将导致难于安排会议，并且在审查会议上经常引发题外话，在许多问题上也难于达成一致意见。</p><p>这种情况经常导致花了大量的时间而无较好的结果等。</p><p>对于上述这些困难，往往要根据实际情况给予解决。</p><p>例如，可在强调评审工作重要性的基础上，采取解释与说明的方式，采用多人分段审查的方式，以及采取分组方式等。</p><h2 id="测试需求"><a href="#测试需求" class="headerlink" title="测试需求"></a><strong>测试需求</strong></h2><p>测试需求概述</p><p>测试需求，是验证需求是否是正确的、完整的、无二义性的。</p><p>测试人员要能够分辨出来问题点，并跟用户进行核对，确定用户的真实需求。</p><p>测试需求的输入主要包括：</p><p>需求规格说明、用户用例、界面设计、项目会议或与用户沟通时有关需求信息的会议记录、其他技术文档等；</p><p>测试需求的输出主要包括：</p><p>问题点及修改建议，以及测试分析结果。</p><p>在部分需求稳定时，就可以开始设计测试用例，及早发现问题并以较少的费用解决这些问题。</p><p>测试需求：是对测试目标的概括，根据测试需求，了解测试时所应测试的功能点。</p><p>测试需求：主要是整理测试焦点。</p><p>包括：一些界面、输入域、业务流程、数据等。</p><p>并明确测试焦点的优先级，为测试用例的设计提供测试所需的功能点信息。</p><p>测试需求：是告诉要测什么，而测试用例是告诉怎么测。</p><p>好的测试需求：能发现需求中显性和隐性的测试焦点，从而能更好地指导测试用例的设计。</p><p>在开发过程的早期阶段，可以从用例中获得概念上的功能测试用例。</p><p>即，可验证需求规格说明和分析模型，并做出评价。</p><p>为什么要进行测试需求？</p><p>1）把不直观的需求转变为直观的需求。</p><p>使得测试范围可以度量；</p><p>使得独立的功能点其对应的所有的处理分支可以度量；</p><p>使得该系统需要测试的业务场景可以度量；</p><p>2）把不明确的需求转变为明确的需求，明确其功能点对应的输出、处理和输出；</p><p>3）把不能度量的需求转变为可度量的需求。</p><p>包括：度量测试范围，度量处理分支，度量业务场景。</p><p>需求测试的范围主要有：</p><p>1）需求的背景，目标，影响范围；</p><p>2）系统的输入输出，类型，精度，允许的出错次数，输出的格式，数据的来源以及正确性；</p><p>3）响应时间，提示的方式，异常处理方式，性能指标；</p><p>4）主要流程描述，操作流程和步骤说明，分析是否合理化；</p><p>5）需求的上下文是否一致，有没有与其他需求发生冲突；</p><p>6）需求逻辑是否足够清晰，每个条款是否都包含描述问题及解决问题；</p><p>7）需求是否都是可测试的；</p><p>8）寻找隐含的需求，和相互依赖的需求。</p><p>4）推荐的需求文档格式的内容</p><p>主要有：</p><p>1）业务名称解释；</p><p>2）需求背景及目标介绍；</p><p>3）用户操作场景说明；</p><p>4）功能总览：</p><p>如：逐项叙述对系统所提出的功能要求，说明输入什么量、经怎么样的处理、得到什么输出；</p><p>5）系统交互图；</p><p>6）界面原型；</p><p>7）业务规则说明；</p><p>8）业务正常流程：如：功能模块流程，主要操作流程；</p><p>9）业务异常流处理：如：异常场景，错误提示；异常流转。</p><p>4）推荐的需求文档格式的内容</p><p>这里要注意：</p><p>需求测试：不等同于集成测试或者系统测试。</p><p>软件测试，都是软件已经编写完成的条件下，判断软件是否会出错。</p><p>而需求测试，只是验证需求是否真正是用户的要求。</p><h2 id="Summary-7"><a href="#Summary-7" class="headerlink" title="Summary"></a>Summary</h2><p>需求确认：是软件工程中一项重要的活动。</p><p>需求确认：是需求工程中发生的对需求规格说明文档进行的验证与确认活动。</p><p>需求确认：不仅要发现问题，而且要监督、跟踪问题的解决。</p><p>验证和确认的过程：贯穿于项目开发的每个阶段。</p><p>尽早的了解系统需求，可很大程度上节约后期修改的成本。</p><p>需求确认，主要包括：需求的评审和作出承诺。</p><p>需求确认的目的：</p><p>是要检验需求是否能够反映用户的意愿。</p><p>是尽可能地发现需求里的错误，减少因后期修改需求错误所带来的损失。</p><p>需求确认，主要包括：需求的评审和作出承诺。</p><p>需求确认的目的：</p><p>是要检验需求是否能够反映用户的意愿。</p><p>是尽可能地发现需求里的错误，减少因后期修改需求错误所带来的损失。</p><p>（1）需求确认的任务：</p><p>是对需求规格说明文档做出综合性评价。</p><p>需要确认的内容主要是验证需求的：</p><p>一致性、完整性、现实性、有效性4个方面。</p><p>（2）需求确认的内容：</p><p>一致性</p><p>完整性</p><p>现实性</p><p>有效性</p><p>（1）需求评审方法：</p><p>需求评审：就是由需求评审员对软件需求规格说明进行检查，以发现其所存在的问题。</p><p>需求评审可划分为：非正式评审和正式评审</p><p>（2）需求评审的组成人员：</p><p>1）从事软件系统需求开发的相关人员。</p><p>2）具有需求分析经验和知识的人员，以及领域专家等。</p><p>3）客户或用户代表。</p><p>4）软件开发人员。</p><p>3）需求评审的过程：</p><p>规范的评审过程包括：规划、总体会议、会前准备、评审会议、返工、跟踪6个阶段。</p><p>（4）需求评审面临的困难：</p><p>1）大型的需求文档</p><p>对于一个大的复杂软件系统，其需求规格说明往往有几百页，要审查这样的需求规格说明工作量是非常大的。</p><p>2）庞大的审查小组</p><p>一个项目可能涉及许多的相关人员，如：用户、部门经理、销售部门等，他们都与需求相关。</p><p>测试需求的解释：</p><p>测试需求，是验证需求是否是正确的、完整的、无二义性的。</p><p>为什么要进行测试需求？</p><p>1）把不直观的需求转变为直观的需求。</p><p>2）把不明确的需求转变为明确的需求，明确其功能点对应的输出、处理和输出；</p><p>3）把不能度量的需求转变为可度量的需求。</p><p>需求测试的内容：</p><p>1）需求的背景，目标，影响范围；</p><p>2）系统的输入输出，类型，精度，允许的出错次数，输出的格式，数据的来源以及正确性；</p><p>3）响应时间，提示的方式，异常处理方式，性能指标；</p><p>4）主要流程描述，操作流程和步骤说明，分析是否合理化；</p><p>5）需求的上下文是否一致，有没有与其他需求发生冲突；</p><p>6）需求逻辑是否足够清晰，每个条款是否都包含描述问题及解决问题；</p><p>7）需求是否都是可测试的；</p><p>8）寻找隐含的需求，和相互依赖的需求。</p><p>推荐的需求文档格式的内容：</p><p>1）业务名称解释；</p><p>2）需求背景及目标介绍；</p><p>3）用户操作场景说明；</p><p>4）功能总览；</p><p>5）系统交互图；</p><p>6）界面原型；</p><p>7）业务规则说明；</p><p>8）业务正常流程：如：功能模块流程，主要操作流程；</p><p>9）业务异常流处理：如：异常场景，错误提示；异常流转。</p><h1 id="第12章-需求管理实践"><a href="#第12章-需求管理实践" class="headerlink" title="第12章   需求管理实践"></a>第12章   需求管理实践</h1><p>（1）需求管理内容<br>软件需求工程，分为：需求开发和需求管理。<br>需求开发活动：<br>包括：获取需求、分析需求、描述需求和确认需求。<br>需求开发的交付物：<br>包括：业务需求、用户需求、功能需求、非功能需求、数据字典和各种分析模型等。<br>在这些交付物经过评审，且核准之后，这些条目的任何已定义子集都可以组成需求基线。[toc]</p><h1 id="第0章-引言-1"><a href="#第0章-引言-1" class="headerlink" title="第0章 引言"></a>第0章 引言</h1><h2 id="项目失败或严重超支的8个最重要原因中有5个都与需求相关：-1"><a href="#项目失败或严重超支的8个最重要原因中有5个都与需求相关：-1" class="headerlink" title="项目失败或严重超支的8个最重要原因中有5个都与需求相关："></a>项目失败或严重超支的8个最重要原因中有5个都与需求相关：</h2><ol><li>需求不完整</li><li>缺乏用户的参与</li><li>用户期望不实际</li><li>需求和需求规格说明的变更</li><li>提供许多不必要的功能。</li></ol><h2 id="“软件需求分析”：-1"><a href="#“软件需求分析”：-1" class="headerlink" title="“软件需求分析”："></a>“软件需求分析”：</h2><p>就是对需要解决的问题进行详细分析</p><p>弄清楚需要解决的问题，开发人员才能顺利开发出用户真正需要的软件。</p><p>如果一味追求进度，而忽略软件需求分析，很可能南辕北敏，开发变得毫无意义。</p><p>“软件需求分析”：是连接开发人员和用户之间的重要纽带。只有真正理解用户的需求，才能设计出用户所需要的软件。</p><p>“软件需求分析”：</p><p>就是分析软件用户的需求是什么。</p><p>如果投入大量的人力、物力、财力、时间，开发出的软件却没人要，那所有的投入都是徒劳。</p><p>如果费了很大的精力，开发一个软件系统，最后却不满足用户的要求，从而要重新开发过，这种返工是让人痛心疾首的。</p><p>总之，软件需求问题不仅关系到软件项目开发的成功，也关系到软件产业的发展，更关系到各行各业信息化目标的实现。</p><p>解决软件需求问题已成为软件领域刻不容缓的任务。</p><h1 id="第1章-软件需求概述-1"><a href="#第1章-软件需求概述-1" class="headerlink" title="第1章  软件需求概述"></a>第1章  软件需求概述</h1><p>软件需求的好坏直接关系到软件的成功与否。</p><p>客户提出的需求是软件系统的源头，它定义了软件系统的意图和目的。</p><p>如果需求遗漏或完成得不好，不管系统多么完美，系统也是失败的。</p><p>为了得到有效的需求，需要采用有效的方法与用户广泛地交流。</p><h2 id="定义：-2"><a href="#定义：-2" class="headerlink" title="定义："></a>定义：</h2><p>① 用户解决问题或达到目标所需的条件或权能。</p><p>② 系统或系统部件要满足合同、标准、规范或其他正式规定文档所需具有的条件或权能。</p><p>③ 一种反映上面两种所描述的条件或权能的文档说明。</p><h2 id="基本原则：-1"><a href="#基本原则：-1" class="headerlink" title="基本原则："></a>基本原则：</h2><p>1）并没有一个清晰、毫无歧义性的“需求”术语存在，真正的“需求”实际上在人们的脑海中。</p><p>2）定义问题，而不是解决方案。</p><p>3）定义系统，而不是项目。需求定义了系统需要做什么：它们是一组目标。</p><p>4）区分正式和非正式部分。</p><p>5）避免重置。</p><p>6）保持每个需求定义的大小在合适的范围内是良好的做法。</p><h2 id="软件需求的层次：-1"><a href="#软件需求的层次：-1" class="headerlink" title="软件需求的层次："></a>软件需求的层次：</h2><ol><li>业务需求（Business Requirement ）</li><li>用户需求（User Requirement）</li><li>软件需求（Software Requirement）</li></ol><h3 id="业务需求：-1"><a href="#业务需求：-1" class="headerlink" title="业务需求："></a>业务需求：</h3><p>是从业务角度描述的，是指导软件开发的高层需求。</p><p>业务需求的目标体现在两个方面：</p><p>1）问题：解决企业运行过程中遇到的问题。</p><p>2）机会：抓住外部环境变化所带来的机会，以便为企业带来新的发展。</p><p>业务需求：是从各个不同的人那里收集来的，它们包括主办者、客户、支付或采购软件产品者、开发公司的高级管理人员等。</p><p>业务需求：阐明产品的高层次概念和产品的主要业务内容。</p><p>业务需求：说明客户、公司和想从该系统获利的风险承担者或从系统中取得结果的用户所要求的目标。</p><p>业务需求：为后继工作建立了一个指导性的框架。</p><h3 id="用户需求：-1"><a href="#用户需求：-1" class="headerlink" title="用户需求："></a>用户需求：</h3><p>是指描述的是用户使用软件需要完成什么任务。</p><p>用户需求：是在业务需求基础上进行用户访谈、调查，对用户使用的场景进行整理，从而建立用户角度的需求。</p><p>用户需求具有两个方面的特点：</p><p>1）零散：用户会给出不同角度、不同层面、不同粒度的用户需求。</p><p>2）存在矛盾：由于用户的层次不同，导致需求的片面性，甚至在不同用户之间会有不同的观点。</p><h3 id="软件需求：-1"><a href="#软件需求：-1" class="headerlink" title="软件需求："></a>软件需求：</h3><p>是需求分析与建模的产物。</p><p>软件需求：必须根据用户需求来考虑，并要与业务需求所设定的目标相一致。</p><p>用户需求：具有零散、存在矛盾的特点。</p><p>  —— 因此，需求分析人员还需要对其进行分析、提炼、整理，从而生成指导开发的、更精确的软件需求。</p><h2 id="软件需求可以分为：-1"><a href="#软件需求可以分为：-1" class="headerlink" title="软件需求可以分为："></a>软件需求可以分为：</h2><ul><li>功能需求（Functional Requirement）</li><li>非功能需求（Non-Functional Requirement）</li><li>设计约束</li></ul><h3 id="功能需求：-1"><a href="#功能需求：-1" class="headerlink" title="功能需求："></a>功能需求：</h3><p>是一个系统必须提供的活动和服务描述。</p><p>功能需求：定义了开发人员必须实现的软件功能，使得用户能完成他们的任务，从而满足业务需求。</p><p>开发人员根据功能需求来设计软件以实现必需的功能。</p><p>功能需求：描述软件系统所应具有的外部行为，它在开发、测试、质量保证、项目管理以及相关项目功能中都将起到重要的作用。</p><h3 id="非功能需求：-2"><a href="#非功能需求：-2" class="headerlink" title="非功能需求："></a>非功能需求：</h3><p>描述了系统展现给用户的行为和执行的操作等。</p><p>非功能需求：包括外部界面的具体细节、性能要求及质量属性。</p><p>非功能需求：是产品必须具备的品质，它们可以让产品更具有吸引力、易于使用、快速、可靠或者安全。</p><p>非功能需求：通常并不改变产品的功能。</p><p>一般来说，不管增加多少的质量属性，功能需求都会保持不变，功能需求和非功能需求是相辅相成密不可分的。</p><p>非功能需求：经常被忽略，因为它们不易被发现，发现后不易表达、实现以及测试。</p><p>在系统实现过程中，有时候满足非功能需求往往比满足功能需求更为重要。</p><h3 id="设计约束：-1"><a href="#设计约束：-1" class="headerlink" title="设计约束："></a>设计约束：</h3><p>是指对开发人员在软件产品设计和构造上的限制，产品必须遵从的标准、规范和合约。</p><p>设计约束：包括：非技术因素的技术选型、预期的软硬件环境和预期的使用环境三大类型。</p><p>技术开发团队在决定架构、选择技术时，会受到企业实际的软硬件环境的影响，如果忽略了这个方面的因素会给项目带来一些不必要的麻烦。因此，在需求人员整理需求时，应该将这些预期的软硬件环境描述出来。</p><p> 实现有效的需求工程过程可以让组织受益匪浅。减少开发后期以及整个维护过程中不必要的返工，并可带来极大的回报。</p><h2 id="高质量软件需求的可以带来好处：-1"><a href="#高质量软件需求的可以带来好处：-1" class="headerlink" title="高质量软件需求的可以带来好处："></a>高质量软件需求的可以带来好处：</h2><ul><li>减少需求的缺陷</li><li>减少开发过程中的返工</li><li>减少不必要的特性</li><li>降低改进成本</li><li>加快开发进度</li><li>提高沟通效率</li><li>控制需求范围的改变</li><li>项目更有序</li><li>对系统测试的评估更准确</li><li>10）提高客户和开发人员的满意度</li></ul><h2 id="需求陈述的特点：-1"><a href="#需求陈述的特点：-1" class="headerlink" title="需求陈述的特点："></a>需求陈述的特点：</h2><ol><li><h3 id="完整性-1"><a href="#完整性-1" class="headerlink" title="完整性"></a>完整性</h3><ul><li>每一项需求都必须完整地描述即将交付使用的功能。</li><li>它必须包含开发人员设计和实现这项功能需要的所有信息</li></ul></li><li><h3 id="正确性-1"><a href="#正确性-1" class="headerlink" title="正确性"></a>正确性</h3><ul><li>每一项需求都必须准确地描述将要开发的功能。</li><li>如果一项软件需求与其相对应的系统需求发生冲突就是不正确的。</li><li>只有用户代表才能决定用户需求的正确性。</li></ul></li><li><h3 id="可行性-1"><a href="#可行性-1" class="headerlink" title="可行性"></a>可行性</h3><ul><li>需求必须能够在系统及其运行环境的已知能力和约束条件内实现，因此，由开发人员来进行可行性检查，判断技术上能够实现哪些需求，或者什么功能需要额外的成本才能实现。</li></ul></li><li><h3 id="必要性-1"><a href="#必要性-1" class="headerlink" title="必要性"></a>必要性</h3><ul><li><p>每一项需求记录的功能都必须是用户的真正需要，或者是为符合外部系统需求或某一标准而必须具备的功能。</p></li><li><p>每项需求都必须来源于有权定义需求的一方。对每项需求都必须追溯至特定的客户需求的来源。</p></li></ul></li><li><h3 id="有优先次序-1"><a href="#有优先次序-1" class="headerlink" title="有优先次序"></a>有优先次序</h3><ul><li>为每一项功能需求、特性或用例指定一个实现优先级，以表明它在产品的某一版本中的重要程度。</li><li>如果把所有的需求都看作同样重要，那么项目管理者在开发或节省预算或调度中就丧失控制自由度。</li></ul></li><li><h3 id="无歧义-1"><a href="#无歧义-1" class="headerlink" title="无歧义"></a>无歧义</h3><ul><li>一项需求对所有读者应该只有一种一致的解释，由于自然语言极易导致二义性，所以尽量把每项需求用简洁明了的用户的语言表达出来。</li><li>避免二义性的有效方法包括对需求文档的正规审查、编写测试用例、开发原型以及设计特定的方案脚本。</li></ul></li><li><h3 id="可验证性-1"><a href="#可验证性-1" class="headerlink" title="可验证性"></a>可验证性</h3><ul><li>检查一下每项需求是否能通过设计测试用例或其它的验证方法，如用演示、检测等方法来确定产品是否确实按需求实现了。</li><li>如果需求不可验证，则确定其实施是否正确就成为主观臆断，而非客观分析了。</li><li>一份前后矛盾，不可行或有二义性的需求也是不可验证的。</li></ul></li></ol><h2 id="需求规格说明的特点：-1"><a href="#需求规格说明的特点：-1" class="headerlink" title="需求规格说明的特点："></a>需求规格说明的特点：</h2><h3 id="1）完整性-1"><a href="#1）完整性-1" class="headerlink" title="1）完整性"></a>1）完整性</h3><p>不能遗漏任何需求或必要的信息。</p><p>需求遗漏问题很难被发现，因为它们并没有列出来，着重于用户任务而不是系统功能会有助于避免遗漏需求。</p><h3 id="2）一致性-1"><a href="#2）一致性-1" class="headerlink" title="2）一致性"></a>2）一致性</h3><p>需求的一致性是指需求不会与同一类型的其他需求或更高层次的业务、系统或用户需求发生冲突。</p><p>必须在开发前解决需求不一致的问题。只有经过调查才能知道需求正确与否。</p><h3 id="3）可修改性-1"><a href="#3）可修改性-1" class="headerlink" title="3）可修改性"></a>3）可修改性</h3><p>必须能够对SRS作必要的修订，并可以为每项需求维护修改的历史记录。</p><p>这要求对每项需求进行唯一标识，与其他需求分开表述，从而能够明确地提及它。</p><p>每项需求只能在SRS中出现一次。</p><p>如果有重复的需求，很容易因为只修改其中一项而产生不一致。</p><h3 id="4）可跟踪性-1"><a href="#4）可跟踪性-1" class="headerlink" title="4）可跟踪性"></a>4）可跟踪性</h3><p>需求如果是可跟踪的，就能找到它的来源、它对应的设计单元、实现它的源代码以及用于验证其是否被正确实现的测试用例。</p><p>可跟踪的需求都有一个固定的标识符对其唯一标识。</p><h2 id="需求与其他软件项目过程的关系-1"><a href="#需求与其他软件项目过程的关系-1" class="headerlink" title="需求与其他软件项目过程的关系"></a>需求与其他软件项目过程的关系</h2><p>软件需求阶段在系统开发的整个生命周期中处于最基础、最重要的位置。</p><p>只有在需求分析工作做得比较扎实到位，文档经过开发方与用户方的充分参与、查验、修改、完善，才能为设计实施迈出坚实的一步。</p><p>软件需求活动用于软件项目的初始阶段，它的结果接着用于开发的下一个阶段，即设计阶段。</p><p>随着更强调迭代的方法学的出现，需求活动的使用被扩展到每一个开发迭代过程中，而且需求分析和设计的界限也变得模糊。</p><p>软件需求阶段是以真实世界建模为对象，并找出系统要处理什么的过程。</p><p>此阶段需要把一组复杂的需求分解为基本元素和关系，之后的解决方案建立在这些元素和关系的基础之上。</p><p>此阶段的结果是生成软件需求规格说明。</p><p>根据项目的大小不同，需求规格说明的详细程度各异，但是即使是最小的项目，也应该有某种成文的需求规格说明供开发团队使用。</p><p>需求过程中最为困难工作是编写详细技术需求，这包括所有面向用户、面向机器和其他软件系统的接口等。</p><p>这个过程一旦做错，将最终给系统带来极大损害，并且以后再对它进行修改也极为困难。</p><p><img src="/.imgs%E5%9B%BE%E7%89%871.png" alt="img"></p><h2 id="需求与各过程间的关系-1"><a href="#需求与各过程间的关系-1" class="headerlink" title="需求与各过程间的关系"></a>需求与各过程间的关系</h2><h3 id="（1）需求与制订项目计划关系-1"><a href="#（1）需求与制订项目计划关系-1" class="headerlink" title="（1）需求与制订项目计划关系"></a>（1）需求与制订项目计划关系</h3><p>需求是制订项目计划的<strong>基础</strong>，开发资源和进度安排的预估都要建立在对最终产品的真正理解之上。</p><p>项目计划所指出的所有希望特性不可能在允许的资源和时间内完成，因此，需要缩小项目范围或采用版本计划对功能特性进行选择。</p><h3 id="（2）需求与项目跟踪和控制关系-1"><a href="#（2）需求与项目跟踪和控制关系-1" class="headerlink" title="（2）需求与项目跟踪和控制关系"></a>（2）需求与项目跟踪和控制关系</h3><p>在项目实施过程中，<strong>要监控每项需求的状态</strong>，以便项目管理者能发现设计和验证是否达到预期的要求。</p><p>如果没有达到，管理者通常请求变更控制过程来进行范围的缩减。</p><h3 id="（3）需求与变更控制关系-1"><a href="#（3）需求与变更控制关系-1" class="headerlink" title="（3）需求与变更控制关系"></a>（3）需求与变更控制关系</h3><p>在需求编写成文档并制订基线以后，所有后续的变更都应通过确定的变更控制过程来进行。</p><h3 id="（4）需求与系统测试关系-1"><a href="#（4）需求与系统测试关系-1" class="headerlink" title="（4）需求与系统测试关系"></a>（4）需求与系统测试关系</h3><p>用户需求和功能需求是系统测试的重要参考。</p><p>如果未清楚说明产品在多种多样条件下的期望行为，系统测试者将很难确定正确的测试内容。</p><p>系统测试是一种方法，可以验证计划中所列的功能是否按预期要求实现了。</p><p>测试也验证了用户任务是否能正确执行。</p><h3 id="5）需求与用户编制文档关系-1"><a href="#5）需求与用户编制文档关系-1" class="headerlink" title="5）需求与用户编制文档关系"></a>5）需求与用户编制文档关系</h3><p><strong>软件需求是编写文档的重要参考</strong>，低质量和拖延的需求会给编写用户文档带来极大的困难，需求文档是所有设计、实现工作的基础。</p><h3 id="（6）需求与构造过程关系-1"><a href="#（6）需求与构造过程关系-1" class="headerlink" title="（6）需求与构造过程关系"></a>（6）需求与构造过程关系</h3><p>构成软件项目的主要产品是交付可执行软件，而不是需求说明文档。</p><p>要根据功能需求来确定设计模块，而模块又要作为编写代码的依据。</p><p>采用设计评审的方法来确保设计正确地反映了所有的需求。而代码的单元测试能确定是否满足了设计规格说明和相关的需求。</p><p><strong>本章小结</strong></p><p>（1）软件需求的定义：给出了几种主要的软件需求定义和软件需求定义的一些基本原则。</p><p>（2）需求的层次：需求包括三个不同的层次，它们是：业务需求、用户需求和软件需求</p><p>（3）软件需求的分类：软件需求可以分为：功能需求、非功能需求和设计约束三种类型。</p><p>（4）高质量软件需求的好处及好的软件需求具有的特点。</p><p>（5）需求与其他软件项目过程的关系。</p><h1 id="第2章-用户眼中的软件需求-1"><a href="#第2章-用户眼中的软件需求-1" class="headerlink" title="第2章 用户眼中的软件需求"></a>第2章 用户眼中的软件需求</h1><p>软件需求来源于用户，用户是能够直接或间接从软件产品中获益的个人或组织。</p><p>软件用户可能提出需求、出钱、选择、说明、使用或者接收软件产品的输出。</p><h2 id="用户”是一种泛称，它可细分为：-1"><a href="#用户”是一种泛称，它可细分为：-1" class="headerlink" title="用户”是一种泛称，它可细分为："></a>用户”是一种泛称，它可细分为：</h2><ul><li>“客户”（customer） 掏钱买软件产品的用户称为客户；</li><li>“最终用户”（the end user）真正操作软件产品的用户叫最终用户。</li><li>“间接用户”（或称为关系人）。既不掏钱买该软件产品，也不使用该软件，但是它可能对软件产品有很大的影响。<ul><li>例如：财务软件，开发商在把“财务软件”卖给客户之前，必须得到国家财政部的批准。否则，即使该软件的功能是完美的，但却被政府认为是非法的。所以，国家财政部就是所有财务软件的间接用户。</li><li>又例如：市面上流通的信息安全软件、杀病毒软件必须得到国家公安部的批准，否则不能销售</li></ul></li></ul><p>优秀的软件产品建立在优秀的需求基础上，而高质量的需求来源于用户与开发者之间的有效沟通与合作。</p><p>协同合作要想取得成果，需要所有人员都清楚自己的需要，理解并尊重其他合作者的需求。</p><p>通常用户与开发者要建立合作伙伴关系。</p><h2 id="十项软件客户权利清单-1"><a href="#十项软件客户权利清单-1" class="headerlink" title="十项软件客户权利清单"></a>十项软件客户权利清单</h2><ol><li>要求需求分析员使用客户的语言进行交流</li><li>要求需求分析员了解客户的业务和目标</li><li>要求需求分析员用适合的形式记录需求</li><li>要求需求分析员解释需求过程生成的所有工作结果</li><li>要求需求分析员和开发人员尊重客户，并以合作和专业的态度与客户进行互动。</li><li>要求需求分析员和开发人员为需求和产品实现提供思路和备用方案</li><li>要求开发人员实现能让产品使用起来更容易、更有趣的特性</li><li>调整需求，便于重用已有的软件组件</li><li>在提出需求变更时，获得对变更的成本、影响及二者权衡关系的真实评估</li><li>获得满足功能和质量要求的系统，这些要求必须事先告知开发人员并征得其同意</li></ol><h2 id="十项客户的需求义务清单-1"><a href="#十项客户的需求义务清单-1" class="headerlink" title="十项客户的需求义务清单"></a>十项客户的需求义务清单</h2><ol><li>为需求分析员和开发人员讲解业务并定义业务术语</li><li>提供需求，阐明需求，通过与开发人员的交互将需求充实完善</li><li>对系统需求的描述必须详细、准确</li><li>需要时，及时对需求做出决定</li><li>尊重开发人员对需求成本和可行性的评估</li><li>与开发人员协作，为功能需求、系统特性和用例设置优先级</li><li>审阅需求文档，评估原型</li><li>发现需要变更需求时，及时与开发人员沟通</li><li>按照开发组织的变更控制过程提出需求变更</li><li>尊重需求分析员在需求工程中使用的过程</li></ol><h2 id="对需求达成一致-1"><a href="#对需求达成一致-1" class="headerlink" title="对需求达成一致"></a>对需求达成一致</h2><p>对在建产品的需求达成一致或是在某部分达成一致是客户和开发人员关系的核心。</p><p>涉及的多个角色应形成如下共识：</p><ul><li>客户承认需求描述了他们的需要。</li><li>开发人员承认理解需求，并且认为它们是可实现的。</li><li>测试人员承认需求是可验证的。</li><li>管理层承认需求可以达成他们的业务目标。</li></ul><h1 id="第3章-需求工程-1"><a href="#第3章-需求工程-1" class="headerlink" title="第3章  需求工程"></a><strong>第3章  需求工程</strong></h1><p>需求工程分为：需求开发和需求管理两部分。</p><p>需求分析是需求开发的其中一个环节，确立了需求工程与软件工程是同等重要的观念。</p><p>需求工程：是确保软件需求质量的。</p><p>软件工程：是确保软件开发质量的。</p><p>一个软件项目要想成功，必须握有需求工程和软件工程这两把利剑在手。</p><p>需求工程：是随着计算机的发展而发展的。</p><p>在计算机发展的初期，软件规模不大，软件开发所关注的是代码编写，软件需求很少受到重视。</p><p>随着软件系统规模的扩大，软件需求分析与定义在整个软件开发与维护过程中越来越重要，直接关系到软件的成功与否。</p><p>人们逐渐认识到软件需求活动不再仅限于软件开发的最初阶段，它贯穿于系统开发的整个生命周期。</p><p>需求工程：是用已证实有效的技术和方法进行需求分析、确定客户需求、帮助分析人员理解问题，并定义目标系统的所有外部特征的一门学科。</p><p>需求工程：通过合适工具和记号，描述待开发系统及其行为特征和相关约束，形成需求文档，并对用户不断变化的需求演进给予支持。</p><p>需求工程：可分为：系统需求工程和软件需求工程。</p><p>系统需求工程，将软件需求开发和系统需求开发结合起来，在系统工程的开始阶段起到重要的作用。</p><p>软件需求工程，是一门分析并记录软件需求的学科，它把系统需求分解成一些主要的子系统和任务，把这些子系统或任务分配给软件，并通过一系列重复的分析、设计、比较研究、原型开发，把这些系统需求转换成软件的需求描述和性能参数。</p><p>需求工程定义：</p><p>Davis的定义：“直到(但不包括）把软件分解为实际架构组建之前的所有活动”，即软件设计之前的一切活动。</p><p>Brays的定义：认为需求工程是“对问题域及需求做调查研究和描述，设计满足系统的特性，并用文档给予说明。这个定义明确指出了需求工程的任务就是获取、分析和表达软件的需求”</p><p>HerbKrasner（赫克拉斯纳）定义了五阶段生命周期：</p><ol><li>需求定义和分析</li><li>需求决策</li><li>形成需求规格</li><li>需求实现与验证</li><li>需求演进管理</li></ol><p>需求工程：主要是抽取需求、模拟和分析需求、传递需求、认可需求和进化需求。</p><p>需求工程的定义：主要是抽取需求、模拟和分析需求、传递需求、认可需求和进化需求。每个活动都有它基本的动机、任务和结果，也有各自的困难所在。</p><p>需求工程的组成：需求开发和需求管理两部分。</p><p>Ø需求开发包括：需求获取、需求分析、形成需求规格、需求确认。</p><p>Ø需求管理包括：需求变更控制、版本控制、需求跟踪、需求状态跟踪。</p><p>初始循环</p><p>脉络循环</p><p>细节循环</p><h1 id="第四章-需求获取-1"><a href="#第四章-需求获取-1" class="headerlink" title="第四章 需求获取"></a>第四章 需求获取</h1><p>需求获取阶段的任务：就是获取用户的需求信息。</p><p>需求获取：是软件需求的早期活动，也是十分重要的一步。</p><p>由于需求获取是软件开发中最困难、最关键、最易出错和最需要交流的活动，故其只能通过用户与需求分析员之间进行高度的合作和交流才能成功。</p><h2 id="需求获取阶段的活动可分为：-1"><a href="#需求获取阶段的活动可分为：-1" class="headerlink" title="需求获取阶段的活动可分为："></a>需求获取阶段的活动可分为：</h2><ol><li>确定需求开发计划</li><li>确定项目的目标和范围</li><li>确定调研对象</li><li>需求信息收集</li></ol><p>需求开发计划的任务：是确定需求开发的实施步骤，给出收集需求活动的具体安排和进度。</p><p>软件需求：是分析、理解和描述用户的需求，着重于软件系统“做什么”，而不是如何实现软件系统。</p><p>为了保证软件需求有充分的时间和经费，在安排软件需求的实施步骤、收集需求活动的进度时，只能考虑与需求开发相关的工作。</p><p>否则，将会导致软件需求花费的时间过长、成本过高，不利于有效地进行软件需求的活动。</p><p>在安排进度时，应考虑困难性和灵活性。</p><p>例如：在收集用户需求的活动中，由于用户可能出差或开会，不一定能保证在规定的时间内进行交流，因此，需要与用户预约时间，及时调整时间和计划。</p><p>此外，书写和整理需求规格说明也是需花费时间的，故在安排进度和时间时应予以考虑。</p><p>项目目标和范围的基本任务是：</p><p>—— 根据项目目标把项目相关人员定位到一个共同的和明确的方向上，并决定软件系统的范围。</p><p>项目的目标主要包括：</p><p>—— 项目开发的目的和意义，以及软件系统应实现的业务需求。</p><p>项目的范围：</p><p>—— 是指软件系统具体应包括和不应包括的部分，以及软件系统所涉及的各个方面。</p><p>如：计算机硬件和其他软件系统等，即软件系统在一个完善的环境中最终具有的功能。</p><p>项目的业务需求代表了需求层次中最高层的需求，为软件系统定义了作用的范围。</p><h2 id="需求信息的类型-1"><a href="#需求信息的类型-1" class="headerlink" title="需求信息的类型"></a>需求信息的类型</h2><ol><li>业务需求<ol><li>描述用户或开发机构，通过产品可获得的利益和利润。</li><li>以及与产品相关的发展规划等方面的信息。</li></ol></li><li>用例说明</li><li>业务规则。有关业务过程的操作原则。</li><li>功能需求。定义了系统应该做什么，它们是软件需求规格说明的一部分。</li><li>性能需求</li><li>外部接口需求</li><li>约束<ol><li>约束：是指一些合理限制设计者和程序员选择的条件。</li><li>约束：必须写入软件需求规格说明。</li><li>施加不必要的约束，将妨碍提出一个好的解决方案，将会降低利用现有商业化软件集成解决方案的能力，</li><li>一定的约束有助于提高产品质量。</li></ol></li><li>数据定义<ol><li>当客户描述一个数据项，或一个复杂的业务数据结构的格式、允许值或默认值时，就是在进行数据定义。</li><li>把这些集中在一个数据词典中，作为项目参与者在整个项目的开发和维护中的主要参考文档。</li></ol></li><li>解决方案<ol><li>如果一个客户描述了用户与系统交互的特定方法，使系统产生一系列活动，这时，就是在听取建议性的解决方案，而不是需求。</li></ol></li></ol><h2 id="需求收集中应注意的问题-1"><a href="#需求收集中应注意的问题-1" class="headerlink" title="需求收集中应注意的问题"></a>需求收集中应注意的问题</h2><ol><li>应能适当地调整收集范围<ul><li>在收集需求的开始，需求分析员并不知道用户需求量的大小，可以根据系统的范围适当扩大收集范围。</li><li>收集的范围不能过于扩大，因为范围扩大，收集的需求有些可能不是真正的需求，将导致分析员要花费大量的精力和时间，来理解和分析这些需求。</li><li>收集的范围也不能太小，否则有些重要需求会被遗漏或排除在外。</li></ul></li><li>弄清楚用户所做的假设和冲突。<ul><li>尽量把用户所做的假设解释清楚，特别是发生冲突的部分。这就需要根据用户的信息去理解。</li><li>以明确用户没有表达清楚的需求。</li></ul></li><li>理解用户的思维过程、专业知识和术语。<ul><li>尽量理解用户的思维过程，特别是尽量熟悉和掌握用户具有的一些专业知识和术语。</li></ul></li><li>避免受不熟悉细节的影响。</li><li>避免讨论一些具体的解决方案。</li><li>需求收集工作的结束。<ul><li>如何决定收集工作的结束，并没有一个简单和严格的标准，需根据实际情况进行判断。</li><li>eg<ul><li>用户不可能再提供更多新的需求信息。</li><li>用户重复提出以前已提出的需求信息。</li><li>与用户的讨论开始进入设计方面的工作。</li><li>需求分析员本身已提不出更多的问题。</li><li>安排收集工作的结束时间已到。</li></ul></li></ul></li><li>非功能需求的确定<ul><li>非功能需求：是衡量软件能否良好运行的定性指标。</li><li>非功能需求：也是非常重要的。</li><li>可靠性、可扩展性、安全性、互操作性、易使用性、可维护性、用户界面友好等。</li><li>必须根据用户对系统的期望来确定非功能需求。</li></ul></li><li>收集非功能需求的一些方法：<ol><li>将不同用户类代表，提出的可能很重要的非功能需求进行综合，并根据其中的每个需求设计出许多方法，然后，根据用户的回答，使这些需求更明确。</li><li>需求分析员与用户一起对每一个非功能需求，制定可测试和可验证的具体标准。如果这些需求缺乏评价标准，就无法说明开发出的软件系统是否已满足这些需求。</li><li>设计与非功能需求相冲突的假设示例，利用反例来提示用户。</li></ol></li></ol><h2 id="需求获取方法-1"><a href="#需求获取方法-1" class="headerlink" title="需求获取方法"></a>需求获取方法</h2><ol><li>面向目标的方法<ul><li>目标是用户所期望达到的目的。</li><li>层次性是目标的一个重要特征。</li><li>从高层来说，目标是抽象的问题描述。</li><li>从底层来说，则是具体的实现方式，即技术需求描述。</li><li>这有利于需求的逐步精化，通过需求对高层目标的可追溯性，建立起软件需求与业务目标的关系。</li><li>因此，面向目标方法不仅被用来进行需求获取、分析，还被应用于需求协商等领域。</li></ul></li><li>面向目标的方法的优点有：<ol><li>容易理解和交流，可以保证需求的完整性、避免无关的需求。</li><li>目标本身所具有的层次关系，使得需求文档更加结构化，增强了可读性。</li><li>有助于将软件需求与业务环境联系起来，有助于解决多视点之间的冲突。</li><li>由于目标方法可以将稳定的需求和经常变化需求区分开，有利于需求的管理。</li></ol></li><li>基于场景的方法<ul><li>基于场景的方法：是通过应用环境的某一特定情景的描述，来阐述用户的需求。</li><li>由于这一方法非常便于涉众之间的交流，并且提供了一种将需求与实际经验相结合的机制，因此，对于需求的获取和确认有很大的帮助。</li><li>基于场景的方法：目前应用最广泛的一种就是基于用例的方法。<ul><li>用例是从用户的观点、以交互的方式，对于系统的行为特征进行的描述，而场景一般认为是用例的一个实例。</li></ul></li></ul></li><li>面向视点的方法<ul><li>视点是对于涉众局部观察角度的一种抽象。</li><li>在多视点需求工程中，需求分析人员从一组涉众处获取各局部需求，并将其进行整合。</li><li>多视点需求工程方法认为，需求之间的冲突往往是由于涉众视点不同所导致的。</li><li>因此，完整、一致地发现和集成视点，是获得高质量需求的关键。</li><li>多视点方法适应于涉众视角的局部性和分布性特征，反映各种涉众的需求。</li></ul></li><li>基于知识的方法<ul><li>软件开发是一个知识密集型的活动，知识在其中起到关键的作用。</li><li>基于知识的方法的出发点，是希望利用历史项目中，积累的经验或领域分析的结果，来帮助人们理解和获取需求。</li><li>事实上，大多数的需求获取方法，都或多或少地用到这一类方法。</li></ul></li><li>面向方面的方法<ul><li>面向方面的软件开发：是使横切关注点更好地分离的一种技术。</li><li>在面向方面的编程中，对于“横切”给出这样的定义：如果被构建的两个属性，必须以不同的方式构造，但它们之间又需要被协同，那么它们彼此横切。</li><li>把问题分解为更小的部分，称为关注点分离。</li><li>通过对关注点的分离，有助于从不同角度对软件系统进行理解、维护和扩展。</li><li>面向方面的方法：在近年来被提出，并受到了研究者的重视。</li><li>通常将功能需求作为一组基础，而将非功能需求作为方面级的需求。</li><li>面向方面的方法：从编程方法发展而来，它的基本思想和多视角的方法有相似之处，目前，较为成功的应用主要集中在需求的实现。</li><li>由于需求之间的关系往往错综复杂，因此，对横切需求的识别仍然是一个难题。</li></ul></li></ol><h2 id="Summary-8"><a href="#Summary-8" class="headerlink" title="Summary"></a>Summary</h2><h3 id="需求获取阶段的任务：-1"><a href="#需求获取阶段的任务：-1" class="headerlink" title="需求获取阶段的任务："></a>需求获取阶段的任务：</h3><p>—— 就是获取用户的需求信息。通过用户与需求分析员之间进行高度的合作和交流才能成功。</p><h3 id="需求开发计划：-1"><a href="#需求开发计划：-1" class="headerlink" title="需求开发计划："></a>需求开发计划：</h3><p>—— 需求开发计划的任务：是确定需求开发的实施步骤，给出收集需求活动的具体安排和进度。</p><h3 id="项目的目标和范围-1"><a href="#项目的目标和范围-1" class="headerlink" title="项目的目标和范围"></a>项目的目标和范围</h3><p>—— 项目的目标主要包括： 项目开发的目的和意义，以及软件系统应实现的业务需求。</p><p>—— 项目的范围： 是指软件系统具体应包括和不应包括的部分，以及软件系统所涉及的各个方面。</p><h3 id="需求调研对象：主要是：用户-1"><a href="#需求调研对象：主要是：用户-1" class="headerlink" title="需求调研对象：主要是：用户"></a>需求调研对象：主要是：用户</h3><p>根据用户的某些方面将用户分类：</p><p>根据用户所在的部门和职责分类。</p><p>   —— 如：计划部门、销售部门、财务部门等。</p><p>根据用户使用系统的频繁度和优先级等分类。</p><p>根据用户掌握的计算机知识和使用计算机的熟练程度分类。</p><p>根据直接使用和非直接使用软件系统的情况分类。</p><h3 id="确定需求来源-1"><a href="#确定需求来源-1" class="headerlink" title="确定需求来源"></a>确定需求来源</h3><p>典型的软件需求来源有以下几方面：</p><p>1）直接和间接使用软件系统的用户。</p><p>2）系统需求规格说明。</p><p>3）市场调研和用户问卷调查。</p><p>4）已开发出的和待开发的同类软件系统的描述和文档。</p><p>5）人工系统中存在的问题报告。</p><p>6）观察正在工作的用户。</p><p>7）用户工作内容的分析。</p><h3 id="需求调研的三个步骤：-1"><a href="#需求调研的三个步骤：-1" class="headerlink" title="需求调研的三个步骤："></a>需求调研的三个步骤：</h3><p>1）向掌握“全局”的负责人调研</p><p>2）向部门负责人调研</p><p>3）向业务人员调研</p><h3 id="明确需求信息的决策者-1"><a href="#明确需求信息的决策者-1" class="headerlink" title="明确需求信息的决策者"></a>明确需求信息的决策者</h3><p>决策者能根据具体情况，对存在问题需求信息做出决定。</p><p>决策者并不是固定不变的，而是根据实际中可能发生的具体问题来确定。</p><h3 id="需求信息收集面临的困难-1"><a href="#需求信息收集面临的困难-1" class="headerlink" title="需求信息收集面临的困难"></a>需求信息收集面临的困难</h3><p>需求信息收集并不是件容易的工作，需求分析员要与用户进行充分的交流，听取用户对软件系统的看法和意见。</p><p>但在与用户交流的过程中并非是十分顺利的，特别是需要用户花费时间来讲解他们的业务流程和工作内容。</p><h3 id="需求信息收集的方式。-1"><a href="#需求信息收集的方式。-1" class="headerlink" title="需求信息收集的方式。"></a>需求信息收集的方式。</h3><p>1）座谈会的方式</p><p>2）书面咨询的方式</p><p>3）利用用例表示方法</p><h3 id="需求信息的类型有9种。-1"><a href="#需求信息的类型有9种。-1" class="headerlink" title="需求信息的类型有9种。"></a>需求信息的类型有9种。</h3><p>1.业务需求</p><p>2.用例说明</p><p>3.业务规则</p><p>4.功能需求</p><p>5.性能需求</p><p>6.外部接口需求</p><p>7.约束</p><p>8.数据定义</p><p>9.解决方案</p><h3 id="需求收集中应注意的一些问题：-1"><a href="#需求收集中应注意的一些问题：-1" class="headerlink" title="需求收集中应注意的一些问题："></a>需求收集中应注意的一些问题：</h3><p>1）应能适当地调整收集范围。</p><p>2）尽量把用户所做的假设解释清楚，特别是发生冲突的部分。这就需要根据用户的信息去理解，以明确用户没有表达清楚的需求。</p><p>3）尽量理解用户的思维过程，特别是尽量熟悉和掌握用户具有的一些专业知识和术语。</p><p>4）在收集需求信息时，应尽量避免受不熟悉细节的影响。</p><p>5）应尽量避免讨论一些具体的解决方案，因为需求阶段的工作，是要弄清楚软件系统做什么，而不是怎么做。</p><p>6）需求收集工作的结束。</p><h3 id="非功能需求：-3"><a href="#非功能需求：-3" class="headerlink" title="非功能需求："></a>非功能需求：</h3><p>非功能需求：是衡量软件能否良好运行的定性指标。</p><p>如：可靠性、可扩展性、安全性、互操作性、易使用性、可维护性、用户界面友好等。</p><h3 id="收集非功能需求使用的3种方法：-1"><a href="#收集非功能需求使用的3种方法：-1" class="headerlink" title="收集非功能需求使用的3种方法："></a>收集非功能需求使用的3种方法：</h3><p>将重要非功能需求进行综合，并根据其中的每个需求设计出许多方法，根据用户的回答，使这些需求更明确。</p><p>方法2：需求分析员与用户一起对每一个非功能需求，制定可测试和可验证的具体标准。</p><p>方法3：设计与非功能需求相冲突的假设示例，利用反例来提示用户。</p><h3 id="需求获取方法：有5种-1"><a href="#需求获取方法：有5种-1" class="headerlink" title="需求获取方法：有5种"></a>需求获取方法：有5种</h3><ol><li>面向目标的方法</li><li>基于场景的方法</li><li>面向视点的方法</li><li>基于知识的方法</li><li>面向方面的方法</li></ol><h1 id="第5章-需求分析-1"><a href="#第5章-需求分析-1" class="headerlink" title="第5章 需求分析"></a>第5章 需求分析</h1><h2 id="需求分析的任务-1"><a href="#需求分析的任务-1" class="headerlink" title="需求分析的任务"></a>需求分析的任务</h2><p>通过需求获取阶段的工作，软件开发人员从用户处收集到大量的需求信息。</p><p>这些需求信息并不完全都是真正的需求。</p><p>需求分析的<strong>基本任务</strong>：就是<strong>分析和综合</strong>已收集到的需求信息。</p><p><em>分析</em>：在于透过现象看本质，找出这些需求信息间的内在联系和可能的矛盾。</p><p><em>综合</em>：就是去掉那些非本质的信息，找出解决矛盾的方法，并建立系统的逻辑模型。</p><p><strong>具体地说</strong>，需求分析的基本任务：就是<strong>提炼、分析和仔细审查已收集到的需求信息</strong>，找出真正的和具体的需求，以确保所有项目相关人员都明白其含义。</p><p>在分析过程中，通过建立软件系统的逻辑模型，发现或找出需求信息中存在的冲突、遗漏、错误或含糊问题等。</p><p>需求分析阶段工作结果：是获得高质量的具体软件需求。</p><p>需求分析的<strong>具体工作包括</strong>：</p><ul><li>建立系统关联图；</li><li>分析需求的可行性；</li><li>构建用户分析原型；</li><li>确定需求的优先级；</li><li>需求建模；</li><li>建立数据词典。</li><li>对于较为简单的系统，确定需求优先级等工作可以考虑不施行。</li></ul><h2 id="系统关联图的建立-1"><a href="#系统关联图的建立-1" class="headerlink" title="系统关联图的建立"></a>系统关联图的建立</h2><p>在需求获取阶段，首先确定收集需求信息的范围，提高需求获取效率，把项目相关人员定位到一个共同的、明确的方向上。</p><p><strong>建立系统关联图：主要是根据需求获取阶段确定的系统范围，用图形表示系统与外部实体间的关联。</strong></p><p><em>关联图：就是用于描述系统与外部实体间的<strong>界限和接口</strong>的模型，而且明确通过接口的信息流和物质流</em></p><p>关联图的建立：</p><ul><li>把整个要开发的系统表示为一个椭圆，椭圆内标识系统的名字。</li><li>用箭头表示系统与外部实体间的关系和信息流向。</li><li>用矩形框表示系统外部实体。</li></ul><p>关联图：不明确描述系统的内部过程和数据。</p><p>EG</p><p>某培训中心的主要工作是为本行业在职人员提供课程培训服务。有兴趣的本行业职工可以通过电子邮件、信函等报名、选修或注销课程，或询问课程计划等。培训中心收取一定的培训费用，学费可以用现金或支票形式支付。</p><p>该系统应具有记录和分类由电子邮件或信函表达的信息，处理报名、询问、注销和付款，以及输出回答信息的功能。</p><p>该系统外的实体主要是学员和系统的操作员等。</p><p>系统的关联图，如图所示。</p><p><img src="/.imgs2.png"></p><p>建立关联图的目的：是项目相关人员一开始不必去考虑太多的细节，而是把注意力集中在软件系统的接口方面。</p><ul><li>即系统的输入&#x2F;输出上，从而确定系统的界限，并为分折用户需求提供很好的依据，特别是在功能需求方面。</li></ul><p>关联图：以图形方式表示系统的范围，使得项目相关人员更易于理解和审查。</p><p>如果某些需求不可实施，例如：开发环境的支持，或技术实现有困难，或处理效率较低等，都应尽早与用户讨论和协商。</p><p>分析需求可行性的基本任务：是在允许的成本和性能要求以及系统的范围内，分析每项需求得以实施的可能性。</p><p>分析需求可行性的目的：在于明确与每项需求相关联的风险，包括：一些与其它方面的冲突、对外部环境的依赖和某些技术的障碍等。</p><p>分析需求可行性：是一项困难的工作，不存在对所有类型的需求都适用的分析方法。</p><p>分析需求可行性：需要与有经验的开发人员共同分析。</p><p>对于要开发的软件系统，由于涉及不可知因素，进行需求可行性分析，有助于避免后期开发过程中的一些问题。</p><p>与高风险相关的需求，最有可能导致软件开发工作的失败。</p><h2 id="考虑的风险类型-1"><a href="#考虑的风险类型-1" class="headerlink" title="考虑的风险类型"></a>考虑的风险类型</h2><ol><li>性能风险：实现这项需求，可能导致整个系统性能的下降。</li><li>安全风险：实现这项需求，可能导致无法满足整个系统的安全需求。</li><li>过程风险：实现这项需求，可能导致需要对常规的开发过程做修改。</li><li>实现技术风险：实现这项需求，可能需要使用不熟悉的实现技术。</li><li>数据库风险：实现这项需求，可能导致系统不支持的非标准数据。</li><li>日程风险：实现这项需求，可能遇到技术困难，并危及系统原定的开发日程。</li><li>外部接口风险：实现这项需求，可能涉及外部接口。</li><li>稳定风险：这项需求可能是易变的，将导致开发过程的重大变动。</li></ol><p>在实际工作中，通常使用定性的方法。</p><p>如：分类为：</p><ul><li>“高”</li><li>“中”</li><li>“低”</li></ul><h2 id="建立用户分析原型-1"><a href="#建立用户分析原型-1" class="headerlink" title="建立用户分析原型"></a>建立用户分析原型</h2><p>在需求建模前，需要澄清一些不能确定的或含糊的需求，尽早使这些需求能完整和清楚地表达出来。</p><p>创建用户分析原型的基本任务：是对于软件开发人员或用户不能明确化的需求，通过建立相应的用户分析原型，然后，评估该原型，使得项目相关人员能更好理解所要解决的问题。</p><p>用户分析原型：是指一个可能的局部实现，而不是整个系统，这样可使许多概念和可能发生的事更为直观明了。</p><h2 id="需求优先级分析-1"><a href="#需求优先级分析-1" class="headerlink" title="需求优先级分析"></a>需求优先级分析</h2><p>划分需求优先级可以帮助项目相关人员判断系统的核心需求，并有助于项目相关人员集中于重点问题的交流和协商，特别是涉及需求风险分析的时候。</p><p>需求优先级之间的关联，可以帮助软件开发人员决定软件体系结构，还可以帮助解决可能发生的设计冲突。</p><p>软件开发人员可以根据需求优先级，权衡合理的项目范围和进度安排、预算、人力资源以及质量目标的要求。</p><p>实现权衡的方法是，当接受一个新的高优先级的需求或者项目发生环境变化时，删除低优先级的需求，或者将其推迟到下一版本去实现。</p><p>在需求获取的理想情况下，开发人员应在客户表达需求时，由用户决定需求的重要性，标上需求的优先级。</p><p>如果单独让用户来决定需求的优先级是很难做到的，在众多具有不同期望的用户之间，达到一致意见就更难了。</p><p>优先级的分配，应当由软件开发人员和项目相关人员共同完成，最好是在做了一些初始的分析工作后，再进行需求优先级的分配。</p><p>在很多情况下，对同一需求，不同的项目相关人员会分配不同的优先级。</p><p>这可能反映了实际的需要，也可能只是简单地反映了不同项目相关人员各自的理解。</p><p>因此，必须消除这些差异，并在分配的每一类优先级的含义上达成一致意见。</p><h2 id="需求建模-1"><a href="#需求建模-1" class="headerlink" title="需求建模"></a>需求建模</h2><p>需求建模：就是导出目标系统的逻辑模型或需求模型，以明确目标系统“做什么”的问题。</p><p>目标系统：是指待开发的软件系统。</p><p>在已知需求的可行性以及各个需求明确以后，为了更好地理解需求，特别是复杂系统的需求，软件开发人员应从不同的角度，抽象出目标系统的特性，</p><p>使用精确的方法构造系统的模型，验证模型是否满足用户的需求，并在设计过程中，逐渐把与实现相关的细节加进模型，直至最终用程序实现模型。</p><p>模型，就是为了理解事物而对事物作出的一种抽象，是对事物的一种无歧义的书面描述。</p><p>模型：可由文本、图形符号或数学符号以及组织这些符号的规则组成。</p><p>需求建模，就是把由文本表示的需求和由图形或数学符号表示的需求结合起来，绘制出对目标系统的完整性描述，以检测软件需求的一致性、完整性和错误等。</p><p>利用图形表示需求，有助于增强项目相关人员对需求的理解，对于某些类型的信息。</p><p>图形表示方式可以使项目相关人员之间减轻语言和词汇方面的负担。</p><p>建立需求模型的目的：是为了增强对用自然语言描述的需求规格说明的理解，而不是替换它。</p><p>在需求建模中，使用什么方法取决于建模的目的、时间和应用领域等。</p><h3 id="常见的需求分析方法有-1"><a href="#常见的需求分析方法有-1" class="headerlink" title="常见的需求分析方法有"></a>常见的需求分析方法有</h3><ol><li>结构化分析方法（Structured Analysis, SA）</li><li>面向对象方法</li><li>面向问题域的分析方法</li><li>面向特征的需求分析方法</li><li>基于本体的需求分析方法</li><li>面向多视点的需求分析方法</li></ol><h2 id="数据词典-1"><a href="#数据词典-1" class="headerlink" title="数据词典"></a>数据词典</h2><h3 id="定义：-3"><a href="#定义：-3" class="headerlink" title="定义："></a>定义：</h3><p>目标系统中使用的所有数据元素和结构的含义、类型、数量值、精度及允许取值范围的共享数据仓库。</p><h3 id="作用：-1"><a href="#作用：-1" class="headerlink" title="作用："></a>作用：</h3><p>是确保软件开发人员使用统一的数据定义，可提高需求分析、设计、实现和维护过程中的可跟踪性。</p><p>为避免冗余和不一致性，每个项目建立一个独立的数据词典，而不是在每个需求出现的地方定义每个数据项。</p><p>数据词典：把不同的需求文档和需求模型紧密地结合到一起。</p><p>数据词典中的每个数据项对应一项记录，并根据实际情况使用简单的符合予以定义</p><h2 id="Summary-9"><a href="#Summary-9" class="headerlink" title="Summary:"></a>Summary:</h2><p>1）需求分析的任务：</p><p>就是分析和综合已收集到的需求信息。</p><p>分析：在于透过现象看本质，找出这些需求信息间的内在联系和可能的矛盾。</p><p>综合：就是去掉那些非本质的信息，找出解决矛盾的方法，并建立系统的逻辑模型。</p><p>（2）关联图：</p><p>就是用于描述系统与外部实体间的界限和接口的模型，而且明确通过接口的信息流和物质流。</p><p>（1）分析需求可行性的基本任务：</p><p>是在允许的成本和性能要求以及系统的范围内，分析每项需求得以实施的可能性。</p><p>（2）这项工作的目的：</p><p>在于明确与每项需求相关联的风险，包括：一些与其它方面的冲突、对外部环境的依赖和某些技术的障碍等。</p><p>（3）在需求分析中应考虑的风险类型：</p><p>性能风险、安全风险、过程风险、实现技术风险、</p><p>数据库风险、日程风险、外部接口风险、稳定风险</p><p>（1）用户分析原型：</p><p>用户分析原型：是指一个可能的局部实现，而不是整个系统，这样可使许多概念和可能发生的事更为直观明了。</p><p>（2）划分需求优先级</p><p>可以帮助项目相关人员判断系统的核心需求，并有助于项目相关人员集中于重点问题的交流和协商。</p><p>（3）需求建模</p><p>就是导出目标系统的逻辑模型或需求模型，以明确目标系统“做什么”的问题。</p><p>（4）数据词典</p><p>是定义目标系统中使用的所有数据元素和结构的含义、类型、数量值、精度及允许取值范围的共享数据仓库。</p><h1 id="第6章-需求建模方法与技术-1"><a href="#第6章-需求建模方法与技术-1" class="headerlink" title="第6章  需求建模方法与技术"></a>第6章  需求建模方法与技术</h1><p>需求建模：是根据待开发软件系统的需求，利用某种建模方法建立该系统的逻辑模型。</p><p>也称为：需求模型或分析模型。</p><p>帮助软件开发人员检测软件需求的一致性、完全性、二义性和错误等。</p><p>在软件的实际开发中，为了表达和描述软件需求，软件开发人员使用不同的建模方法，来建立软件需求模型。</p><p>这些建模方法的作用、范围和特点不同，因此，在使用中是有所区别的。</p><h2 id="需求建模方法具备的共同特点：-1"><a href="#需求建模方法具备的共同特点：-1" class="headerlink" title="需求建模方法具备的共同特点："></a>需求建模方法具备的共同特点：</h2><p>1）提供描述手段</p><p>开发一个软件系统涉及许多人，开发人员之间如何有效地进行交流是项目成功的关键之一。</p><p>在开发过程中，每个开发人员都必须将工作的结果以一定的形式记录下来，采用什么样的描述形式，对人员间的交流和继续进行下一步工作是非常重要的。</p><p>需求建模方法应该规定描述模型的手段，这包括要记录什么内容以及用什么符号来表达等。</p><p>2）提供基本步骤</p><p>开发一个软件系统，特别是大型复杂系统，要考虑的问题很多，如果同时处理这些问题，就会束手无策或者造成混乱。</p><p>正确解决问题的方法是，将问题按先后次序进行分解，每一步集中精力解决某个问题，直至所有问题被解决为止。</p><p>因此，需求建模方法需要规定基本实施步骤，确定每一步的目的，要产生什么样的结果，每步中要注意哪些概念，以及完成该步的工作需要掌握哪些必要的信息等。</p><p>在需求建模方法中，主要使用的描述手段和技术是：自然语言、图形符号语言和形式语言等。</p><h2 id="常见的软件需求模型包括-1"><a href="#常见的软件需求模型包括-1" class="headerlink" title="常见的软件需求模型包括:"></a>常见的软件需求模型包括:</h2><p>数据流图（DFD）</p><p>实体关系图（ERD）</p><p>状态转换图（STD）</p><p>用例图</p><p>类图</p><p>活动图</p><p>时序图</p><p>事件-响应表</p><table><thead><tr><th>词语类型</th><th>示 例</th><th>分析模型的组件</th></tr></thead><tbody><tr><td>名词</td><td>人员、组织机构、软件系统、数据元素、已经存在的对象</td><td>·外部实体、数据库或者数据流（数据流图，DFD）  ·参与者（用例图）  ·实体或者实体属性（实体-关系图，ERD）  ·通道（时序图）  ·带状态的对象（状态转换，STD）</td></tr><tr><td>动词</td><td>行为、用户或者系统所做的事情、能够发生的事件</td><td>·处理（数据流图，DFD）  ·处理步骤（时序图）  ·用例（用例图）  ·关系（实体-关系图，ERD）  ·转换（状态转换图，STD）  ·活动（活动图）  ·事件（事件-响应表）</td></tr><tr><td>条件</td><td>条件逻辑的陈述，如if&#x2F;then</td><td>·判定条件（决策树、决策表或者活动图）  ·分支（时序图或者活动图）</td></tr></tbody></table><h3 id="数据流图-1"><a href="#数据流图-1" class="headerlink" title="数据流图"></a>数据流图</h3><p>（Data Flow Diagram ,简称：DFD）</p><p>数据流图：用于标识一个系统中的加工处理、系统所操作的数据集合或者物理介质以及在处理、存储和系统外部之间的数据流。</p><p>数据流图：指明系统中数据是如何流动和变换的，以及描述使数据流进行变换的功能。</p><p>数据流图：是用来描绘软件系统逻辑模型的图形工具，它描绘信息和数据从输入到输出过程中，所经历的一系列变换。</p><p>数据流图：一般在软件生命周期的早期阶段开始进行分析，在软件生命周期后续阶段不断改进、完善和细化。</p><p>数据流图：非常适用于事务处理系统和其他偏重功能性的应用系统。</p><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16682551691331668255168835.png"></p><p>数据流图的绘制</p><p>一般情况下，应该遵守“由外向里”的原则。</p><p>即先确定系统的边界或范围，再考虑系统的内部，先画数据处理的输入和输出，再画数据处理内部。</p><p>也就是：</p><p>先全局，后局部；</p><p>先整体，后细节；</p><p>先抽象，后具体。</p><p>在图书预订系统中，书店向顾客发放订单，顾客将所填订单交由系统处理，系统首先依据图书目录对订单进行检查，并对合格订单进行处理，处理过程中，根据顾客情况和订单数目，将订单分为：优先订单与正常订单两种，随时处理优先订单，定期处理正常订单。最后，系统根据所处理的订单，进行汇总，并按出版社要求发给出版社。</p><p>第1步，画出顶层数据流图。</p><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16682552621251668255261204.png"></p><p>第2步，逐层分解加工，绘制1层数据流图。</p><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16682553101281668255309986.png"></p><p>第3步，绘制2层数据流图。</p><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16682553851221668255384615.png"></p><h3 id="实体-关系图-1"><a href="#实体-关系图-1" class="headerlink" title="实体-关系图"></a>实体-关系图</h3><p>（Entity Relation Diagram，简称为：E-R图）</p><p>实体-关系图的组成元素</p><p>实体-关系图：主要包含：实体、关系和属性，它创建了软件的数据模型。</p><p>实体：是现实世界中客观存在的，而且，可以相互区别的事物或活动的抽象。如：人、汽车、商品、职工等；</p><p>属性：是描述实体或关系中的一种特征。</p><p>一个实体或关系通常具有多个特征，需要多个相应属性来描述。如：学生的属性，包括：学号、姓名、性别、年龄等。</p><p>绘制实体-关系图：</p><p>用矩形表示实体，在框内写上实体名；</p><p>用椭圆形表示实体的属性，并用无向边把实体和属性连接起来；</p><p>用菱形表示实体间的关系，在菱形框内写上关系名，用无向边分别把菱形框与有关实体连接起来，在无向边旁注明关系的类型。</p><p>实体-关系图（Entity Relation Diagram，简称为：E-R图）</p><p>“学生实体和班级实体”的实体-关系图。</p><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16682556291221668255628262.png"></p><h3 id="状态转换图-1"><a href="#状态转换图-1" class="headerlink" title="状态转换图"></a>状态转换图</h3><p>（Status Transfer Diagram，简称为：STD）</p><p>状态转换图：是用于指明系统在外部事件作用下，将会如何动作，表明了系统的各种状态，以及各种状态间的转换。</p><p>状态转换图：还指明了作为特定事件的结果，系统将做哪些动作。</p><p>状态转换图的组成元素</p><p>状态转换图：由状态、事件和转换组成。</p><ul><li>状态：是任何可以被观察到的系统行为模式，一个状态代表系统的一种行为模式。<ul><li>状态主要有：初态（即：开始状态），终态（即：最终状态）和中间状态。<ul><li>初态：用实心圆表示。</li><li>终态：用一对同心圆（内圆为实心圆）表示。</li><li>中间状态：用圆角矩形表示，可以用两条水平横线，把它分成上、中、下3个部分。上面部分为状态的名称，这部分是必须有的；中间部分为状态变量的名字和值，这部分是可选的；下面部分是活动表，这部分也是可选的。</li></ul></li></ul></li><li>事件：是在某个特定时刻发生的事情，它是对引起系统做动作或从一个状态转换到另一个状态的外界事件的抽象。<ul><li>事件：就是引起系统做动作或转换状态的控制信息。<ul><li>是用箭头上的标记表示，它是引起转换的消息。</li></ul></li></ul></li><li>转换：表示状态从一种状态变为另一种状态<ul><li>用两个状态之间带箭头的连线来表示，箭头指明了转换方向。</li></ul></li></ul><p>例题：“复印机控制软件”的状态转换图。状态：闲置状态、复印状态、缺纸状态、卡纸状态。事件：复印命令、完成复印命令、发现没纸、装满纸、发生卡纸故障、故障排除。</p><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16682558781351668255877501.png"></p><h3 id="用例图-1"><a href="#用例图-1" class="headerlink" title="用例图"></a>用例图</h3><p>用例图：是用来描述<strong>系统外部执行者</strong>与其<strong>交互用例之间</strong>的关系。</p><p>用例是<strong>系统开发者和用户反复讨论的结果</strong>，描述了<strong>开发者和用户对需求规格说明所达成的共识</strong>。</p><p>用例描述了对目标系统的功能需求，并把系统看作黑盒子，从外部行为者的角度来理解系统。</p><p>用例驱动了需求分析之后各阶段的开发工作，从而影响到开发过程的各个阶段。</p><p>用例图是进行需求分析和建立系统功能模型的强有力工具。</p><p>用例图的主要元素是：系统、用例、行为者以及用例之间的关系。</p><p>例如，自动售货机系统的用例图。</p><p>自动售货机系统的用例图。</p><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16682560991251668256098456.png"></p><h3 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h3><p>类是：对一组对象的描述，这些对象具有相似的属性、操作、关系和行为。</p><p>类图：描述类及类与类之间的静态关系。</p><p>类图：不仅定义软件系统中的类，描述类与类之间的关系，它还表示类的内部结构（即：类的属性和操作）。</p><p>一个类可以出现在多个类图中，一个系统可以由多个类图来描述。</p><p>类图的表示符号</p><p>类图的符号是一个长方形，用两条横线把长方形分为上、中、下三个区域。这三个区域分别放类的名字、属性和操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">    class 动物</span><br><span class="line">    动物 : String 标签</span><br><span class="line">    动物 : 吃()</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">  class 银行账户</span><br><span class="line">  银行账户 : +String 户主</span><br><span class="line">  银行账户 : +BigDecimal 余额</span><br><span class="line">  银行账户 : +存(数量)</span><br><span class="line">  银行账户 : +取(数量)</span><br></pre></td></tr></table></figure><h3 id="活动图-1"><a href="#活动图-1" class="headerlink" title="活动图"></a>活动图</h3><p>活动图，用来描述<strong>用例中交错的各种流</strong>或者<strong>执行某个动作的执行者角色或者业务处理中的流程</strong>。</p><p>活动图：主要描述<strong>动作及动作的结果对象状态改变</strong>。</p><p>无须指明任何事件，只要源状态中的动作被执行了，活动图中的状态（称为动作状态）就自动开始转换。</p><p>活动图：描述交互的方式，它描述采取何种动作，动作的结果是什么（即：动作状态改变），何时发生，以及在何处发生。</p><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16682564111221668256411074.png"></p><h3 id="时序图-1"><a href="#时序图-1" class="headerlink" title="时序图"></a>时序图</h3><p>时序图：描述对象之间的动态交互关系，着重表现对象之间消息传递的时间顺序。</p><p>时序图有2个坐标轴：纵坐标表示时间、横坐标表示不同的对象。</p><p>注意：时序图通常有多个对象，体现对象间的时间顺序。</p><p>时序图中的对象：用一个矩形框表示，框内标有对象名，从表示对象的矩形框，向下的垂直虚线是对象的“生命线”，用于表示在某段时间内该对象的存在。</p><p>对象间的通信通过对象生命线之间的水平消息线来表示，消息箭头的形状表明消息的类型（有：同步、异步或简单）。</p><p>当收到消息时，接收对象立即开始执行活动。</p><p>即对象被激活</p><p>激活用对象生命线上的细长矩形框表示。</p><p>消息：通常用消息名和参数表来标识。</p><p>消息可以带有条件表达式，用于表示分支或决定是否发送消息。</p><p>如果用条件表达式表示分支，则会有若干个互斥的箭头，也就是说，在某一时刻仅可发送分支中的一个消息。</p><p>浏览时序图的方法是：</p><p>从上到下（即：按时间顺序）查看对象间交换的消息。</p><p>如图所示为时序图示例。</p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16682567711271668256770517.png" style="zoom:50%;" /><h3 id="决策表-1"><a href="#决策表-1" class="headerlink" title="决策表"></a>决策表</h3><p>决策表：是分析和表达多逻辑条件下，执行不同操作情况的工具。</p><p>决策表：分为四个部分</p><p>左上部列出所有条件</p><p>左下部是所有可能做的动作</p><p>右上部是表示各种条件组合的一个矩阵</p><p>右下部是和每种条件组合相对应的动作。</p><p>决策表通常有四个部分组成：</p><p>① 条件桩（Condition Stub）：列出了问题的所有条件。通常认为列出的条件的次序无关紧要。</p><p>② 动作桩（Action Stub）：列出了问题规定可能采取的操作。这些操作的排列顺序没有约束。</p><p>③ 条件项（Condition Entry）：列出针对它左列条件的取值。在所有可能情况下的真假值。</p><p>④ 动作项（Action Entry）：列出在条件项的各种取值情况下应该采取的动作。</p><p>行李费算法的决策表。</p><p>条件项：国内乘客、头等舱、残疾乘客、行李重量</p><p>动作项：列出了不同行李重量可能采取的操作</p><p>右侧上部和下部：各种条件组合和每种条件组合相对应的动作。</p><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16682569271221668256926721.png"></p><p>决策表的建立步骤：</p><p>① 确定规则的个数，假如有n个条件，每个条件有两个取值（0，1）,故有2的n次方种规则。</p><p>② 列出所有的条件桩和动作桩。</p><p>③ 填入条件项。</p><p>④ 填入动作项。得到初始决策表。</p><p>⑤ 简化、合并相似规则（相同动作）。</p><p>决策表的优点：</p><p>1）能够将复杂的问题按照各种可能的情况全部列举出来，简明并避免遗漏。因此，利用决策表能够设计出完整的测试用例集合。</p><p>2）在一些数据处理问题中，某些操作的实施依赖于多个逻辑条件的组合，即：针对不同逻辑条件的组合值，分别执行不同的操作。决策表很适合于处理这类问题。</p><h3 id="决策树-1"><a href="#决策树-1" class="headerlink" title="决策树"></a>决策树</h3><p>决策树的概念</p><p>决策树：适合描述问题处理中具有多个判断，而且每个决策与若干条件有关。</p><p>决策树：是决策表的变种，也能清晰地表示复杂的条件组合与应做的动作之间的对应关系。</p><p>决策树的形式简单到不需任何说明，一眼就可以看出其含义，因此，易于掌握和使用。</p><p>行李费算法的决策树</p><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16682571361211668257135662.png"></p><p>决策树的优点</p><p>优点：在控制层级的基础上，构造简单，表示方法直观，易于理解。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>描述的每一个需求建模方法都有其优点和不足。</p><p>没有哪一个图形化模型能够充分描述系统的每个方面。</p><p>这些模型提供的描述也有重叠，所以我们也没有必要为项目创建所有的视图。</p><p>比如，如果创建了实体关系图和数据字典，很可能就没有必要再创建类图。</p><h2 id="Summary-10"><a href="#Summary-10" class="headerlink" title="Summary"></a>Summary</h2><p>需求建模方法具备的共同特点：</p><p>1）提供描述手段</p><p>2）提供基本步骤</p><p>常见的软件需求模型包括：</p><p>数据流图（DFD）</p><p>实体关系图（ERD）</p><p>状态转换图（STD）</p><p>用例图</p><p>类图</p><p>活动图</p><p>时序图</p><p>事件-响应表</p><p>数据流图：</p><p>数据流图：用于标识一个系统中的加工处理、系统所操作的数据集合或者物理介质以及在处理、存储和系统外部之间的数据流。</p><p>数据流图由四种基本符号组成：</p><p>“箭头”表示：数据流，</p><p>“圆角矩形”表示：数据处理或加工</p><p>“双线”表示：数据存储</p><p>“矩形框”表示：外部实体</p><p>实体-关系图：</p><p>实体-关系图，包含：实体、关系和属性。</p><p>实体：是现实世界中客观存在的，而且，可以相互区别的事物或活动的抽象。</p><p>属性：是描述实体或关系中的一种特征。一个实体或关系通常具有多个特征，需要多个相应属性来描述。</p><p>关系：现实世界中事物内部以及事物之间的联系，在软件系统中反映为实体内部的关系和实体之间的关系。</p><p>实体之间的关系有三类：一对一关系（1:1）、一对多关系（1:n）和 多对多关系（m:n）</p><p>用例图：是用来描述系统外部执行者与其交互用例之间的关系。</p><p>（2）类是：对一组对象的描述，这些对象具有相似的属性、操作、关系和行为。</p><p>（3）活动图，用来描述用例中交错的各种流或者执行某个动作的执行者角色或者业务处理中的流程。</p><p>（4）时序图：描述对象之间的动态交互关系，着重表现对象之间消息传递的时间顺序。</p><p>决策表：</p><p>决策表：是分析和表达多逻辑条件下执行不同操作的情况的工具。</p><p>决策表：分为四个部分，其左上部列出所有条件，左下部是所有可能做的动作，右上部是表示各种条件组合的一个矩阵，右下部是和每种条件组合相对应的动作。</p><p>决策树：</p><p>决策树：适合描述问题处理中具有多个判断，而且每个决策与若干条件有关。</p><p>决策树：是决策表的变种，也能清晰地表示复杂的条件组合与应做的动作之间的对应关系。</p><h1 id="第7章-需求文档-1"><a href="#第7章-需求文档-1" class="headerlink" title="第7章  需求文档"></a><strong>第7章  需求文档</strong></h1><h2 id="需求文档在需求工程中的位置-1"><a href="#需求文档在需求工程中的位置-1" class="headerlink" title="需求文档在需求工程中的位置"></a>需求文档在需求工程中的位置</h2><p>软件文档：是软件产品的重要组成部分，对于开发人员、项目管理人员以及软件用户都是十分重要的辅助工具。</p><p>软件文档定义清晰、维护及时，能够帮助开发人员理解需求、顺畅沟通，帮助项目管理人员了解进度、加强管理，帮助软件用户更好地使用和维护软件。</p><p>常用的软件文档主要包括：可行性研究报告、项目开发计划、需求文档、概要设计文档、详细设计文档、测试文档、项目开发总结报告、用户手册和操作手册等。</p><p>需求文档：是其中最重要的软件文档之一。</p><p>需求文档：使得开发人员、项目管理人员和软件用户对软件的初始规定达成共识，并使之成为整个开发工作的基础。</p><p>需求工程是一个不断反复的需求定义、需求分析、文档记录、需求演进的过程，并最终在验证的基础上得到需求基线。</p><p><em>需求是软件产品的根源，需求工作的优劣对软件产品影响最大。</em></p><p><em>就像一条河流，如果源头被污染了，那么整条河流也就被污染了。</em></p><h2 id="需求文档与需求工程中各阶段的关系-1"><a href="#需求文档与需求工程中各阶段的关系-1" class="headerlink" title="需求文档与需求工程中各阶段的关系"></a>需求文档与需求工程中各阶段的关系</h2><p>如图所示</p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16682609193551668260919301.png" style="zoom:50%;" /><ul><li><p>需求获取：当我们和客户合作时，我们会问一些问题，取得他们所提供的信息。</p></li><li><p>需求分析：分析获取的信息以理解它们，并把它们分成不同的类别，同时把客户需求同可能的软件需求联系起来。</p></li><li><p>需求文档：即，软件需求规格说明。</p></li><li><p>需求验证：可以让客户代表评审软件需求规格说明，并纠正存在的错误。</p></li><li><p>这四个过程相互迭代，贯穿着需求开发整个阶段。</p></li></ul><p>需求文档：</p><ul><li><p>是在整个需求开发过程中逐步完成，并完善。</p></li><li><p>经过评审后的需求文档，是经过迭代式的需求开发工作后最终形成的成果。</p></li><li><p>是需求管理的主要对象，也是设计文档、开发文档、测试文档等编写的重要依据。</p></li></ul><h2 id="需求文档的作用有以下几方面：-1"><a href="#需求文档的作用有以下几方面：-1" class="headerlink" title="需求文档的作用有以下几方面："></a>需求文档的作用有以下几方面：</h2><ol><li><p>规范的文档可以拓展人脑的知识记忆能力。</p><p>人脑的记忆力总是有限的，获取的信息会随着时间慢慢消退。</p><p>大量临时记录的文档，如果不及时进行整理，在下次阅读时很难再回忆起当时要表达的知识，容易造成歧义。</p><p>规范的文档可以解决这些问题。</p></li><li><p>编制需求文档的过程，是需求分析员更理解问题的过程，使文档表达的知识更准确、更清晰。</p></li><li><p>定义清晰、正确、规范的需求文档为开发人员、项目管理人员和软件用户提供相对稳定的可阅读资料。</p></li><li><p>通过编制需求文档，可以尽早发现需求错误，提高项目开发效率。</p><p>错误在整个项目开发过程中有放大效应，因此，编制需求文档的过程，也是进一步明确和完善系统需求的过程。</p><p>通过减少需求错误从而尽可能地降低项目返工成本，保证项目按期完成。</p></li><li><p>需求文档能够促进软件开发过程的规范化，也为开发团队建立了经验模型和可复用知识库。</p><p>如果需求分析员在项目未完成时离开了开发团队，通过需求文档记录了他们的工作，智力资产不会被带走。</p><p>如果有新员工加人项目开发团队，也可以通过阅读文档，尽快地融人团队中。</p><p>如果要进行项目二次开发，或者有类似的项目，则通过文档获得可复用知识模型，可以加快项目开发进度。</p></li><li><p>需求文档可以作为项目开发方和软件客户之间的有关软件系统的协议基准，可以使用它作为合同协议的重要组成部分。使开发方和软件客户对系统目标达成一致。</p></li><li><p>需求文档可以作为软件成本估算和项目开发进度安排的重要依据，从而使整个项目开发计划的制订更为合理。</p></li></ol><h2 id="对待需求文档的两种不同观点：-1"><a href="#对待需求文档的两种不同观点：-1" class="headerlink" title="对待需求文档的两种不同观点："></a>对待需求文档的两种不同观点：</h2><p>一种观点，是过分强调文档，一味追求文档的厚度、完整性，甚至花很长时间去美化文档，不断更新一些不重要的文档细节，从而导致花费大量时间编制和维护文档，反而降低了软件开发效率。</p><p>另一种观点，则是完全不重视文档，认为文档的编写只是一个形式化的过程，为节约时间，根本不重视文档的书写风格和表达方式，在实际开发过程中也基本不使用文档，这种观点将导致文档的作用得不到体现，和没有使用文档的开发，效果相差无几。</p><p>科学的态度应该是：</p><ul><li><p>充分重视文档的实效，而非形式，不要过于强调“文档量”。</p></li><li><p>而要注重文档内容和文档中文字、图表的表达，使文档能够准确、简洁、清晰的表达系统需求信息。</p></li><li><p>使文档能够被项目管理人员、开发人员和软件客户共同接受。</p></li></ul><h2 id="在编写需求文档时，应遵循如下的基本原则：-1"><a href="#在编写需求文档时，应遵循如下的基本原则：-1" class="headerlink" title="在编写需求文档时，应遵循如下的基本原则："></a>在编写需求文档时，应遵循如下的基本原则：</h2><p>（1）在可能的情况下，需求文档应该由软件开发方和软件客户联合起草。</p><p>由于用户通常对软件设计和开发过程了解较少，</p><p>软件开发方通常对客户从事的领域了解较少，对于客户的问题和意图也不甚清楚。</p><p>（2）需求文档编写应适应文档的读者。</p><p>需求文档的读者主要是项目管理人员、开发人员和软件客户，其中开发人员主要包括系统设计人员、程序员、测试人员、文档编写人员。</p><p>只有充分了解读者对文档的需求，才能编写出一份好的技术性文档。</p><p>（3）需求文档的表达方式依赖于内容。</p><p>需求文档的表达方式可以划分为：自然语言、图形化模型和形式化规格描述3种。</p><p>在大多数情况下中，仍然采用自然语言表达为主，图形化模型表达为辅的文档表达方式，在少量对描述精确性要求很高的文档中，采用形式化描述方式。</p><p>（4）需求文档编写应有必要的重复，并不断完善。</p><p>为了保证读者能够正确理解文档内容，或提醒用户关注重点内容，在文档中应有必要的重复，但要注意不是简单的重复，而是不断的完善。</p><p>（5）需求文档编写应具有一定的灵活性。</p><p>主要表现如下。</p><p>1）文档的详细程度应具有一定的灵活性。</p><p>基于相同模版的需求文档，可能只有几页，也可能是上百页。</p><p>详细程度取决于任务的规模、复杂性和项目管理人员对软件开发过程及运行环境所需要的详细程度的判断。</p><p>2）文档可以扩展与合并，文档中所有的章节都可以进一步细分或缩并，以适应实际需要。</p><p>3）文档应能够对需求变更进行有效的管理和控制。</p><p>用户需求的变化、市场需求的变化、系统变化、工作环境的变化，以及由于对原有需求的误解或需求分析不充分而存在的需求Bug都有可能导致需求变更。</p><p>因此，文档应能够灵活地处理需求变更。</p><p>（6）采用原型法，渐进式开发需求文档。</p><p>人们总是希望一开始就能将整个软件系统的需求确定下来，但在实际项目中却很难达到这一目标。</p><p>为降低需求风险，提高软件开发效率，可以采用原型法，渐进式编写需求文档。</p><p>常用的编写需求文档的方法有：</p><p>自然语言</p><p>图形化模型</p><p>形式化规格描述</p><h2 id="常用的编写需求文档的方法有：-1"><a href="#常用的编写需求文档的方法有：-1" class="headerlink" title="常用的编写需求文档的方法有："></a>常用的编写需求文档的方法有：</h2><ol><li><p>自然语言</p><p>自然语言：是使用结构合理的自然语言来表述需求。</p><p>自然语言：不管对于写的人还是看的人，都是一个很容易接受的方法，一直以来这都是描述需求的首选方法。</p><p>自然语言优点：易于编写、易于阅读，不要求掌握特定的技能。</p><p>自然语言缺点：不够严谨，歧义性强，表述力差，对于复杂问题的描述就更为明显，往往需要很大的篇幅来解释。</p><p>因此，需要尽可能采用结构化文本来组织。</p></li><li><p>图形化模型   —— “一图抵千言”</p><p>图形化模型：在表述时能够给读者提供更强的视觉效果，同时能够使问题更加聚焦。</p><p>图形化模型：在日常的交流中，经常会在纸上绘制一些非标的示意图，以更好地完成沟通。</p><p>图形化模型优点：就是前面提到的可视性、聚焦性。</p><p>图形化模型缺点：要求编写和阅读的人都能够正确地理解模型，而且并不是所有的信息都是可以用模型表示的。</p><p>因此，对于一个软件需求文档而言，是不可能只有图形化模型、没有任何文字表述的。</p></li><li><p>形式化方法描述</p><p>形式化方法描述：比图形化模型更高一些。对于逻辑性很强、精度要求很高的场合，形式化方法描述就是一种不错的选择。</p><p>形式化方法描述优点：是严谨、精确。</p><p>形式化方法描述：缺点：是编写和阅读的人都会感到很困难，容易产生理解歧义。</p></li><li><p>需求文档编写方法的选择：</p><p>1）以自然语言为主，而以图形化模型为辅，需要的地方少量使用形式化方法描述。</p><p>这是现在最常见的组合形式，对于绝大多数信息系统、软件产品而言都是十分适合的方法。</p><p>2）以图形化模型为主，而以自然语言作为补充，需要的地方少量使用形式化方法描述。</p><p>3）以形式化规格语言为主，而以图形化模型为辅，并以自然语言为补充。</p><p>适用于质量要求很高的领域，例如：航天、军工中的一些重要软件系统。</p></li></ol><p>软件需求规格说明，也称为：功能规格说明、需求协议及系统规格说明。</p><p>软件需求规格说明：精确地阐述一个软件系统必须提供的功能、性能及它所要求考虑的限制条件。</p><p>软件需求规格说明：不仅是系统测试和用户手册的编写基础，也是各子系统计划、设计、编码的基础。</p><p>软件需求规格说明：应尽可能完整地描述系统预期的外部行为和用户可视化行为。</p><h2 id="编写需求规格说明步骤：-1"><a href="#编写需求规格说明步骤：-1" class="headerlink" title="编写需求规格说明步骤："></a>编写需求规格说明步骤：</h2><p>1）整理所有已经通过审核的各阶段工作文档，这些文档虽然是阶段性的，但一定是经过审核准确的，对于每一个审核的局部文档都要给出版本号。</p><p>2）制订一个结构完成的需求规格说明模板，并给需求规格说明模板一个版本号，同时要制订一个需求规格说明的编写规范。</p><p>3）按照需求规格说明模板和编写规范依据整理的各阶段文档成果进行编写，编写时一定要注意前后一致性原则。</p><p>4）软件需求规格说明书编写成员进行自检和互检，最终形成一个提交需求验证的软件需求规格说明文档。</p><p>常用的标识方法有以下几种：</p><p>1）序列号法</p><p>序列号法：是一种最简单的方法，就是给每个需求一个唯一的序列号，如UR-1 , SRS13 , FR-1等。</p><p>当一个新的需求进来时，再依序给它分配一个序列号，序列号的前缀代表需求类型，</p><p>由于序号不能重用，当有一个需求被纳人进来时，其原先占有的序列号并不能释放出来，容易造成序列号断号。</p><p>序列号法：不能提供任何相关需求在逻辑上或层次上的区别，而且标识中不含有与需求内容相关的信息。</p><p>2）层次化编码</p><p>层次化编码：是一种常用的方法。如：软件需求规格说明中的4.1，下一层标识号是4.1.1等。</p><p>层次化编码中的数字越多，则表示需求越详细，号数越多的说明它是最底层的需求。</p><p>层次化编码：简单且紧凑，利用文档工具可以实现层次号的自动变更，它很方便地显示了一个需求的层次构成。</p><p>层次化编码： 不含需求的内容信息，而且如果有其他地方引用，当变动时引用部分要做相应的修改。</p><p>3）层次化文本标签</p><p>层次化的文本标签是结构化的、具有语义上的含义。</p><p>层次化文本标签：不受增加和减少或移动的影响。</p><p>层次化文本标签：但要定义好层次化文本标签要比层次化数字标识难得多。</p><p>处理不完整性</p><p>在编写需求规格说明时，一定会遇到缺少特定的需求信息，或认为原有过程化需求文档有不正确的地方，则使用一种TBD ，即待确定的标记来标识这些不确定的需求。</p><p>并将TBD的地方记录在一个TBD问题列表中，该列表有TBD编号、问题内容、责任人、解决时间、解决状态，这个表将有助于跟踪这个文档的编写。</p><p>TBD问题列表将作为需求规格说明文档的附录。</p><p>要把最终的软件需求规格说明移交给软件开发组时，必须解决所有的TBD问题。</p><h2 id="软件需求规格说明模板-1"><a href="#软件需求规格说明模板-1" class="headerlink" title="软件需求规格说明模板"></a>软件需求规格说明模板</h2><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16682618521221668261851542.png"></p><p>1.引言</p><p>引言：提供了一个概述，帮助于读者理解软件需求规格说明的组织方式和使用方式。</p><p>引言：主要包括：目标、文档约定、读者对象和阅读建议、项目范围及参考文献。</p><p>1.1 目标</p><p>在文档中说明软件或应用程序的需求，包括：修订或者发行版本号。</p><p>如果该软件需求规格说明只与整个系统的一部分有关系，那么，就只需确定这一部分或子系统。</p><p>1.2 文档约定</p><p>描述编写文档时所采用的所有标准或印刷上的约定。</p><p>包括：文本样式、强调形式或具有特殊意义的表示符号。</p><p>1.3 读者对象和阅读建议</p><p>列举软件需求规格说明面向的不同读者对象。</p><p>描述软件需求规格说明中其余部分的内容及其组织结构。</p><p>就每一类读者最合适以什么顺序来阅读该文档提出建议。</p><p>1.4 项目范围</p><p>提供对指定的软件及其作用的简短描述。</p><p>把软件与用户或公司目标相关联，把软件与业务目标和策略相关联。</p><p>如果可以得到单独的前景和范围文档，那么应该引用它，而不要直接将其内容复制到这里。</p><p>如果是说明改进产品的增量发布的软件需求规格说明，那么应该包括它自己的范围声明，作为长期战略的产品前景的一个子集。</p><p>1.5参考资料</p><p>列举编写软件需求规格说明时所参考的所有文档或其他资源。</p><p>如果可能的话，使用超文本链接。</p><p>2.总体描述</p><p>2.1 产品前景</p><p>描述产品的背景和起源。</p><p>说明该产品是否是产品系列中的下一个成员，是否是成熟系统的下一版本，是现有应用程序的升级产品还是是一个全新的产品。</p><p>2.2 产品特性</p><p>列出产品所具有的主要特性或者产品可实现的重要功能。</p><p>在此只需要提供一个总体概括即可。</p><p>2.3 用户类及其特征</p><p>确定我们能预料到的有可能使用该产品的各种用户类。</p><p>描述他们的相关特征。</p><p>2.4 运行环境</p><p>描述软件的运行环境，包括：硬件平台、操作系统和版本，以及用户、服务器和数据库的地理位置</p><p>2.5 设计和实现上的约束</p><p>描述限制开发人员进行有效选择的所有因素，以及每一种约束的基本原理。</p><p>2.6 用户文档</p><p>列出将要交付的用户文档组件以及可执行软件，可以包括用户手册、联机帮助和教程。</p><p>确定所有要求的文档交付格式、标准或工具。</p><p>2.7 假设和依赖</p><p>假设是这样一种声明，在缺少证据或不确定的情况下先相信它是真的。</p><p>如果假设不正确、不一致或被更改，那么就可能会产生问题。</p><p>有些假设将会转化为项目风险。</p><p>3.系统特性</p><p>模板是根据系统特性来组织的，它只是安排功能性需求的一种可能的方式。</p><p>其他可以选择的方式还包括按照用例、操作模式、刺激、响应、对象类或功能层次结构等。</p><p>正确的选择并不是惟一的，但我们应该选择一种使读者易于理解产品预期功能的组织方法</p><p>3.1 系统特性X</p><p>仅用简短的词语说明特性的名称，例如“3.1 拼写检查”。</p><p>对每一个系统特性都要重复 3.x.1一3.x.3 这几个部分。</p><p>3.x.1 描述优先级</p><p>提供对该特性的简短描述，并指出该特性的优先级是高、中或低</p><p>3.x.2 激励&#x2F;响应序列</p><p>列出输入激励序列（如：用户操作、来自外部设备的信号或其他触发器）和系统响应序列，系统响应序列定义这一特性的行为。</p><p>这些激励与用例最初的对话步骤或者与外部系统事件相对应。</p><p>3.x.3 功能性需求</p><p>逐项列出与该特性相关的详细功能性需求。</p><p>这些是必须提交给用户的软件功能，使用户可以执行该特性的服务或者完成一个用例。</p><p>描述产品如何响应可预知的出错条件以及如何响应非法输入或操作。</p><p>唯一地标识每个功能性需求。</p><p>4.外部接口需求</p><p>这部分所提供信息是为了保证系统与用户、与外部硬件或软件元素之间的正常通信。</p><p>如果一个复杂系统有多个组成部分，则应创建一个独立的接口规范说明或者系统架构规范说明。</p><p>主要包括：用户界面、硬件接口、软件接口和通信接口。</p><p>4.1 用户界面</p><p>描述系统所需的每个用户界面的逻辑特征或屏幕模型，以便与需求的另一个视图进行交流。</p><p>而不能将用户界面的设计细节写入软件需求规格说明中。</p><p>4.2 硬件接口</p><p>描述系统中软件和硬件组件之间每一接口的特征。</p><p>这种描述可能包括支持的设备类型、软件和硬件之间的数据和控制交互以及所用的通信协议等。</p><p>4.3 软件接口</p><p>描述该产品与其他软件组件之间的连接，这些组件包括数据库、操作系统、工具、库和集成的商业组件等。</p><p>声明在软件组件之间交换消息、数据和控制项的目的。</p><p>描述外部软件组件所需的服务，以及组件间通信的本质。</p><p>确定将在软件组件之间共享的数据。</p><p>4.4 通信接口</p><p>描述产品将使用的所有通信功能的需求，包括电子邮件、Web浏览器、网络通信协议和电子表格等。</p><p>定义所有相关的消息格式。</p><p>规定通信安全或加密问题、数据传输速率和同步通信机制等。</p><p>5.其他非功能性需求</p><p>5.1 性能需求</p><p>声明各种系统操作特定的性能需求，并解释其原理以指导开发人员做出合理的设计选择。</p><p>5.2 防护性需求</p><p>这部分声明与产品使用过程中可能发生的损失、破坏或危害相关的需求。</p><p>定义必须采取的安全保护措施或动作，还有那些必须避免的可能危险的动作。</p><p>明确产品必须遵循的安全标准、策略或规则。</p><p>5.3 安全性需求</p><p>指定与安全性、完整性或保密性问题相关的所有需求，这些问题影响对产品的访问、使用以及产品所创建或使用的数据的保护。</p><p>确定产品必须遵守的所有安全或保密策略或规则。</p><p>5.4 软件质量属性</p><p>声明对用户或开发人员至关重要的其他产品质量特征。</p><p>这些特征必须是明确的、定量的和可验证的。</p><p>应该指明各种属性的相对优先级。</p><p>6.其他需求</p><p>定义在此软件需求规格说明中其他部分未出现的所有其他需求。</p><p>例如：国际化需求及法律上的需求。</p><p>如果不需要添加任何其他需求，就省略这一部分。</p><p>7.附录</p><p>附录A：术语表</p><p>定义读者需要了解的所有专门术语，以便他们能够正确地理解软件需求规格说明。</p><p>附录B：分析模型</p><p>这一部分是可选的，包括或指向相关的分析模型。</p><p>例如：数据流图、类图、状态转换图、实体-关系图等。</p><p>附录C：待确定问题的清单</p><p>这一部分列出了有待于解决的需求问题。</p><p>这一部分并不是软件需求规格说明所必需的。</p><h2 id="Summary-11"><a href="#Summary-11" class="headerlink" title="Summary"></a>Summary</h2><p>需求文档：是其中最重要的软件文档之一。</p><p>需求开发，包括：</p><p>需求获取</p><p>需求分析</p><p>需求文档</p><p>需求确认</p><p>需求文档的7个作用：</p><p>（1）规范的文档可以拓展人脑的知识记忆能力。</p><p>（2）编制需求文档的过程，是需求分析员更理解问题的过程，使文档表达的知识更准确、更清晰。</p><p>（3）定义清晰、正确、规范的需求文档为开发人员、项目管理人员和软件用户提供相对稳定的可阅读资料。</p><p>（4）通过编制需求文档，可以尽早发现需求错误，提高项目开发效率。</p><p>（5）需求文档能够促进软件开发过程的规范化，也为开发团队建立了经验模型和可复用知识库。</p><p>（6）需求文档可以作为项目开发方和软件客户之间的有关软件系统的协议基准，可以使用它作为合同协议的重要组成部分。使开发方和软件客户对系统目标达成一致。</p><p>（7）需求文档可以作为软件成本估算和项目开发进度安排的重要依据，从而使整个项目开发计划的制订更为合理。</p><p>编写需求文档的6个原则：</p><p>（1）在可能的情况下，需求文档应该由软件开发方和软件客户联合起草。</p><p>（2）需求文档编写应适应文档的读者。</p><p>（3）需求文档的表达方式依赖于内容。</p><p>（4）需求文档编写应有必要的重复，并不断完善。</p><p>（5）需求文档编写应具有一定的灵活性。</p><p>（6）采用原型法，渐进式开发需求文档。</p><p>需求文档的编写方法：</p><p>自然语言</p><p>图形化模型</p><p>形式化规格描述</p><p>需求文档编写方法的选择：</p><p>1）以自然语言为主，而以图形化模型为辅，需要的地方少量使用形式化方法描述。</p><p>2）以图形化模型为主，而以自然语言作为补充，需要的地方少量使用形式化方法描述。</p><p>3）以形式化规格语言为主，而以图形化模型为辅，并以自然语言为补充。</p><p>编写需求规格说明步骤：</p><p>（1）整理所有已经通过审核的各阶段工作文档。</p><p>（2）制订一个结构完成的需求规格说明模板，并给需求规格说明模板一个版本号。</p><p>（3）按照需求规格说明模板和编写规范依据整理的各阶段文档成果进行编写。</p><p>（4）软件需求规格说明书编写成员进行自检和互检。</p><p>常用的标识方法：</p><p>（1）序列号法</p><p>（2）层次化编码</p><p>（3）层次化文本标签</p><p>处理不完整性方法：</p><p>（1）使用：TBD ，即待确定的标记来标识这些不确定的需求。</p><p>（2）将有TBD的地方记录在一个TBD问题列表中。</p><p>（3） TBD问题列表将作为需求规格说明文档的附录。</p><p>（4）要把最终的软件需求规格说明移交给软件开发组时，必须解决所有的TBD问题。</p><p>软件需求规格说明模板：</p><p>当前常用的模板是IEEE标准830-1998的模板。</p><p>模板中的主要内容：</p><ol><li><p>引言</p></li><li><p>总体描述</p></li><li><p>系统特性</p></li><li><p>外部接口需求</p></li><li><p>其他非功能性需求</p></li><li><p>其他需求</p></li><li><p>附录</p></li></ol><h1 id="第8章-软件质量属性-1"><a href="#第8章-软件质量属性-1" class="headerlink" title="第8章   软件质量属性"></a>第8章   软件质量属性</h1><h2 id="质量属性的概念：-1"><a href="#质量属性的概念：-1" class="headerlink" title="质量属性的概念："></a>质量属性的概念：</h2><p>系统的功能：是系统能够为用户提供帮助的第一要素。</p><p>成功的软件系统除了满足功能需求之外，还需要满足更多的要求。</p><p>系统的<strong>性能需求</strong>，包括：系统的易用性、运行速度、出错频率，以及处理异常情况的能力等。</p><p>这些特性合起来被称为：<strong>软件质量属性或质量因素</strong></p><p>它是<strong>系统非功能需求</strong>的一部分。</p><p>质量属性：也应该和功能需求一样得到足够的重视。</p><p>在决定系统的成功或失败的因素中，有时满足非功能属性往往比满足功能需求更为重要。</p><p>质量属性：对设计的影响很大。</p><p>质量属性：在软件设计中，对任何指定的功能都会有多种可选的方案，不同的方案选择产生不同的设计结果。</p><p>不同的方案之间却有着很大的区别，差异之处即在于拥有不同的质量属性。</p><p>不同的质量属性之间互有折中，很难会出现某一个设计方案的质量属性完全优于其他方案的情况。</p><p>因此，软件设计必须根据需求的质量属性在多种方案中，选择一个最优的方案。</p><p>如果不存在事先定义好的质量属性，设计方案的选择将完全没有依据，结果就很有可能导致软件不被用户接受。</p><p>在设计开始之初，就确定质量属性非常重要，而且对越复杂的系统越为重要。</p><p>质量属性：分类两类：</p><p>（1）根据质量属性能否在运行时进行识别。</p><p>（2）根据对用户和技术人员的重要性，分为：</p><p>对用户很重要的可见的质量属性</p><p>对技术人员有意义的质量属性</p><p>后者通过使系统易于更改、纠正和验证，并易于移植到新的平台上，间接地促进用户需要的满足。</p><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16685971558011668597155036.png"></p><p>理想情况下，每一个系统总是展示所有这些属性可能的最大值。</p><p>系统总是可用的，决不会崩溃，可以立即得出始终正确的运行结果，系统也总是直观且易于使用。</p><p>必须了解哪些属性对项目的成功至关重要。</p><p>根据这些基本属性来定义用户和开发人员的目标，从而使系统的设计人员能够做出合适的选择</p><h2 id="对用户重要的属性：-1"><a href="#对用户重要的属性：-1" class="headerlink" title="对用户重要的属性："></a>对用户重要的属性：</h2><h3 id="可用性（Availability）-1"><a href="#可用性（Availability）-1" class="headerlink" title="可用性（Availability）"></a>可用性（Availability）</h3><p>可用性：用于衡量预定的可用时间，在这期间系统是真正可用并且是完全可操作的。</p><p>可用性：等于系统的平均无故障时间（简称：MTTF）除以平均无故障时间与故障发生后所用的故障修复时间（简称：MTTR）之和。</p><p>即：可用性 &#x3D; MTTF&#x2F;（MTTF+MTTR）</p><p>可用性，包括：可靠性、可维护性和完整性。</p><h3 id="有效性（Efficiency）-1"><a href="#有效性（Efficiency）-1" class="headerlink" title="有效性（Efficiency）"></a>有效性（Efficiency）</h3><p>有效性：用来衡量系统在利用处理器的处理能力、磁盘空间、内存或通信带宽等方面的表现如何。</p><p>有效性与性能相关，性能是另一类非功能性需求。</p><p>如果系统消耗了太多可用的资源，那么用户遇到的将是性能的下降，这是缺乏有效性的一个表现。</p><h3 id="灵活性（Flexibility）-1"><a href="#灵活性（Flexibility）-1" class="headerlink" title="灵活性（Flexibility）"></a>灵活性（Flexibility）</h3><p>灵活性，也称为：可扩充性、可扩展性。</p><p>灵活性：用来测量向系统中添加新功能的容易程度。</p><p>如果开发人员预料到要对系统进行扩展，那么他们可以选择使软件灵活性最高的设计方案。</p><p>灵活性：对以增量或迭代方式开发的系统是必不可少的，这些系统是通过一系列连续的发布版本或演化式原型而开发的。</p><h3 id="完整性（Integrity）-1"><a href="#完整性（Integrity）-1" class="headerlink" title="完整性（Integrity）"></a>完整性（Integrity）</h3><p>完整性：主要处理防止非法访问系统功能、防止数据丢失、保护软件免受病毒入侵以及保护输入到系统的数据的保密性和安全性等问题。</p><p>完整性需求不能容忍任何错误，陈述完整性需求时应使用含义明确的术语。</p><p>如：用户身份验证、用户特权级别、访问限制或者需要保护的精确数据。</p><h3 id="互操作性（Interoperability）-1"><a href="#互操作性（Interoperability）-1" class="headerlink" title="互操作性（Interoperability）"></a>互操作性（Interoperability）</h3><p>互操作性：表明了系统与其他系统交换数据和服务的难易程度。</p><p>为了评估互操作性，必须了解清楚用户使用其他哪些应用程序与本系统协同工作，还要了解清楚用户期望交换什么数据。</p><h3 id="可靠性（Reliability）-1"><a href="#可靠性（Reliability）-1" class="headerlink" title="可靠性（Reliability）"></a>可靠性（Reliability）</h3><p>可靠性：是软件无故障执行指定时间的概率。</p><p>健壮性有时可看成是可靠性的一部分。</p><p>衡量软件可靠性的方法，包括：正确执行操作所占的百分比和系统发生故障之前正常运行的平均时间长度。</p><p>具有高可靠性要求的系统，也应该设计得具有很高的可测试性，就可以轻松地发现损害系统可靠性的缺陷。</p><h3 id="健壮性（Robustness）-1"><a href="#健壮性（Robustness）-1" class="headerlink" title="健壮性（Robustness）"></a>健壮性（Robustness）</h3><p>健壮性：指的是当系统遇到非法的输入数据、相连接的软件组件或硬件组件的缺陷，以及预料不到的操作情况时，能继续正确运行功能的可能性。</p><p>健壮的软件：可以从发生问题的环境中自然地恢复过来，并且可以容忍用户所犯的错误。</p><p>当获取健壮性需求时，向用户询问系统可能遇到的错误条件，并且要了解用户期望系统如何响应。</p><h3 id="易用性（Usability）-1"><a href="#易用性（Usability）-1" class="headerlink" title="易用性（Usability）"></a>易用性（Usability）</h3><p>易用性：陈述了许多因素，用户经常将这些因素描述为“用户友好性”。</p><p>分析人员和开发人员不应该讨论友好的软件，而应该讨论将软件的使用设计得有效而不让人感到困惑。</p><p>易用性：包括：对于新用户或不常使用系统的用户在学习使用系统时的简易程度。</p><h2 id="对开发人员重要的属性-1"><a href="#对开发人员重要的属性-1" class="headerlink" title="对开发人员重要的属性"></a>对开发人员重要的属性</h2><h3 id="可维护性-1"><a href="#可维护性-1" class="headerlink" title="可维护性"></a>可维护性</h3><p>可维护性：表明了纠正缺陷或修改软件的简单程度，它取决于理解软件、更改软件和测试软件的简单程度。</p><p>可维护性：与灵活性和可测试性密切相关。</p><p>对那些将要频繁修订的系统和要快速生成的系统来说，可维护性的要求很高。</p><p>可以根据修复一个问题所花的平均时间和修复正确的百分比来衡量可维护性。</p><h3 id="可移植性-1"><a href="#可移植性-1" class="headerlink" title="可移植性"></a>可移植性</h3><p>可移植性：用来度量把一个软件从一种运行环境移植到另一种运行环境所需的工作量。</p><p>可移植性：对项目的成功来说，要么是无关紧要，要么是至关重要。</p><p>可移植性：目标应该确定系统中必须移植到其他环境的那一部分，并描述这些目标环境。</p><p>开发人员就能选择设计和编码方法以适当提高系统的可移植性。</p><h3 id="可重用性-1"><a href="#可重用性-1" class="headerlink" title="可重用性"></a>可重用性</h3><p>可重用性：是软件开发的一个长远目标。</p><p>可重用性：表明把一个软件组件用于其他应用程序所涉及的相关工作量。</p><p>比起创建一个打算只在一个应用程序中使用的组件，开发可重用软件的费用会大得多。</p><p>可重用软件必须模块化，文档齐全，不依赖于特定的应用程序和运行环境，并且具有通用性。</p><h3 id="可测试性-1"><a href="#可测试性-1" class="headerlink" title="可测试性"></a>可测试性</h3><p>可测试性：也称为：可验证性。</p><p>可测试性：指的是测试软件组件或集成系统以查找缺陷的简单程度。</p><p>如果系统中包含复杂的算法和逻辑，或包含复杂的功能性相互关系，那么对于可测试性的设计就很重要。</p><p>如果经常更改系统，那么可测试性也是很重要的，因为需要经常对系统进行回归测试，来判断更改是否破坏了任何原有的功能性。</p><h2 id="属性的折中方案-1"><a href="#属性的折中方案-1" class="headerlink" title="属性的折中方案"></a>属性的折中方案</h2><p>用户和开发人员必须确定，与其他属性相比哪些属性更为重要。</p><p>当制定决策时，必须始终遵照优先级顺序。</p><p>如图所示，描述了质量属性之间一些典型的相互关系。</p><p>当然我们也可能会遇到一些与此不一致的例外</p><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16685984267931668598426587.png"></p><p>单元格中的加号：表明单元格所在行的属性对其所在列的属性具有正面的影响。</p><ul><li>例如，增强软件组件可移植性的设计方法也可以使软件变得更加灵活，更易于与其他软件组件相连接，更易于重用，并且更易于测试。</li></ul><p>单元格中的减号：表明单元格所在行的属性对其所在列的属性具有负面的影响。</p><p>单元格为空则表明单元格所在行的属性对其所在列的属性几乎没有什么影响。</p><p>有效性对其他许多属性具有消极影响。</p><p>类似地，一些对易用性进行优化的系统，或具有灵活性、可重用性以及与其他软件组件或硬件组件进行互操作的系统，则要付出性能的代价。</p><p>如图所示中的矩阵并不是对称的，因为增加属性A对属性B所产生的影响与增加属性B对属性A所产生的影响并不一定是相同的。</p><ul><li>例如，图中表明设计系统时增加有效性并不一定对完整性产生任何影响。</li></ul><p>增加完整性却可能会损害有效性，因为系统必须通过更多层次的用户身份验证、加密、病毒扫描和数据检查技术。</p><p>为达到系统特性的最佳平衡，必须在需求获取阶段识别、指定相关的质量属性，并且为之确定优先级。</p><p>为项目定义重要的质量属性时，利用图可以防止发生与目标冲突的行为。</p><h2 id="性能需求-1"><a href="#性能需求-1" class="headerlink" title="性能需求"></a>性能需求</h2><p>性能需求：定义了系统必须多好和多快地完成专门的功能。</p><p>性能需求：包括：速度（例如，数据库响应时间）、吞吐量（例如，每秒钟处理的事务）、处理能力（例如，并发使用负载）和定时（例如，严格的实时要求）。</p><p>苛刻的性能需求，会对设计软件策略和选择硬件造成严重的影响，因此，定义的性能需求目标要适合于运行环境。</p><p>性能需求范例：</p><p>范例1：温度控制循环必须在80毫秒内完全执行。这里，“80毫秒”就是性能需求。</p><p>范例2：解释器每分钟应该至少解析5000条没有错误的语句。这里，“5000条”就是性能需求。</p><p>范例3：在通过50KBps的调制解调器与Internet相连的情况下，下载一个Web页面需要15秒或更短。这里，“15秒或更短”就是性能需求。</p><p>范例4：ATM自动拒员机系统对提款请求的身份认证不能超过10秒。这里，“10秒”就是性能需求。</p><h2 id="Summary-12"><a href="#Summary-12" class="headerlink" title="Summary"></a>Summary</h2><p>质量属性：</p><p>用于衡量系统性能的特性包括：系统的易用性、运行速度、出错频率，以及处理异常情况的能力等。</p><p>这些特性合起来被称为：软件质量属性或质量因素。</p><p>对用户重要的属性有：</p><p>可用性、有效性、灵活性、完整性、互操作性、可靠性、健壮性、易用性。</p><p>对开发人员重要的属性有：</p><p>可维护性、可移植性、可重用性、可测试性。</p><p>属性的折中方案</p><p>为达到系统特性的最佳平衡，必须在需求获取阶段识别、指定相关的质量属性，并且为之确定优先级。</p><p>性能需求</p><p>性能需求，定义了系统必须多好和多快地完成专门的功能。</p><p>性能需求，包括：速度（例如，数据库响应时间）、吞吐量（例如，每秒钟处理的事务）、处理能力（例如，并发使用负载）和定时（例如，严格的实时要求）。</p><h1 id="第9章-通过原型来减少风险-1"><a href="#第9章-通过原型来减少风险-1" class="headerlink" title="第9章   通过原型来减少风险"></a>第9章   通过原型来减少风险</h1><h2 id="为什么要建立原型？-1"><a href="#为什么要建立原型？-1" class="headerlink" title="为什么要建立原型？"></a>为什么要建立原型？</h2><p>因为预想一个未来的软件系统，并表达出系统需求是比较困难的，而通过制作软件原型，可以使需求更加真实，使用例更加生动，并且，可以减小在需求理解上的差异。</p><p>原型：可以把新系统的一个模型或一个部分摆在用户的面前，可以激活他们的思维，并促进需求对话。</p><p>对原型的早期反馈有助于涉众对理解系统需求达成共识，从而减小客户不满意的风险。</p><p>由于需求中仍然还会有对用户、对开发人员或者对这二者都不明确或不清晰的部分。</p><p>如果不解决这些问题，那么用户对系统的想像与开发人员对系统的理解会存在期望差距。</p><p>原型有多种含义，并且参与原型制作活动的人可以有完全不同的期望。</p><p>如：一个飞机原型实际上可能是真实飞机的雏形。</p><p>一个软件原型：仅仅是真实系统的一部分或一个模型，它可能根本不能完成任何有用的功能。</p><p>软件原型，可能是：</p><p>工作模型或静态设计</p><p>很详细的屏幕草图或简单草图</p><p>真实功能的可视化显示或一部分</p><h2 id="使用原型有3个主要目的：-1"><a href="#使用原型有3个主要目的：-1" class="headerlink" title="使用原型有3个主要目的："></a>使用原型有3个主要目的：</h2><p>（1）明确并完善需求。</p><p>原型：作为一种需求工具。</p><p>原型：是对部分系统的初步实现，因为我们尚没有很好地了解该系统。</p><p>用户对原型的评估，可以指出需求中存在的问题。</p><p>这样可以在开发真正的系统之前，以低成本来解决这些问题。</p><p>（2）研究设计选择方案。</p><p>原型作为一种设计工具，涉众可以用它研究不同的用户交互技术，优化系统的易用性，并评估可能的技术方案。</p><p>原型能够通过有效的设计来演示需求的可行性。</p><p>（3）发展为最终系统。</p><p>原型作为一种构造工具，是系统一个最初子集的完整功能实现，通过一系列小规模的开发周期，我们可以完成整个系统的开发。</p><p>建立原型的主要原因：</p><p>是为了解决在系统开发早期阶段不能确定的一些问题。</p><p>利用这些不确定性，可以判断系统中哪些部分需要建立原型，以及希望从用户对原型的评估中获得什么信息。</p><p>原型：是发现并解决需求中的二义性和不完整性的很好的方法。</p><p>用户、管理人员和其他非技术人员发现：</p><p>当系统处于编写需求规格说明和设计阶段时，原型可以使他们更具体地思考问题</p><p>原型，尤其是直观的原型，比开发人员有时所使用的技术术语更易于理解。</p><h2 id="根据使用原型的目的不同，原型分为：-1"><a href="#根据使用原型的目的不同，原型分为：-1" class="headerlink" title="根据使用原型的目的不同，原型分为："></a>根据使用原型的目的不同，原型分为：</h2><ol><li>水平原型和垂直原型</li><li>抛弃式原型和演化式原型</li><li>书面原型和电子原型</li></ol><h3 id="水平原型-1"><a href="#水平原型-1" class="headerlink" title="水平原型"></a>水平原型</h3><p>当人们谈到“软件原型”时，所想到的通常是一个可能的用户界面的水平原型。</p><ul><li><p>水平原型，也叫做：行为原型或演示性模型。</p></li><li><p>水平原型：主要描绘了用户界面的一部分。</p><ul><li>因为水平原型并不能深入到体系结构的所有层次，或者深入到系统的细节。</li></ul></li><li><p>通过水平原型，可以研究预期系统的一些特定行为，并达到完善需求的目的。</p></li><li><p>水平原型：有助于用户判断基于该原型的系统是否能完成任务。</p></li><li><p>水平原型：显示用户界面的屏幕外观，并允许这些屏幕之间进行某些导航，但只包含很少或根本就不包含真正的功能实现。</p></li><li><p>水平原型：能够演示用户以后可用的功能选项、用户界面的外观和感觉（如：颜色、布局、图形和控件），以及信息体系结构（如：导航结构）等。</p></li><li><p>虽然原型看起来似乎可以执行一些有意义的工作，但其实不然。</p></li><li><p>水平原型：常常只是使用户判断是否有遗漏、错误或不必要的功能。</p></li><li><p>有些原型，代表了开发人员对可能如何实现一个特定用例的一种观念。</p></li><li><p>用户对原型的评估，可以指出用例的其他实现方式、遗漏的交互步骤，或者其他异常情况。</p></li><li><p>当处理水平原型时，用户应该把注意力集中在概括性需求和工作流问题上，而不要被屏幕元素的精确外观所分心。</p></li><li><p>在此阶段，不要担心屏幕元素的精确位置、字体、颜色、图形或控件。</p></li><li><p>弄清了需求，并确定了界面的总体框架之后，再来研究用户界面的细节。</p></li></ul><h3 id="垂直原型-1"><a href="#垂直原型-1" class="headerlink" title="垂直原型"></a>垂直原型</h3><ul><li><p>垂直原型：也称为：结构化原型、概念的证明</p></li><li><p>垂直原型：在整个技术服务层上实现应用程序用户界面的一部分功能。</p></li><li><p>垂直原型的运作与所期望的真实系统的运作类似，因为它触及到了系统实现的所有层次。</p></li><li><p>如果不能确定所提议的架构方法是否可行和合理，或者如果我们想要优化算法、评估所提议的数据库架构或测试关键的定时需求。就可以开发一个垂直模型。</p></li><li><p>垂直原型：为使其结果有意义，通常在与系统类似的运行环境中，用生产工具来创建垂直原型。</p></li><li><p>垂直原型：常用于研究关键界面和定时需求，也常用在设计阶段以减小风险。</p></li></ul><h3 id="抛弃式原型和演化式原型-1"><a href="#抛弃式原型和演化式原型-1" class="headerlink" title="抛弃式原型和演化式原型"></a>抛弃式原型和演化式原型</h3><p>（1）抛弃式原型</p><p>在构造一个原型之前，需要做出一个明确的和经过分析的决策。</p><p>也就是在评估之后是将原型抛弃掉，还是将原型作为最终交付系统的一部分。</p><p>如果打算在原型达到预期目的以后将它抛弃掉，那么，就应该尽量花最小的代价，并尽可能快地创建该原型。</p><p>在此原型上付出的努力越多，项目的参与者就越不愿意将它抛弃掉。</p><p>要注意的是：</p><p>如果认为该原型有其优点，应该留着以备将来重用，那么也不一定非要将它抛弃掉。</p><p>不能将“抛弃式原型”整合到最终交付的系统中。</p><p>可能更愿意将它称为“非发布型原型”。</p><p>抛弃式原型：重点强调在健壮性、可靠性、性能和长期维护性等方面的快速实现和修改。</p><p>不允许将抛弃式原型中质量低的代码移植到最终系统中，否则，用户和维护人员将在系统生命周期中遭遇种种麻烦</p><p>当团队面临需求中的不确定性、二义性、不完整性或含糊性时。</p><p>最恰当的方法是建立一个抛弃式原型。</p><p>这样可以减少在继续开发时存在的风险。</p><p>抛弃式原型：可帮助用户和开发人员直观地了解需求可能如何实现，并发现需求中存在的漏洞。</p><p>抛弃式原型：可以使用户判断出这些需求是否可以使必要的业务过程运作起来。</p><p>不要过于详细地构建抛弃式原型，只要能够满足原型制作的目标就够了。</p><p>如图所示，描述了借助于抛弃式原型，从用例到详细的用户界面设计的一系列开发活动。</p><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16685999257921668599925429.png"></p><p>演化式原型</p><p>当随着时间的推移，需求越来越明确时，演化式原型为增量地构建系统奠定了坚实的结构基础。</p><p>演化式原型：是螺旋式软件开发生命周期模型和某些面向对象软件开发过程的一个组成部分。</p><p>与抛弃式原型快速、粗略的特点相比，演化式原型必须具有健壮性，代码质量从一开始就要达到系统的要求。</p><p>要完成相同的功能，构建演化式原型要比构建抛弃式原型所花的时间更多。</p><p>演化式原型：必须设计得易于进行扩展和频繁改进，开发人员必须重视软件体系结构和成熟的设计原则。</p><p>要得到高质量的演化式原型，并没有捷径可走。</p><p>应该将演化式原型的第1次增量作为一个试验性版本，用来实现需求中已经正确理解和稳定的部分。</p><p>根据用户验收测试和初次使用时发现的问题，在下一次迭代中对其进行修改，最终得到完整的系统，可以很快地将能够使用的功能交付给用户。</p><p>如果已经预料到系统以后还要进行扩展。</p><p>那么，就选择演化式原型。</p><p>如图所示，给出了综合使用各种原型的几种方法。</p><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16686000067931668600006239.png"></p><p>如表所示，概括地总结了抛弃式、演化式、水平和垂直原型的一些典型应用。</p><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16686000497931668600049221.png"></p><h3 id="书面原型和电子原型-1"><a href="#书面原型和电子原型-1" class="headerlink" title="书面原型和电子原型"></a>书面原型和电子原型</h3><p>（1）书面原型</p><p>书面原型：有时也称为“低保真原型”</p><p>书面原型：是一种成本低、速度快，且不涉及高深技术的方法。</p><p>书面原型：可以把一个系统的某部分，是如何实现的呈现在用户面前。</p><p>通过书面原型可以判断用户和开发人员对需求的理解是否一致。</p><p>书面原型：可以在代码编制之前，对可能的解决方案进行试验性和低风险的尝试。</p><p>书面原型：所涉及的工具仅仅是纸张、索引卡、粘贴便签和干净的塑料板等。</p><p>设计人员对屏幕布局进行构思，而不必关心布局中控件的精确位置和它们的外观。</p><p>当用户遍历一个评估场景时，一个人就可以充当计算机的角色。</p><p>用户说出他想在特定的屏幕上做什么来启动动作，模仿计算机的人就会把相应的纸张和索引卡拿给用户看，这些纸张和索引卡表示了用户采取这一动作时的外观显示。</p><p>用户就可以判断这是否确实是所期望的响应，并且还可以判断所显示的条目内容是否正确。</p><p>如果有错误，只需要用一张新纸或索引卡，重画一张就可以了。</p><p>书面原型：可以方便地实现快速迭代，而迭代对需求开发的成功与否起着至关重要的作用。</p><p>书面原型：也有助于开发团队管理客户的需求。</p><p>（2）电子原型</p><p>电子原型：就是一个基于计算机的可运行的原型。</p><p>构建一个抛弃式电子原型，可以使用以下工具：</p><ol><li><p>编程语言，例如：Visual Basic，IBM VisualAge Smalltalk和Delphi。</p></li><li><p>脚本语言，例如Perk Python和Rexx（雷克斯）。</p></li><li><p>商业原型制作工具箱、屏幕绘图器和图形用户界面生成器。</p></li><li><p>绘图工具，例如Visio和PowerPoint</p></li></ol><p>运用合适的工具，可以轻松地实现并修改用户界面组件，而不管隐藏在界面背后的代码效率高低。</p><p>如果创建一个演化式原型，那么必须从一开始就使用系统开发工具。</p><h2 id="Summary-13"><a href="#Summary-13" class="headerlink" title="Summary"></a>Summary</h2><p>建立原型的3个目的：</p><p>（1）明确并完善需求</p><p>（2）研究设计选择方案</p><p>（3）发展为最终系统</p><p>根据使用原型的目的不同，原型分为：</p><p>水平原型和垂直原型</p><p>抛弃式原型和演化式原型</p><p>书面原型和电子原型</p><p>水平原型：主要描绘了用户界面的一部分。</p><p>因为水平原型并不能深入到体系结构的所有层次，或者深入到系统的细节。</p><p>垂直原型：也称为：结构化原型、概念的证明</p><p>在整个技术服务层上实现应用程序用户界面的一部分功能。</p><p>建立水平原型目的：</p><p>研究预期系统的一些特定行。</p><p>显示用户界面的屏幕外观、屏幕之间的导航。</p><p>建立垂直原型目的：</p><p>确定所提议的架构方法是否可行和合理。</p><p>优化算法、评估所提议的数据库架构或测试关键的需求。</p><p>（1）抛弃式原型：</p><p>是在原型达到预期目的后，就将原型抛弃掉。</p><p>当团队面临需求中的不确定性、二义性、不完整性或含糊性时，最恰当的方法是建立一个抛弃式原型。</p><p>（2）演化式原型：</p><p>是增量地构建系统，是被开发系统的一个组成部分。</p><p>必须具有健壮性，代码质量从一开始就要达到系统的要求。</p><p>必须易于进行扩展和频繁改进。</p><p>开发人员必须重视软件体系结构和成熟的设计原则。</p><p>（1）书面原型</p><p>书面原型：有时也称为“低保真原型”</p><p>书面原型：是一种成本低、速度快，且不涉及高深技术的方法。</p><p>书面原型：所涉及的工具仅仅是纸张、索引卡、粘贴便签和干净的塑料板等。</p><p>（2）电子原型</p><p>电子原型：就是一个基于计算机的可运行的原型。</p><p>（1）原型评估：</p><p>可以从原型所针对的用例或功能中推导出评估脚本。</p><p>务必要通过合适的人从恰当的角度来评估原型。</p><p>要同时包括有经验的和经验不足的用户类代表。</p><p>（2）创建原型所带来的风险：</p><p>风险1：是项目相关人员看到一个正在运行的原型，从而得出系统几乎已经完成的结论。</p><p>风险2：是用户重点关注的是系统“如何做”的问题，他们关注用户界面的外观如何，以及如何操作这些界面。</p><p>风险3：是用户将根据原型的性能来推断最终系统的期望性能。</p><p>（3）建立有效原型应遵循的原则：</p><ol><li><p>应该在项目计划中包括创建原型的任务。安排好开发、评估和更改原型的时间进度和所需的资源。</p></li><li><p>创建原型之前，先要陈述每个原型的用途。</p></li><li><p>要计划开发多个原型，因为很少能一次便成功。</p></li><li><p>创建抛弃式原型时要用最少的投资开发出用于回答问题和解决需求不确定性的原型。</p></li><li><p>抛弃式原型中不应包括输入数据有效性检查、防御式编码技术、用于错误处理的代码或代码注释。</p></li><li><p>对于已经理解的需求不要建立原型，除非是要研究设计选择方案。</p></li><li><p>在原型显示和报告中使用看似真实的数据。</p></li></ol><h1 id="第10章-确定需求的优先级别-1"><a href="#第10章-确定需求的优先级别-1" class="headerlink" title="第10章  确定需求的优先级别"></a>第10章  确定需求的优先级别</h1><h2 id="为什么要设定需求优先级？-1"><a href="#为什么要设定需求优先级？-1" class="headerlink" title="为什么要设定需求优先级？"></a>为什么要设定需求优先级？</h2><p>对于每一个受资源限制的软件项目，都必须对要求的功能定义相对优先级。</p><p>设定优先级：有助于项目经理解决冲突、安排阶段性交付，并且做出必要的取舍。</p><p>当用户的期望很高，而且开发时间又很紧迫时，就必须确保在系统的尽早版本中，提供最重要的功能。</p><p>设定优先级：就是一种行之有效的方法，可以处理在资源有限的情况下，应该优先满足哪些需求。</p><p>为每一种功能建立相对优先级后，就可以规划软件的开发过程，以最低的成本提供最佳的系统。</p><p>项目经理必须根据时间进度、项目预算、人力资源以及质量目标等约束条件，权衡考虑，制定出合理的项目范围。</p><p>达到此目的的一种方法是：</p><p>当接受一个更重要的新需求或者项目的其他条件发生变化时，删除优先级低的需求。</p><p>或者把它们推迟到下一版本中实现。</p><p>如果用户并没有将他们的需求按重要性和紧迫性区分开，那么项目经理就必须自己做出决策。</p><p>很可能用户并不赞成项目经理所设定的优先级，这不足为奇。</p><p>用户必须指明哪些需求必须在最初版本中得到实现，哪些需求可以延期实现。</p><p>当有多个可用方案都可以实现一个成功的系统时，应尽早在项目中设定优先级，并且要定期查看它们。</p><p>如果用户并没有将他们的需求按重要性和紧迫性区分开，那么项目经理就必须自己做出决策。</p><p>很可能用户并不赞成项目经理所设定的优先级，这不足为奇。</p><p>用户必须指明哪些需求必须在最初版本中得到实现，哪些需求可以延期实现。</p><p>当有多个可用方案都可以实现一个成功的系统时，应尽早在项目中设定优先级，并且要定期查看它们。</p><p>2）优先级规则</p><p>用户对设定优先级的第1个反应是：</p><p>“所有功能我都需要，无论采用什么方式，只要实现它就行”</p><p>如果用户知道优先级低的需求可能不会实现，那么就很难说服用户讨论需求优先级。</p><p>有些开发人员更喜欢避开设定优先级，因为他们认为：</p><p>他们可以全部完成系统功能。</p><p>事实上，即便是一个中等规模的软件项目，也有好几十个用户需求和好几百个功能需求，多到难以通过分析进行统一归类。</p><p>项目中总有一些系统功能比其他的功能更为必要。</p><p>在项目接近尾声时，当开发人员抛弃掉一些不必要的功能，以保证按期交付一些重要功能的时候，这一特性体现得尤为明显。</p><p>如果在项目的早期阶段设定优先级，并随着用户偏好、市场状况和业务事件的变更而重新评估它们。</p><p>那么，项目团队就可以“好钢用在刀刃上”，合理地将时间花在价值最高的功能中。</p><p>如果某一功能己经实现得差不多了，才得出该功能并不需要的结论。</p><p>则会造成时间上的巨大浪费，同时，也会让人感到很沮丧。</p><p>如果让用户自己设定优先级。</p><p>那么，他们将把85%的需求设定为高优先级，10%的需求设定为中等优先级，5%的需求设定为低优先级。</p><p>这并没有给项目经理很多灵活性。</p><p>如果确实是几乎所有的需求都具有最高的优先级。</p><p>那么，项目就面临着不能完全获得成功的风险，因此，应该制定出相应的计划。</p><p>可以通过废除不必要的需求，并且简化那些过于复杂的需求，来对需求做出调整。</p><p>为了帮助用户代表确认哪些需求属于低优先级的需求，分析人员可以向他们询问如下几个问题：</p><ol><li><p>是否有其他方法可以满足这一需求?</p></li><li><p>如果忽略或推迟实现这一需求，其后果是什么?</p></li><li><p>如果不立即实现这一需求，那么对项目业务目标会有什么影响?</p></li><li><p>如果将这一需求推迟到下一版本中实现，用户为什么会不满意?</p></li></ol><p>在一个小型项目中，项目相关人员可以非正式地就需求的优先级达成共识。</p><p>对于大型项目或有争议的项目，则需要采用一种更加结构化的方法，这样在处理过程中，可以消除一些感情因素、政策因素以及推测。</p><p>人们提出许多分析上的和数学上的技术，用于辅助需求优先级的确定。</p><p>这些方法包括：建立每个需求的相对价值和相对成本。</p><p>优先级最高的需求是那些以最低的成本生产出最高的系统价值的需求。</p><h2 id="确定需求优先级的一些技术：-1"><a href="#确定需求优先级的一些技术：-1" class="headerlink" title="确定需求优先级的一些技术："></a>确定需求优先级的一些技术：</h2><p>入选与落选</p><p>两两比较并排序</p><p>三层分级法</p><p>MoSCoW（莫斯科欧）排序法</p><p>在MoSCoW（莫斯科欧）优先级排序法中，四个大写字母代表在一个需求集合中四类可能的优先级类别，具体如下：</p><p>M字母，指的是：Must（必做）：需求必须满足，只有这样，解决方案才会被认为是成功的。</p><p>S字母，指的是：Should（应做）：需求很重要，并且如果可能，应当包含到解决方案中，但对于成功不是强制性的。</p><p>C字母，指的是：Could（可做）：想要但是可以推迟或者清除，只有当时间和资源都允许的时候才实现。</p><p>W字母，指的是：Won’t（不做）：表示这次不实现，但可能包含到未来的版本中。</p><p>对于如何通过比较其他需求来评级给定需求的优先级，MoSCoW（莫斯科欧）排序法并没有给出相关的依据。</p><p>MoSCoW（莫斯科欧）排序法：不关注时间，特别是需求被评定为“Won’t”时，极可能意味着“不在下个版本中做”，也可能意味着“永远不做”</p><p>设定优先级的一种方法是：</p><p>质量功能部署（简称：QFD）</p><p>质量功能部署：是将用户价值和所提议的系统功能相联系的一种综合方法。</p><p>在质量功能部署方法中，用户价值取决于两个方面：</p><p>一方面，如果实现了特定的系统特性，将为用户提供收益；</p><p>另一方面，如果不能实现系统特性，用户收益就要受到损害。</p><p>这个设定优先级的方法可适用于除了最高优先级之外的所有需求。</p><p>根据价值、成本和风险来设定优先级方法：</p><p>借鉴了质量功能部署的概念，对用户价值加以考虑。</p><p>即，考虑如果获得某个特定系统特性，会为用户提供什么收益，也考虑到如果没有那个特性，会带来什么损失。</p><p>在设定优先级的过程中典型的参与者有：</p><p>项目经理、用户代表和开发人员代表。</p><p>项目经理：负责整个过程，解决冲突，并且在必要的时候协调其他参与者的意见。</p><p>用户代表：可以提供受益和损失的程度。</p><p>开发人员代表：可以提供成本和风险程度。</p><p>根据价值、成本和风险来设定优先级，必须遵循如下8个步骤：</p><ul><li>步骤1：在表格中列出要设定优先级的所有特性、用例或功能需求。</li></ul><p>所有条目都必须在同一抽象级别上，不要把功能需求与系统特性混合在一起。</p><p>如果某些特性有逻辑上有联系，在分析中只要列出驱动较全面的项。如果有更多的项，那么就把相关的特性归成一类，并建立一个可管理的初始化列表。</p><p>如果需要的话，可以在更详细的级别上进行第二轮分析。</p><ul><li>步骤2：让用户代表来估计每一个特性提供给用户或业务的相关收益，并用1-9划分等级，1代表对任何人都没用的特性，9代表具有最大价值的特性。</li></ul><p>这些收益等级表明这些特性与系统业务需求的一致性。</p><ul><li>步骤3：估计出如果没有把某一特性包括到系统中，将会给用户或业务上带来的相对损失。</li></ul><p>仍然使用1-9划分等级，这里1代表即使不包括这一特性也无人会介意，9代表如果不包括这一特性将带来严重损失。</p><p>对于具有低收益低损失的需求只会增加费用，而不会增加价值；</p><p>步骤4：将表格中的“相对收益”和“相对损失”相加，并考虑权值，计算出每个特性的总价值。</p><p>即：总价值 &#x3D; 相对收益<em>收益权值 + 相对损失</em>损失权值</p><p>并计算出每个特性价值占总价值的百分比。</p><p>即：“价值%”一栏。</p><p>步骤5：让开发人员估计实现每个特性的相对成本，并计算出每个特性价值占总相对成本的百分比。</p><p>使用1-9来划分等级，1代表快速而容易，9代表费时又昂贵。</p><p>根据特性的复杂度、所需要的用户界面的实际情况、重用当前代码的潜在能力、所需的测试量和文档等等，开发人员可以估算出相对成本。</p><p>步骤6：让开发人员估计出与每个特性相关的技术风险或其他风险的相对程度，并计算出每个特性所产生的风险百分比。</p><p>技术风险：是指第1次尝试实现某个特性时，不能成功的概率。</p><p>使用1-9来划分等级，1表示可以轻松地实现编程，9表示需要重点关注其可行性、缺乏具有专门知识的人员，或者使用不成熟或不熟悉的工具和技术。</p><p>如果根本无需在分析中考虑风险，就把风险的权值设为0。</p><p>步骤7：把所有的估算值都填入表格之后，就可以利用优先级公式，计算出每一特性的优先级值。</p><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16686023507921668602350675.png"></p><p>步骤8：按计算出的优先级的降序排列表中的特性。处于列表最顶端的特性是价值、成本和风险之间的最佳平衡，因此，具有最高的优先级。</p><h1 id="Summary-14"><a href="#Summary-14" class="headerlink" title="Summary"></a>Summary</h1><p>设定需求优先级原因：</p><p>设定优先级有助于项目经理解决冲突、安排阶段性交付，并且做出必要的取舍。</p><p>为每一种功能建立相对优先级后，就可以规划软件的开发过程，以最低的成本提供最佳的系统。</p><p>分析人员可以向用户询问的几个问题：</p><ol><li><p>是否有其他方法可以满足这一需求?</p></li><li><p>如果忽略或推迟实现这一需求，其后果是什么?</p></li><li><p>如果不立即实现这一需求，那么对项目业务目标会有什么影响?</p></li><li><p>如果将这一需求推迟到下一版本中实现，用户为什么会不满意?</p></li></ol><p>确定需求优先级的技术，包括：</p><p>入选与落选</p><p>两两比较并排序</p><p>三层分级法</p><p>MoSCoW（莫斯科欧）排序法</p><p>设定优先级的质量功能部署方法：</p><p>质量功能部署（简称：QFD）</p><p>质量功能部署：是将用户价值和所提议的系统功能相联系的一种综合方法。</p><p>根据价值、成本和风险来设定优先级，有8个步骤。</p><p>以“化学品跟踪系统”的特性为例，介绍了根据价值、成本和风险来设定优先级的过程。</p><p>注意：</p><p>计算出来的优先级序列，只能作为一种指导策略的参考。</p><p>客户和开发者代表应该讨论，从而达成共识，并根据使用情况来校正。</p><p>可以适当调整每一因素的权值，直到所计算出的优先级序列与后来对测试集中需求的重要性评估相吻合为止。</p><p>在把需求优先级的设定，应以客观和分析为基础</p><h1 id="第11章-需求确认-1"><a href="#第11章-需求确认-1" class="headerlink" title="第11章   需求确认"></a>第11章   需求确认</h1><ul><li><p>需求确认：是指开发方和用户方共同对软件需求规格说明进行评审，双方对需求达成共识后作出承诺。</p></li><li><p>是需求开发的最后一个环节。可以通过内部评审、同行评审以及用户评审的方式来完成。</p></li><li><p>项目组内部评审或同行评审：主要是根据公司规范和评审人员本身的经验对需求分析中不明确、不合理、不符合逻辑、不符合规范的地方予以指正。</p></li><li><p>用户评审：主要是对描述的软件实现是否真正符合他们的需求，能否帮助他们解决问题等方面做出评定。</p></li><li><p>需求确认的目的：是要检验需求是否能够反映用户的意愿。是尽可能地发现需求里的错误，减少因后期修改需求错误所带来的损失。</p></li></ul><p>需求确认的提出：</p><h2 id="避免信息衰减的关键手段-1"><a href="#避免信息衰减的关键手段-1" class="headerlink" title="避免信息衰减的关键手段"></a>避免信息衰减的关键手段</h2><ol><li><p>文档</p><p>如果信息在传递的过程中仅靠口头传递，就难免发生遗忘、加工等情况。</p><p>因此，必须在这个过程中有效地利用文档，将达成共识的信息文档化。</p><p>但这种方法只是用来辅助沟通的，而不是代替沟通。</p></li><li><p>评审</p><pre><code> 评审：在很多人的脑海中就是得出一个通过与否的结论，这也是导致需求评审工作流于形式的罪魁祸首之一。  评审：是通过再次的审读，尽早地暴露出错误。  最简单、有效的评审：是在用户代表阐述了需求之后，需求分析员用自己的语言再复述一遍，以确保沟通没有失真。  评审的首要任务：是确认需求是否充分，并正确的反映了用户的需求。</code></pre></li></ol><p>需求确认：</p><p>首先需要用户来验证结构和文档化后的需求是否和他们的想法一致，是否把用户的真实意图描述清楚了，以保证需求本身的正确性。</p><p>对于后续设计开发阶段的人员也需要对需求进行评审，以保证需求的可实现性，确认需求描述是否清楚，是否是可以实现的，对于业务对象，流程和规则是否存在不可实现的模糊描述词语。</p><p>对于测试人员，则主要是确认需求是否是可测试的，是否在需求描述中存在不确定和不可测试的词语。</p><p>不仅仅是需求阶段对需求文档的评审，还需要关注设计，开发等各阶段对需求的实现情况的验证。指在需求规格说明完成之后，对需求规格说明文档进行的验证活动。是对需求的复查和审核，目的是发现需求中存在的错误，以便及时更正，避免在后期实施中修改造成大量的损失。</p><p>好的需求将会带来好的系统质量和用户满意度，降低系统后期维护和用户支持的费用。</p><h2 id="需求确认的任务：-1"><a href="#需求确认的任务：-1" class="headerlink" title="需求确认的任务："></a>需求确认的任务：</h2><p>需求确认的活动确保以下几个方面的内容：</p><ol><li><p>软件需求规格说明是否正确描述了目标系统的行为和特征；</p></li><li><p>从系统需求、业务规则或其他来源中得到软件需求；</p></li><li><p>需求是完整的和高质量的；</p></li><li><p>所有人对需求的看法是一致的；</p></li><li><p>需求为进一步的软件开发和测试提供了足够的基础。</p></li></ol><p>需求确认的任务：就是要求各方人员从不同的技术角度对需求规格说明文档做出综合性评价。</p><h2 id="需求确认的内容：-1"><a href="#需求确认的内容：-1" class="headerlink" title="需求确认的内容："></a>需求确认的内容：</h2><p>一般来说，从下述4个方面进行需求验证：</p><p>1）一致性：所有需求必须是一致的，任何一条需求不能和其他需求相矛盾。</p><p>2）完整性：需求必须是完整的，软件需求规格说明应包括用户需要的每一个功能和性能。</p><p>3）现实性：指定的需求在现有的硬件技术或软件技术的基础上应该是基本上可行的。</p><p>4）有效性：必须证明需求是正确有效的，确实能解决用户需求间的矛盾。</p><p>一般可根据软件系统的特点和用户的要求增加一些检验内容。</p><p>如：软件的可信特性，即安全性、可靠性、正确性以及系统的灵活性等。</p><p>验证需求规格说明的方法，除形式化方法外，大部分只能通过人工进行检测。</p><p>此外，部分项目相关人员也不愿意在需求确认方面花费时间。</p><p>形式化的验证方法主要使用数学方法：</p><p>即，将软件系统抽象为用数学符号表示的形式系统。</p><p>然后，通过推理和证明的方式来验证软件系统中的一些性质，如：完整性、一致性、可信特性等。</p><p>这种方法的好处：是严格和自动化。</p><p>这种方法的不足：是对数学基础的要求太高，难度较大。</p><p>通过人工进行检测的方式有很多，例如：需求评审。</p><p>这种方式就是让与项目相关的所有人员参加，并根据验证的内容人工评审软件需求规格说明文档。</p><p>另外，还可结合现有的一些软件技术，如：设计测试用例的方法等，对软件需求进行多方面的、有效的检验和测试</p><h2 id="需求评审方法-1"><a href="#需求评审方法-1" class="headerlink" title="需求评审方法"></a>需求评审方法</h2><p>需求评审：是由需求评审员对软件需求规格说明进行检查，以发现其所存在的问题。</p><p>通过对需求规格说明的评审，可以发现其中的不确定和二义性的要求等。</p><p>需求评审，可划分为：非正式评审和正式评审</p><p>非正式评审：由开发人员描述系统并征求意见。</p><p>包括：把工作系统分发给许多其他有关人员，粗略地看一看或走过场地检查。</p><p>非正式评审的好处：是能培养其他人对系统的认识，并可获得一些非结构化的反馈信息。</p><p>非正式评审的不足：是不够系统化和不彻底，或者在实施过程中不具有一致性，并且非正式评审不需要记录，完全可以根据个人爱好进行。</p><p><strong>非正式评审方法包括：</strong></p><p>——同级桌面检查：就是请一位同事检查系统</p><p>——轮查：就是同时请若干同事分别检查可交付的系统</p><p>——走查：作者向评审员描述系统，请求做出评论。</p><p>正式评审：由不同背景的审查人员组成小组，阅读需求规格说明文档，把其中的问题记录下来，再转送给软件开发人员。</p><p>正式评审：有专门的审查人员，正规的审查过程和步骤，审查人员有严格的分工和职责。</p><p>需求评审的组成人员</p><p>在需求正式评审过程中，应由具有不同背景的人组成一个小组，对需求规格说明文档进行评审。</p><p>审查人员由4个方面的人组成：</p><p>1）从事软件系统需求开发的相关人员。</p><p>这类人员主要是指编写需求规格说明的系统分析员及相应参与人员等。</p><p>2）具有需求分析经验和知识的人员，以及领域专家等。</p><p>这些人可以审查需求规格说明文档是否符合标准，是否存在错误等。</p><p>3）客户或用户代表。</p><p>这些人可以保证需求规格说明能正确地、完整地描述他们的需求。</p><p>4）软件开发人员，</p><p>如：设计人员、测试人员、项目经理等。这些人可以发现需求规格说明中存在的不可实现的、含糊或二义性等。</p><p><strong>审查人员的主要角色：</strong></p><p><strong>作者</strong>：编写正在被审查的需求规格说明文档的人，通常为系统分析员。</p><p>他们听取其他审查员的评论，并回答其他审查员提出的问题，但不参与讨论。</p><p><strong>调解员</strong>：审查的调解与主持人，通常为项目总负责人。</p><p>调解员与作者一起制定审查计划，协调审查期间的各种活动，以及推进审查工作的进行。</p><p><strong>读者</strong>：主要由审查员扮演，审查需求规格说明文档，并提出问题，以及自己的看法和理解。</p><p><strong>记录员</strong>：以标准的形式记录在审查中提出的问题和缺陷。</p><p>记录员必须仔细地整理自己所写的材料，以确保记录的正确性。</p><h2 id="需求评审的过程-1"><a href="#需求评审的过程-1" class="headerlink" title="需求评审的过程"></a>需求评审的过程</h2><p>规范的评审过程包括：规划、总体会议、会前准备、评审会议、返工、跟踪6个阶段。</p><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16686067658051668606765489.png"></p><p>1）规划</p><p>由作者和调解员对审查进行规划。</p><p>如：决定谁参加审查，审查之前应准备什么材料，审查会议的日程安排等。</p><p>2）总体会议</p><p>总体会议：可以为审查员提供了解会议的信息。</p><p>包括：要审查的材料背景，作者所做的假设和作者的特定审查目标。</p><p>如果所有的审查员对要审查的项目都很熟悉，那就可以省略本次会议。</p><p>3）准备</p><p>准备工作：做的好不好直接关系到评审会议的质量。</p><p>应为每位评审者提前提供相关资料，提供时间做相关阅读、查找错误。</p><p>评审者可将阅读时发现的文字、版面类的错误直接发给作者，无需在评审会议上讨论，以便节省会议时间，提高会议质量。</p><p>4）评审会议</p><p>在进行审查的过程中，审查员审查软件需求规格说明中的每一个需求。</p><p>当审查员提出可能的错误或其他问题时，记录员就记录这些内容，它们可以成为需求规格说明的作者的参考依据。</p><p>会议的目的是尽可能多地发现需求规格说明中的重大缺陷。</p><p>开审查会的时间不宜过长，如果需要更多的时间，就另外再安排一次会议。</p><p>5）返工</p><p>当发现需求规格说明中出现问题时，作者必须在审查会之后安排一段时间用于修改文档。</p><p>如果把不正确的需求拖延到以后修改，将十分费时。</p><p>马上修改可以解决二义性和消除模糊性，并为成功开发项目打下坚实的基础。</p><p>6）跟踪</p><p>当发现同一类错误多次出现在需求规格说明书中不同地方时，就会发现评审中提出的问题没有得到有效的解决。</p><p>因此，应对提出的问题是否解决进行跟踪、督促，避免同类问题再出现。</p><h2 id="需求评审面临的困难-1"><a href="#需求评审面临的困难-1" class="headerlink" title="需求评审面临的困难"></a>需求评审面临的困难</h2><p>当需求规格说明编写完成后，开发人员希望能尽快地开发软件系统。</p><p>认为需求评审工作是重要的。</p><p>但最重要的是后面的开发工作，从而导致需求评审成为“走过场”。</p><p>在需求评审工作中，一些常见的问题说明如下：</p><p>1）大型的需求文档</p><p>对于一个大的复杂软件系统，其需求规格说明往往有几百页，要审查这样的需求规格说明工作量是非常大的。</p><p>既使一个中型的需求规格说明，审查人员可能会认真地检查开始的部分，有耐心的人可能会审查到中间的部分，但无人可以坚持检查到最后。</p><p>这就导致忽略审查过程，而直接进入软件的开发工作。</p><p>对于上述问题的解决方案是：</p><p>可在强调评审工作重要性的基础上，采用多人分段审查的方式，让一些审查员，从文档的不同位置开始检查，以确保认真地检查其中的每一页，或者采取分组方式，不同组分别审查材料的不同部分。</p><p>2）庞大的审查小组</p><p>一个项目可能涉及许多的相关人员，如：用户、部门经理、销售部门等，他们都与需求相关。</p><p>这些人都可以成为需求评审员。</p><p>然而，评审小组过于庞大，将导致难于安排会议，并且在审查会议上经常引发题外话，在许多问题上也难于达成一致意见。</p><p>这种情况经常导致花了大量的时间而无较好的结果等。</p><p>对于上述这些困难，往往要根据实际情况给予解决。</p><p>例如，可在强调评审工作重要性的基础上，采取解释与说明的方式，采用多人分段审查的方式，以及采取分组方式等。</p><h2 id="测试需求-1"><a href="#测试需求-1" class="headerlink" title="测试需求"></a><strong>测试需求</strong></h2><p>测试需求概述</p><p>测试需求，是验证需求是否是正确的、完整的、无二义性的。</p><p>测试人员要能够分辨出来问题点，并跟用户进行核对，确定用户的真实需求。</p><p>测试需求的输入主要包括：</p><p>需求规格说明、用户用例、界面设计、项目会议或与用户沟通时有关需求信息的会议记录、其他技术文档等；</p><p>测试需求的输出主要包括：</p><p>问题点及修改建议，以及测试分析结果。</p><p>在部分需求稳定时，就可以开始设计测试用例，及早发现问题并以较少的费用解决这些问题。</p><p>测试需求：是对测试目标的概括，根据测试需求，了解测试时所应测试的功能点。</p><p>测试需求：主要是整理测试焦点。</p><p>包括：一些界面、输入域、业务流程、数据等。</p><p>并明确测试焦点的优先级，为测试用例的设计提供测试所需的功能点信息。</p><p>测试需求：是告诉要测什么，而测试用例是告诉怎么测。</p><p>好的测试需求：能发现需求中显性和隐性的测试焦点，从而能更好地指导测试用例的设计。</p><p>在开发过程的早期阶段，可以从用例中获得概念上的功能测试用例。</p><p>即，可验证需求规格说明和分析模型，并做出评价。</p><p>为什么要进行测试需求？</p><p>1）把不直观的需求转变为直观的需求。</p><p>使得测试范围可以度量；</p><p>使得独立的功能点其对应的所有的处理分支可以度量；</p><p>使得该系统需要测试的业务场景可以度量；</p><p>2）把不明确的需求转变为明确的需求，明确其功能点对应的输出、处理和输出；</p><p>3）把不能度量的需求转变为可度量的需求。</p><p>包括：度量测试范围，度量处理分支，度量业务场景。</p><p>需求测试的范围主要有：</p><p>1）需求的背景，目标，影响范围；</p><p>2）系统的输入输出，类型，精度，允许的出错次数，输出的格式，数据的来源以及正确性；</p><p>3）响应时间，提示的方式，异常处理方式，性能指标；</p><p>4）主要流程描述，操作流程和步骤说明，分析是否合理化；</p><p>5）需求的上下文是否一致，有没有与其他需求发生冲突；</p><p>6）需求逻辑是否足够清晰，每个条款是否都包含描述问题及解决问题；</p><p>7）需求是否都是可测试的；</p><p>8）寻找隐含的需求，和相互依赖的需求。</p><p>4）推荐的需求文档格式的内容</p><p>主要有：</p><p>1）业务名称解释；</p><p>2）需求背景及目标介绍；</p><p>3）用户操作场景说明；</p><p>4）功能总览：</p><p>如：逐项叙述对系统所提出的功能要求，说明输入什么量、经怎么样的处理、得到什么输出；</p><p>5）系统交互图；</p><p>6）界面原型；</p><p>7）业务规则说明；</p><p>8）业务正常流程：如：功能模块流程，主要操作流程；</p><p>9）业务异常流处理：如：异常场景，错误提示；异常流转。</p><p>4）推荐的需求文档格式的内容</p><p>这里要注意：</p><p>需求测试：不等同于集成测试或者系统测试。</p><p>软件测试，都是软件已经编写完成的条件下，判断软件是否会出错。</p><p>而需求测试，只是验证需求是否真正是用户的要求。</p><h2 id="Summary-15"><a href="#Summary-15" class="headerlink" title="Summary"></a>Summary</h2><p>需求确认：是软件工程中一项重要的活动。</p><p>需求确认：是需求工程中发生的对需求规格说明文档进行的验证与确认活动。</p><p>需求确认：不仅要发现问题，而且要监督、跟踪问题的解决。</p><p>验证和确认的过程：贯穿于项目开发的每个阶段。</p><p>尽早的了解系统需求，可很大程度上节约后期修改的成本。</p><p>需求确认，主要包括：需求的评审和作出承诺。</p><p>需求确认的目的：</p><p>是要检验需求是否能够反映用户的意愿。</p><p>是尽可能地发现需求里的错误，减少因后期修改需求错误所带来的损失。</p><p>需求确认，主要包括：需求的评审和作出承诺。</p><p>需求确认的目的：</p><p>是要检验需求是否能够反映用户的意愿。</p><p>是尽可能地发现需求里的错误，减少因后期修改需求错误所带来的损失。</p><p>（1）需求确认的任务：</p><p>是对需求规格说明文档做出综合性评价。</p><p>需要确认的内容主要是验证需求的：</p><p>一致性、完整性、现实性、有效性4个方面。</p><p>（2）需求确认的内容：</p><p>一致性</p><p>完整性</p><p>现实性</p><p>有效性</p><p>（1）需求评审方法：</p><p>需求评审：就是由需求评审员对软件需求规格说明进行检查，以发现其所存在的问题。</p><p>需求评审可划分为：非正式评审和正式评审</p><p>（2）需求评审的组成人员：</p><p>1）从事软件系统需求开发的相关人员。</p><p>2）具有需求分析经验和知识的人员，以及领域专家等。</p><p>3）客户或用户代表。</p><p>4）软件开发人员。</p><p>3）需求评审的过程：</p><p>规范的评审过程包括：规划、总体会议、会前准备、评审会议、返工、跟踪6个阶段。</p><p>（4）需求评审面临的困难：</p><p>1）大型的需求文档</p><p>对于一个大的复杂软件系统，其需求规格说明往往有几百页，要审查这样的需求规格说明工作量是非常大的。</p><p>2）庞大的审查小组</p><p>一个项目可能涉及许多的相关人员，如：用户、部门经理、销售部门等，他们都与需求相关。</p><p>测试需求的解释：</p><p>测试需求，是验证需求是否是正确的、完整的、无二义性的。</p><p>为什么要进行测试需求？</p><p>1）把不直观的需求转变为直观的需求。</p><p>2）把不明确的需求转变为明确的需求，明确其功能点对应的输出、处理和输出；</p><p>3）把不能度量的需求转变为可度量的需求。</p><p>需求测试的内容：</p><p>1）需求的背景，目标，影响范围；</p><p>2）系统的输入输出，类型，精度，允许的出错次数，输出的格式，数据的来源以及正确性；</p><p>3）响应时间，提示的方式，异常处理方式，性能指标；</p><p>4）主要流程描述，操作流程和步骤说明，分析是否合理化；</p><p>5）需求的上下文是否一致，有没有与其他需求发生冲突；</p><p>6）需求逻辑是否足够清晰，每个条款是否都包含描述问题及解决问题；</p><p>7）需求是否都是可测试的；</p><p>8）寻找隐含的需求，和相互依赖的需求。</p><p>推荐的需求文档格式的内容：</p><p>1）业务名称解释；</p><p>2）需求背景及目标介绍；</p><p>3）用户操作场景说明；</p><p>4）功能总览；</p><p>5）系统交互图；</p><p>6）界面原型；</p><p>7）业务规则说明；</p><p>8）业务正常流程：如：功能模块流程，主要操作流程；</p><p>9）业务异常流处理：如：异常场景，错误提示；异常流转。</p><h1 id="第12章-需求管理实践-1"><a href="#第12章-需求管理实践-1" class="headerlink" title="第12章   需求管理实践"></a>第12章   需求管理实践</h1><p>（1）需求管理内容<br>软件需求工程，分为：需求开发和需求管理。<br>需求开发活动：<br>包括：获取需求、分析需求、描述需求和确认需求。<br>需求开发的交付物：<br>包括：业务需求、用户需求、功能需求、非功能需求、数据字典和各种分析模型等。<br>在这些交付物经过评审，且核准之后，这些条目的任何已定义子集都可以组成需求基线。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>日记</title>
      <link href="/2022/11/18/%E6%97%A5%E8%AE%B0/"/>
      <url>/2022/11/18/%E6%97%A5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="7c696a58e9f536a65e61f1baf69fd6dae051833a20eab4bafe61bbac186294bd">924d0bf7b0d92eb9e671c08653442f53693e0bbec0694229571ce51ee4e3ea5e2a2dfb84333e7b4339bb19e283f6f274baabd861fb73a07f19013c5617432f0221b21e5fc73e9532ae718c2e7e4ea4c2622dbeec4a82067ffbec3d6df6021159539e15f85a8f92c89d821f5f7d1464446216895c53437434c6dc48c22b8ba3762616a5c0e963668b71be03f5f29d493a0bf37329cb7c52e64be20ff4bf769de28de334c91f7d88ae9a741b1ddfa88a9a245a871a46c4f044b18de6d17916104aac50bc48528207755ee0efce9b93d3fd37091f952169441f05fedf551c4842f40650f2034d386517e4ab131c86d229ec8c2d9854c3c27f462e80750654d4da4fd2c695137e2261466e4b0f01485ff406304e5326046950aa2de52cdee24b1113046470e5db247d32433784ceec53defc66d2dbb29682890e956e6e2c1c7856e65107a9d593c922b7dee7090a6150bf9841684a40444ccb97b3e5d6ab7679bd8b162b41bf8d0d065d092c40db97bcf53aaf16a6865de4e77d16f4c8ae732b982bf4d5fccab90d52967b418c93e0d7b999cc540faead584d0dd0929e330c852cb37a4c689ed7bf2c62590cf602217c40b69d2b23d561193de928ab64bf88f68bae2780813d35433360df6cc756ada72108b1433ce1d1802972cda4b50e515d7fc628496c38a729d2924adb1fcf7316fc790e832cf93aff4fdbb2bd59cfe5b4f55a0d298659cc4f3dc2d40918d109a84234c389572ea30d63ae8f38f412ecf4eacfdd74d9d6f8f8a13eb5248c0651ecfc8ff6608568312f2658a89414fe0473b9ac3fd263222b1589f5a325683ffdfaa7612e29d3cc44acbd6405dc85d8e04f343bb7a80c42ac1d5d6ed1904378aa60d24a6d72572d1222401f118db552599ed25d3ab16c1be56000733ac5eeaadec390f166d0dc6dac8a4be11059cb57d36406cea3542c2bc31df54e505eb15156ae43c0012c6dbfe9263474e48841154df61b9d6b09de72519fee38389c47a904aa31312dd81e124122f1e0c513f7c3e7c8e67f5a6ab66a9cd7234fbfc26773faed6c23f09476f63d9bd6948415d9122de170d9ce175f557e423294baebd81f3ec88b0a59b3f4ab17124db404368e227e87e7bfe2ad3903592f9d98950406b18326884c58aaf5dfe309eb4a5506007574b15131b7b9ce000d6e9bd175430d8f702a82c31088d837bfd186bd7fa487d69287bab15f9dcfc28283b6f1609ffc5aa7adb2162b5d79005296d88eb11a67f11a2b3d48ee7b033dab3b356f0b5190598c49f55ba46545eff4912b3f12f66e1b51ec5f5fefc328265b01730d4f6a327d2520f2c0cc6f3e7ae2a8a540c76e2653df1d0bda51160238557f34823581f0cca333c196b8fcbb2b8ae2866a2679dac06acdd3e3a6c94e31c161debb6e05ff6fd902d3bb2cc41b3f490ec23264313f45c1cee5808f3bc2ba44dd8839c35c6f234ac1a9e1cb005394b38717902df26296e0f1b0dc59b448ac2139d8c185841d94c637a7e39b0f9998a05131ae42759aa1de40535770a4ce67033c1bd19adc2b265d66600193d5a88b472b24118209bb808e351d6820a502b7f172e844ed4896be33ee13635b21f17d3803d3857c25200755add134a175139a4f019b3b3dfc6200696752fa5cdd2d5ec64f602335ddedbe19d35cea7d8f0ce6ef79f0c111c610429e8c75e662e321fab9ca7922f1d8ba7fe2d04cb0929278ba1bcaa74e0974377d6474b25e55d25ac3070ae56b6b3dd34a2cb0b4f49c4427ef5d202df213aec9c4d368abb81ddfe9bf96946dfee5c848c6436dbd1a2eb28138efd3a9a5ee8cec98a03f2d177f94ed2725068fdd8a78ab9aa9858bcbaa518f935643dc7e860c4cea48b65d9e60411e132935ff18a9d1c0f14f12f6e5a05c0a26e34be8daf533160bf72bcc08a51b6db0b9270ded0f1d443639b848cfc94552b463e91483cd1335f899f9e73f5cceab378c8acb46e151edd94c76328a977e1a4e597f12ac3e44ee803c260e7df2b119171ebe71cbb39985c662a53efdae41af5ba7dbda5abb9dbb557ac45cf384107ad977d6beb0520e046b1ffe08c47ea8354450d84be976dcd635370b084ae4816f228cc54cf675616a6f7da79712a5b1a61d2d45fe579ecc14525eb714b7f4dbc9eaf11c5e28e4bfd883f9b5d96bf5ad2570ec782ed4d74506756ec5f12d4a620a3ebb94038da65678d0a7eeb9fb848f33622da6e0ad48476c0ceb2af0fd62f300eaee21d7c404e049c3092bdaa1a2349b162780335b7b89a460831b9d59e046ae47d76723bd17e63d0fd17a8cb23c464ddaaf4f75e7ab8f375b30fb57fdc36c53cec0d550cfe552f7e861ccf248425ff242b5f4f5e160b52bce5860466fbe15f85f380fcd14f661daf85f5d4edf836d43100b113f57c4089b912b12d04a1cbc6b849ca835cfaa9d867abb4ac02909453aabc113adf021ab20f9fb5dc5a6227ffd49d1148fe4b5adc29b95090f1c8d166d31832002795adaa8a1a0e2a5d422fb19cf608a8782428283e46b45bcec67b3a44e2d13a11589406f241cbfeb110ea42f1eb6fa1de7d4debded100beed23d43fdfba90de3d1263ed9c8fb25cd10ba54fd2996908804dc31b1b4815528ac67e306646e9c4c95f42263b7325172877e9276fe6156398e03e16c465a387219aab3b7fc8dccfed3fc7677d6090be96b65784141f0ad4eed1e9a1561e83bc1b8f95d1315d1c118b7c2bec98f8178e534021bebe2973b2cb555e4102c4d2eac61cbd19022162613635bbeb4c2f7c91b2f0cba846e9d2f0cc2cf1d9c6702333e0d51f66e246604eaaa444148866c3c9ffd3d8de3a0ade49b72051b5105efeffc68c1f27f3ee131db140aae9ce2d7e242dc4834ef01a817a45fb142bc61334c424172fe5873313ec9570da3d4b433772160d78fedbf357a41cdc7f4402ca55f8a8617ba4593e6bb536ba13f348914b100cc9a352e8af3481acd9466f9b957f7d443e04594a86b00c5286e294fe22d1cbf66d598763d9ba5d9bb7e2c0560751244a67592ea8e0b71ab0055a42d25ee8800b8dda87758a1883b2e69b2ba1e611c6e4e082f354b7a59d55dafe0989fec20a28c90657199fb712a45217b9026331c82207216a8a7a2d3d32d1dbfe10eec80d6861f9993135da78ecf291d65e0ef5861a57b9aef4e3987aba45d4422eb9e3e5b0547f8cfe5275463ddf2260bb304deee38eca342edb2ffbeab92da90bc05af6f7290226d044b6c27d1069bd7595c8a20617acbc8b9947e9e5f4da945b7ac75626015caa0d9e29805f749e535e8edf114ce277de5355de9542b7aa54b547432a6129d3fc6d094a9199338870746d02e643819dc6ea01797cb96f3ce18fcef05a3e7cfde2cda910e5e328af8872d2388c8fac81fb8e2a016236fe637b33112c9d3f57b1e0f3b666d2a4a9a24a704a0a003538248f8bd8f578c163b9ab66d843b86a3803ccd80e2ae09c31b465a43c13267e1b5ce58db3f156f2dfe7a50060ec11c5a9ac173078eaf71c8598ad92834347bb414bd472d5386676da3df4a1dd16a17a00fa7b5759642288de44f9cdb2a723976bfd60914348b56d317fcdc9aeaa278330b07af429de232c54daaca1253e363816b844e87b753b2f4e44b974e05bdc3b6467b9dde387c7611b2d8d8d1ebef7c7250bb4785265008f2b2ce56235cf011e8b0556fa64e7f86e599b9d0b57f316f832c78be4af70f78b11b12dca358cff7811527997916b47d16aa491379e8f91f181472477a8d17fe2c7e8dccd991a2420baa6b774ced8630096020b4d84acb269f835ec2586f5a7c91640b025d7c69d2f6140cd5ba9c158861d7c9950f34b103d5ad8149914822a232fe64e0a9eaa2d71d6d2eacfa9977b78280e35ab0cf57ae3fa0ac99a579610c00c31d68113764c991b53f54c8962fff6be3752a21659f9f4786aaf07ebf8b31fbd7f94be693e9114f9be5db073c51e1b326e69f962fa6dc5b7431ad883a52c2340facb839699c833eb4b4ec0581a1319edd51ba3703308760a6156c2bb854ce1f789b0acde0afc16f129e96d53e278cd71ecf744f43a62128a1c2c2fd705f01da1576cbcbda9b81949ae021a0ecff0b9b0414aac04808bac57ccda5509d5fda23a03c74c9ba83bf7ab08fe42328e31f9c23f823ec3e9cc19225f0814525b85bd6f0d4b95811ea1b3143fa64b68bc71a1500a40b5ff8d53b4650afbb90ec06672225f895ce9af88b60dc1e0d9a96190355d10e4de82875eae271aaf537b02b4e0da2599edc7f35cce258af286b8158c5050f1f7cca2cedb133ced3edc196d2c5c535361bccae709c5a8711ae973f9612ec64aebc98d4dc1fe5c06d446183f2c1a1c87bcb6f099c36d2286eefbccc7e1405a0d3aba0c1352833fb7ea26e46e8f23dedf6db9d0591b2ff28bee06cdc7b9fd1de56fa47f0ad1e0d237e6d444991d3c37ddfd345a4ecd461a194007d1d8294589c81e59183fa58f2006b6dc72ceca1ca4ee137614a3f2ee0603860030304016558e99593ad9f6e0092865ec7d89519ebf73fe6acd73fc8ad806d87cb8396408dc7a9e5fa3473c599fb484d850afb63f1d00c57d89a0931ea266ed34b731a12fb6ff99e9ad78ef79190fc323790d66477038d6a745031865c07968b07d8ccfd7c9fc402bdc1864afad06a2634265fafb6a89415dc0c0db1fce1e5a764c23b7bbc33d8b97d9362cdffe53741a8d73d7b56428bcd8502c0ff3564c789d3896e81f42eeace43c13ae93368639363e9f2f6d3e42186fa2755303cb4ee727376be9563a8f7228c18891ac506505bec443e0ff59058633a61ec74ac9277c0c6fc24ca5b0b38d012158cc48a035fd6257235ec143965bc2e21bd0e95eb0d1a6e257890dc349f2c0cae86c1e33c75d81bddd0cba50019f00a43bb7f591e24bca0ee18687f3609f36c4343464d9d5f1d57229f28e321fc66837877d6be5fb1bfb04de7d51b35df6106f842f204d6fb7a6582b252ab0bb09569a9c05a79aeb838f03f8fff668ba9696bcadd7ff43cc1acea348620a77f2a0cd9e1b994fa6461ae8e2baf3a2057b7a74cc7cf95884ff6d65800a7236ab8e2b6b12136f2e6a8844125c0cfd70b377ca786d7beba40050926f80d4501f2ddd31dfbf756908ca0defdc662845480f520ba86e11bec801d5b10aee39b4082e3bfeb5801bea63d014bc59af4ca26a1bbc6411f289c1c4120c7b60abf37153cc6def9607bcc0b4263325de335efd79ec43ef259b0c570e746b83ebc0544051018762efe56336ecbf2be3d17da1108201bd60e0c77cd0828c779abcbc2cd507ab3842b431f88db0a221d80960c96e27fc9bf29d9010347d45cabd7486eb15d5dbaff7a4bb904429ac228c87b87767fa7778eff6c4c955c6a694379b7ba201a468cd6a434ab40339bd3b652043f58a140b1296a1ed5b59002224e16c922f3d8900e09474cf714d2d7cb300180defac5ed8e5574039a5781ae998a1884508137c710ed7ab9ac3f613b63173b711c869ea0cd158fb07119607653d43a6a6990dd44d56c1b975b7ca566195936b9f6c1066bc17c29f7fcb64a910e32238aa6be56799e429b997ffa8bf66ba6cd0e1d0fa10572e64a61a11fd8748c353e6275ed2f6a118f03eb032fdbe19c07f291b8f4ff5c01500b354b5bdec0c8ed2c9fcd7c36ed2481527f3ddbf26ab88d2ad4a2e5676d960971df86874a8cf693be0e42a6253dbdf4a9df6d46622e4912d8aa2f287374761cc4039472b0b6f404adf85d1ee0d62b925dec6162e2607a9b9c0c492a086eee04b485984e47b9fae22b6a2de92cbef70c0b316320a7a643b199e8f0ab956af8f053ad41bed25fbf537edcefb261a06aefa13e78230796c75d1c23f2ea9196986da3c7c1c79db321a6bfac33219f6d8688e73e3d623bc7ee5b1fe972bd60df6af41e637b6c3bc2cd4f5aa6c94a8b5269d03e155f637dc767f93265ed32c7049c87b3866ef28eb899c613faf055a4071cd7596c49121c7a2573c3f1b96954214b481ec4b25d54bf9ccbccb1e4739711f5d711ea9cf009d696ff7aa6ca9bc15d39969539e602fc6fbabf1f2f8fae6f09e949b75ae0bf82c434061619c6aa6d6fcd10b88a72c9400cdf4dc49934d9e7365f5ab8470668323ad742d5caabdfdf9f2db0dba1d373be0fda5fe46382db3205dcf87ecc2d4c44d07c29921b069d7abdc977cddfbd8506e84e947035b26fb2f2fe8d08ec5d6791118eb5524b5397f5158f359f8f1586ed35756dd80fccb7215cbacc30dbfc5beaf76a680419ebc69829090d0f051f4469395760cb52f7eb1b35821e159ef0318fb52b47f815c3727e2054bd44a7ec59779900514614c471039fe32373f80dbe2457c05f43345871add008a66bb571e71e0db306434438ca829deb917b5bc1611bec0aa9b6871d38bbed2dc78e85aea995c6cf194795ae96dd1cbabc6723209273000563bcc499fd148493959d29ca7ee016afa334580417c703cc6bd063e3230440aa0179457ca131ea4b78fbf7fe4d7f438b0253790949286ca33c958cf031cf965e532b407e8065b0c70150b83ca68213a5f3810faebd65956f4eda0ebd6fe22ff13409776888da225e839050910269ddfbd4561f3a5b574df5e689c9fd197c0e2ae6d1ece17778f8bbe18ed300c97ef5d3c49326e68f483e0c0f138b956333568af2b3b4685eadbd40947b819430a2afc7d35c39a572727d9d747f267f46252ad1747d60b8d6cf6d8c44af6de49f60aac64f8125fb30d063c1d50f8a3174b67c1cce72bc40d909bc462754b27538e127cfb4e7b7c2845149e631367ac25fea4998656f3b55af2a1a29c61c4951078a3b2ace4517b2526f3e799101391a2ea5f163d6cb2a3d2c173ce3dcc83b8f1fa78174bdb248518fa4c49fea9e75e06c927e1cfcf27fbd2edfe7f70078f2c31148d5a39d3d16cfc9dc93ea70c2bfd55216e374d66f129eb07fc8f904f604c40c470bb26aa4ec99f8072622ddd213a065796cdae5d0778c500c64a4a80187bec107a373789be6e9b00be1bbf276b89868823ff8f2171262b7849dd8dc6cdb82882ef4491a58324af63de4b45c942b6e53463102016a4fbf73ca545d469bf64a12bb3cf220e836c38ac8b0421bd42df1437eadb52bfc8863fed3367525000a07ac012862feeb46021a72129f8983f38f4e374209c0ea6f8c388391c766f528208f7b51</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> 作为日记加密 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web开发技术复习整理</title>
      <link href="/2022/11/16/Web%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/"/>
      <url>/2022/11/16/Web%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="Web前端"><a href="#Web前端" class="headerlink" title="Web前端"></a>Web前端</h1><h2 id="src和href的区别"><a href="#src和href的区别" class="headerlink" title="src和href的区别"></a>src和href的区别</h2><p>href标识超文本引用，用在link和a等元素上，href是引用和页面关联，是在当前元素和引用资源之间建立联系</p><p>src表示引用资源，表示替换当前元素，用在img，script，iframe上，src是页面内容不可缺少的一部分。</p><p>src是source的缩写，是指向外部资源的位置，指向的内部会迁入到文档中当前标签所在的位置；在请求src资源时会将其指向的资源下载并应用到当前文档中，例如js脚本，img图片和frame等元素。</p><script src="js.js"></script>当浏览器解析到这一句的时候会暂停其他资源的下载和处理，直至将该资源加载，编译，执行完毕，图片和框架等元素也是如此，类似于该元素所指向的资源嵌套如当前标签内，这也是为什么要把js饭再底部而不是头部。<link href="common.css" rel="stylesheet"/>当浏览器解析到这一句的时候会识别该文档为css文件，会下载并且不会停止对当前文档的处理，这也是为什么建议使用link方式来加载css而不是使用@import。<h2 id="HTML-5-lt-DOCTYPE-gt-标签"><a href="#HTML-5-lt-DOCTYPE-gt-标签" class="headerlink" title="HTML 5 &lt;!DOCTYPE&gt; 标签"></a>HTML 5 &lt;!DOCTYPE&gt; 标签</h2><!DOCTYPE><p> 声明必须位于 HTML5 文档中的第一行，也就是位于 <html> 标签之前。该标签告知浏览器文档所使用的 HTML 规范。</p><p>doctype 声明不属于 HTML 标签；tag; 它是一条指令，告诉浏览器编写页面所用的标记的版本。</p><p>在所有 HTML 文档中规定 doctype 是非常重要的，这样浏览器就能了解预期的文档类型。</p><p>注释：&lt;!DOCTYPE&gt; 标签没有结束标签！</p><p>提示：&lt;!DOCTYPE&gt; 对大小写不敏感。</p><h2 id="粗体"><a href="#粗体" class="headerlink" title="粗体"></a>粗体</h2><p>产生粗体字的HTML标签为<b></p><h2 id="html实体符号编码解析"><a href="#html实体符号编码解析" class="headerlink" title="html实体符号编码解析"></a>html实体符号编码解析</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">!　　　　&amp;excl;&amp;#33;</span><br><span class="line">&quot;　　　　&amp;quot;&amp;#34;</span><br><span class="line">#　　　　&amp;num;&amp;#35;</span><br><span class="line">$　　　　&amp;dollar;&amp;#36;</span><br><span class="line">%　　　　&amp;percnt;&amp;#37;</span><br><span class="line">&amp;　　　　&amp;amp;&amp;#38;</span><br><span class="line">&#x27;　　　　&amp;apos;&amp;#39;</span><br><span class="line">(　　　　&amp;lpar;&amp;#40;</span><br><span class="line">)　　　　&amp;rpar;&amp;#41;</span><br><span class="line">*　　　　&amp;ast;&amp;#42;</span><br><span class="line">+　　　　&amp;plus;&amp;#43;</span><br><span class="line">,　　　　&amp;comma; &amp;#44;</span><br><span class="line">-　　　　&amp;hyphen; &amp;#45;</span><br><span class="line">.　　　　&amp;period;&amp;#46;</span><br><span class="line">/　　　　&amp;sol; &amp;#47;</span><br><span class="line">:　　　　&amp;colon;&amp;#58;</span><br><span class="line">;　　　　&amp;semi;&amp;#59;</span><br><span class="line">&lt;　　　　&amp;lt;&amp;#60;</span><br><span class="line">=　　　　&amp;equals;&amp;#61;</span><br><span class="line">&gt;　　　　&amp;gt;&amp;#62;</span><br><span class="line">?　　　　&amp;quest;&amp;#63;</span><br><span class="line">@　　　　&amp;commat; &amp;#64;</span><br><span class="line">[　　　　&amp;lsqb; &amp;#91;</span><br><span class="line">\　　　　&amp;bsol; &amp;#92;</span><br><span class="line">]　　　　&amp;rsqb;&amp;#93;</span><br><span class="line">^　　　　&amp;circ;&amp;#94;</span><br><span class="line">_　　　　&amp;lowbar;&amp;#95;</span><br><span class="line">`　　　　&amp;grave;&amp;#96;</span><br><span class="line">&#123;　　　　&amp;lcub;&amp;#123;</span><br><span class="line">|　　　　&amp;verbar;&amp;#124;</span><br><span class="line">&#125;　　　　&amp;rcub;&amp;#125;</span><br><span class="line">~　　　　&amp;tilde;&amp;#126;</span><br></pre></td></tr></table></figure><h2 id="书签"><a href="#书签" class="headerlink" title="书签"></a>书签</h2><p>在HTML中定义一个书签应该使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;#C4&quot;&gt;Jump to Chapter 4&lt;/a&gt;</span><br></pre></td></tr></table></figure><h2 id="html创建电子邮件链接"><a href="#html创建电子邮件链接" class="headerlink" title="html创建电子邮件链接"></a>html创建电子邮件链接</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;mailto:xxx@yyy&gt;</span><br></pre></td></tr></table></figure><h2 id="网页中一般使用的图片格式"><a href="#网页中一般使用的图片格式" class="headerlink" title="网页中一般使用的图片格式"></a>网页中一般使用的图片格式</h2><p>常用的图片格式有JPG、GIF、PNG。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">一、JPEG</span><br><span class="line"></span><br><span class="line">适用于：照片和复杂图像使用</span><br><span class="line"></span><br><span class="line">特点： 1.适合连续色调图像，如照片。</span><br><span class="line"></span><br><span class="line">       2.可以表示包含多达1600万种不同颜色的图像。</span><br><span class="line"></span><br><span class="line">       3.在缩小文件大小时会丢掉图像信息，是一种“有损”格式。</span><br><span class="line"></span><br><span class="line">       4.不支持透明度。</span><br><span class="line"></span><br><span class="line">       5.文件比较小，以便Web页面更高效的显示。</span><br><span class="line"></span><br><span class="line">       6.不支持动画。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">二、PNG</span><br><span class="line"></span><br><span class="line">适用于：单色图像和线条构成的图像（如logo，剪贴画和图像中的小文本）</span><br><span class="line"></span><br><span class="line">特点：1.可以表示上百万种不同颜色的图像、PNG有3种：PNG-8、PNG-24、PNG-32.取决于需要表示多少种颜色。</span><br><span class="line"></span><br><span class="line">           2.会压缩文件来缩小文件大小，不过不会丢掉信息。是一种“无损”格式。</span><br><span class="line"></span><br><span class="line">    3.允许将颜色设置为“透明”，使图像下面的东西可以显示出来。</span><br><span class="line"></span><br><span class="line">         4.与相应的JPEG文件相比，PNG文件更大一些，不过取决的与使用的颜色数，可能比相应的GIF文件小，也可能更大。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">三、GIF</span><br><span class="line"></span><br><span class="line">适用于：类似于PNG,GIF最适合单色图像和线条构成的图像（如logo，剪贴画和图像中的小文本）</span><br><span class="line"></span><br><span class="line">特点：  1.GIF可以表示最多256中不同颜色的图像。</span><br><span class="line"></span><br><span class="line">          2.GIF也是一种“无损”格式。</span><br><span class="line"></span><br><span class="line">      3.GIF也支持透明度，不过只允许一种颜色设置为“透明”。</span><br><span class="line"></span><br><span class="line">      4.GIF往往比相应的JPEG文件大。</span><br><span class="line"></span><br><span class="line">      5.支持动画。</span><br></pre></td></tr></table></figure><h2 id="用于播放html5视频文件的标签"><a href="#用于播放html5视频文件的标签" class="headerlink" title="用于播放html5视频文件的标签"></a>用于播放html5视频文件的标签</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;video&gt;</span><br></pre></td></tr></table></figure><h2 id="＜audio＞标签支持的音频格式"><a href="#＜audio＞标签支持的音频格式" class="headerlink" title="＜audio＞标签支持的音频格式"></a>＜audio＞标签支持的音频格式</h2><p>wav, mp3, ogg, acc, webm</p><h2 id="CSS三种样式表及其使用（内部样式表，行内样式表，外部样式表）"><a href="#CSS三种样式表及其使用（内部样式表，行内样式表，外部样式表）" class="headerlink" title="CSS三种样式表及其使用（内部样式表，行内样式表，外部样式表）"></a>CSS三种样式表及其使用（内部样式表，行内样式表，外部样式表）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">内部样式表是将CSS代码写在HTML文档的head标签中，并且用style标签定义</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">      选择器&#123;属性1:属性值1;属性2:属性值2;属性3:属性值3;&#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line"></span><br><span class="line"> （1）style标签一般位于head标签中title标签之后，也可以把他放在HTML文档的任何地方.</span><br><span class="line"> （2）type=&quot;text/CSS&quot;在HTML中可以省略.</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">内部样式表是将CSS代码写在HTML文档的head标签中，并且用style标签定义</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">      选择器&#123;属性1:属性值1;属性2:属性值2;属性3:属性值3;&#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line"></span><br><span class="line"> （1）style标签一般位于head标签中title标签之后，也可以把他放在HTML文档的任何地方.</span><br><span class="line"> （2）type=&quot;text/CSS&quot;在HTML中可以省略.</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">外部样式表（外链式）</span><br><span class="line">链入式是将所有的样式放在一个或多个以.CSS为扩展名的外部样式表文件中，通过link标签将外部样式表文件链接到HTML文档中</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;link href=&quot;CSS文件的路径&quot;  rel=&quot;stylesheet&quot; /&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">注意：link是单标签</span><br><span class="line"></span><br><span class="line">link标签需要放在head头部标签中，并且必须指定link标签的三个属性</span><br><span class="line"></span><br><span class="line">（1）href:定义所链接外部样式表文件的URL，可以是相对路径，也可以是绝对路径</span><br><span class="line">（2）type:定义所链接文档的类型，在这里需要指定为&quot;text/css&quot;，表示链接的外部文件为CSS样式表。</span><br><span class="line">（3）rel:定义当前文档与被链接文档之间的关系，在这里需要指定为“stylesheet”,表示被链接的文档是一个样式表文件。</span><br></pre></td></tr></table></figure><h2 id="零碎知识点"><a href="#零碎知识点" class="headerlink" title="零碎知识点"></a>零碎知识点</h2><p>Web客户端在Internet上被称为浏览器，它一种用来浏览Web页面的软件</p><p>主页( Home Page)就是网站默认的首页。主页默认的文件名通常为 index.html或default.html</p><p>css指的是Cascading Style Sheets</p><p>结构与样式分离依赖于css</p><p>使用内部样式表示方法定义样式应该使用的标签是style</p><p>在html文档中，应用外部样式表的正确位置是<head>部分</p><p>链接到外部样式表使用的标签是link</p><p>当编写css时，不同属性应使用；分隔</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p &#123;</span><br><span class="line">  color: red;</span><br><span class="line">  text-align: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>位于<code> &lt;style&gt;</code> 元素内的 CSS 注释，以 &#x2F;* 开始，以 *&#x2F; 结束：</p><p>在css中设置文本属性text-indent 主要设置的是首行缩进</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">将段落的第一行缩进 50 像素：</span><br><span class="line">p</span><br><span class="line">  &#123;</span><br><span class="line">  text-indent:50px;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>字体粗细：font-weight</p><p>overflow:hidden 容器里的内容超出容器部分隐藏</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">文本阴影 text-shadow(参数1，参数2，参数3)</span><br><span class="line">参数1：阴影距文字左右距离</span><br><span class="line">参数2：阴影距文字上下距离</span><br><span class="line">参数3：阴影的模糊程度</span><br></pre></td></tr></table></figure><p>设置超级链接没有下划线</p><p>a{<br>text-decoration:none<br>}</p><h2 id="CSS尺寸设置的单位"><a href="#CSS尺寸设置的单位" class="headerlink" title="CSS尺寸设置的单位"></a>CSS尺寸设置的单位</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">px：pixel像素的缩写，绝对长度单位，它的大小取决于屏幕的分辨率，是开发网页中常常使用的单位。</span><br><span class="line"></span><br><span class="line">em：相对长度单位，在 `font-size` 中使用是相对于父元素的字体大小，在其他属性中使用是相对于自身的字体大小，如 width。如当前元素的字体尺寸未设置，由于字体大小可继承的原因，可逐级向上查找，最终找不到则相对于浏览器默认字体大小。</span><br><span class="line"></span><br><span class="line">rem：相对长度单位，相对于根元素的字体大小，根元素字体大小未设置，使用浏览器默认字体大小。</span><br><span class="line"></span><br><span class="line">vw：相对长度单位，相对于视窗宽度的1%。</span><br><span class="line"></span><br><span class="line">vh：相对长度单位，相对于视窗高度的1%。</span><br></pre></td></tr></table></figure><h2 id="行内元素和块级元素"><a href="#行内元素和块级元素" class="headerlink" title="行内元素和块级元素"></a>行内元素和块级元素</h2><p>1、行内元素：a img span b strong input select section </p><p>b, big, i, small, tt<br>abbr, acronym, cite, code, dfn, em, kbd, strong, samp, var<br>a, bdo, br, img, map, object, q, script, span, sub, sup<br>button, input, label, select, textarea</p><p>2、块级元素：div p table ul lo li h1-h6 dl dt </p><p>3、空元素：br hr img input link meta</p><p>区别：</p><p>1、块级元素会独占一行 默认的宽度占满父级元素，行内元素不会换行</p><p>2、行内元素的width height 无效</p><p>3、块级元素可以设置margin和padding属性，行内元素padding-left、padding-right，margin-left，margin-right（水平方向），有边距效果，padding-top，padding-bottom，margin-top，margin-bototm，（垂直方向）没有边距效果，</p><p>本质（浏览器将块级元素的dispaly属性默认为block，行内元素属性默认为inline，因此行内元素与块级元素的切换可以通过修改display属性实现）</p><h2 id="在页面上引用脚本文件js-js"><a href="#在页面上引用脚本文件js-js" class="headerlink" title="在页面上引用脚本文件js.js"></a>在页面上引用脚本文件js.js</h2><script src="js.js"  type="text/javascript"></script><h2 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h2><p>方法get()的作用使用 http get 请求从服务器接口加载数据</p><p>fadeIn()方法可以逐渐改变被选元素的不透明度，从隐藏到可见（褪色效果）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">以下P标签经过Jquery以下操作后的标签将变成</span><br><span class="line">&lt;p&gt;你好&lt;/p&gt;</span><br><span class="line">$(&#x27;p&#x27;).append(&quot;&lt;b&gt;西南石油大学&lt;/b&gt;&quot;);</span><br><span class="line">&lt;p&gt;你好&lt;b&gt;西南石油大学&lt;/b&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用Jquery给按钮添加点击事件的代码正确的是</span><br><span class="line">&lt;input id=&#x27;btnSure&#x27; type=&#x27;button&#x27;   value=&#x27;确定&#x27;&gt;</span><br><span class="line">$(&#x27;#btnSure&#x27;).click(function()&#123;</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><h2 id="javaScript"><a href="#javaScript" class="headerlink" title="javaScript"></a>javaScript</h2><p>javaScript是运行在<strong>客户端</strong>的脚本语言。</p><p>在JavaScript中，把字符串”123”转换为整型值123的正确方法是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var str=&quot;123&quot;;</span><br><span class="line">var num=parseInt(str);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">在<span class="title class_">JavasScript</span>中，若要实现复选框全选功能，则在横线处填写的代码应为<span class="variable language_">document</span>.<span class="title function_">getElementsByName</span>(<span class="string">&quot;chk&quot;</span>);</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">  function allChecked( )&#123;</span><br><span class="line"></span><br><span class="line">         var allck=__________</span><br><span class="line"></span><br><span class="line">         for(var i = 0 ;i&lt;allck.length;i++)&#123;</span><br><span class="line"></span><br><span class="line">                   allck[i].checked=true;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;&lt;input name=&quot;chk&quot; type=&quot;checkbox&quot; value=&quot;滑雪&quot;&gt;滑雪</span><br><span class="line"></span><br><span class="line">&lt;p&gt;&lt;input name=&quot;chk&quot; type=&quot;checkbox&quot; value=&quot;游泳&quot;&gt;游泳</span><br><span class="line"></span><br><span class="line">&lt;p&gt;&lt;input name=&quot;chk&quot; type=&quot;checkbox&quot; value=&quot;爬山&quot;&gt;爬山</span><br><span class="line"></span><br><span class="line">&lt;p&gt;&lt;input name=&quot;btn&quot; type=&quot;button&quot; onClick=&quot;allChecked( )&quot; value=&quot;选择&quot;&gt;</span><br></pre></td></tr></table></figure><p>getElementsByTagName() 方法可返回带有指定<strong>标签名</strong>的对象的集合。(比如input)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">javascript获取div中的文本信息<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;one&quot;</span>).<span class="property">innerHTML</span>;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;one&quot;</span>&gt;</span>西南石油大学<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="variable language_">document</span>).<span class="title function_">ready</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">&#125;)</span><br><span class="line">html元素加载完成后自动执行，主要用于一些初始化工作</span><br></pre></td></tr></table></figure><p>JavaScript是支持对象的编程语言</p><h3 id="JavaScript-关键字"><a href="#JavaScript-关键字" class="headerlink" title="JavaScript 关键字"></a>JavaScript 关键字</h3><table><thead><tr><th align="left">break<br/>case<br/>catch<br/>continue<br/>default<br/>delete<br/>do<br/>else<br/>finally<br/>void<br/>while<br/>with</th><th align="left">for<br/>function<br/>if<br/>in<br/>instanceofnew<br/>return<br/>switch<br/>this<br/>throw<br/>try<br/>typeof<br/>var</th></tr></thead><tbody><tr><td align="left"></td><td align="left"></td></tr></tbody></table><h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><p>XML（Extensible Markup Language），可扩展标记语言。是一种用于标记电子文件使其具有结构性的标记语言。</p><h3 id="XML特点"><a href="#XML特点" class="headerlink" title="XML特点"></a><strong>XML特点</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1）XML可以从HTML中分离数据。即能够在HTML文件之外将数据存储在XML文档中，这样可以使开发者集中精力使用HTML做好数据的显示和布局，并确保数据改动时不会导致HTML文件也需要改动，从而方便维护页面。XML也能够将数据以“数据岛”的形式存储在HTML页面中，开发者依然可以把精力集中到使用HTML格式化和显示数据上。</span><br><span class="line">（2）XML可用于交换数据。基于XML可以在不兼容的系统之间交换数据，计算机系统和数据库系统所存储的数据有多种形式，对于开发者来说，最耗时间的工作就是在遍布网络的系统之间交换数据。把数据转换为XML格式存储将大大减少交换数据时的复杂性，还可以使这些数据能被不同的程序读取。</span><br><span class="line">（3）XML可应用于B2B中。例如在网络中交换金融信息， 目前XML正成为遍布网络的商业系统之间交换信息所使用的主要语言，许多与B2B有关的完全基于XML的应用程序正在开发中。</span><br><span class="line">（4）利用XML可以共享数据。XML数据以纯文本格式存储，这使得XML更易读、更便于记录、更便于调试，使不同系统、不同程序之间的数据共享变得更加简单。</span><br><span class="line">（5）XML可以充分利用数据。XML是与软件、硬件和应用程序无关的，数据可以被更多的用户、设备所利用，而不仅仅限于基于HTML标准的浏览器。其他客户端和应用程序可以把XML文档作为数据源来处理，就像操作数据库一样，XML的数据可以被各种各样的“阅读器”处理。</span><br><span class="line">（6）XML可以用于创建新的语言。比如，WAP和WML语言都是由XML发展来的。WML(Wireless Markup Language，无线标记语言)是用于标识运行于手持设备上（比如手机）的Intemet程序的工具，它就采用了XML的标准。</span><br></pre></td></tr></table></figure><p>XML使用一个简单而又灵活的标准格式，为基于Web的应用提供了一个描述数据和交换数据的有效手段。但是，XML并非是用来取代HTML的。HTML着重如何描述将文件显示在浏览器中，而XML与SGML相近，它着重描述如何将数据以结构化方式表示。</p><p>XML与HTML的区别：</p><ol><li>可扩展性方面：HTML不允许用户自行定义他们自己的标识或属性，而在XML中，用户能够根据需要自行定义新的标识及属性名，以便更好地从语义上修饰数据。</li><li>结构性方面：HTML不支持深层的结构描述，XML的文件结构嵌套可以复杂到任意程度，能表示面向对象的等级层次。</li><li>可校验性方面：HTML没有提供规范文件以支持应用软件对HTML文件进行结构校验，而XML文件可以包括一个语法描述，使应用程序可以对此文件进行结构校验。</li></ol><p>XML对数据进行描述的方式  XML使用DTD来描述数据</p><p>定义XML版本的声明中语法正确的是<?xml version="1.0"?></p><p>DTD指的是Document Type Definition</p><p>XML标签对大小写敏感<br>XML文档必须有根标签<br>XML元素必须被正确地嵌套</p><p>XSL指的是eXtensible Stylesheet Language</p><h3 id="XML语法格式"><a href="#XML语法格式" class="headerlink" title="XML语法格式"></a><strong>XML语法格式</strong></h3><ol><li>必须有声明语句     <?xml version="1.0" encoding="utf-8"?><br>version：版本号，推荐使用主流版本1.0，1.1版本不向下兼容。<br>encoding：编码方式，告知解析引擎当前文档使用的字符集。·<br>standalone：是否独立，yes和no两个值，是否依赖其他文件。</li><li>注意大小写。在XML文档中，大小写是有区别的。注意在写元素时，前后标记的大小写要保持一致。最好养成一种习惯，或者全部大写，或者全部小写，或者大写第一个字母，这样可以减少因为大小写不匹配而产生的文档错误</li><li>XML文档有且只有一个根元素。</li><li>属性值使用引号。在HTML代码里面，属性值可以加引号，也可以不加。但是XML规定，所有属性值必须加引号（可以是单引号，也可以是双引号，建议使用双引号），否则将被视为错误。</li><li>所有的标记必须有相应的结束标记。</li><li>所有的空标记也必须被关闭。</li></ol><h3 id="XML-元素必须遵循以下命名规则："><a href="#XML-元素必须遵循以下命名规则：" class="headerlink" title="XML 元素必须遵循以下命名规则："></a>XML 元素必须遵循以下命名规则：</h3><p>（1）名称可以含字母、数字以及其他的字符。<br>（2）名称不能以数字或者标点符号开始。<br>（3）名称不能以字符 “xml”（或者 XML、Xml）开始。<br>（4）名称不能包含空格。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">users</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">user</span> <span class="attr">id</span>=<span class="string">&quot;u1&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Atlantis<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>23<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sex</span>&gt;</span>男<span class="tag">&lt;/<span class="name">sex</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">user</span> <span class="attr">id</span>=<span class="string">&quot;u2&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>长安<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>21<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sex</span>&gt;</span>女<span class="tag">&lt;/<span class="name">sex</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">users</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="XML约束"><a href="#XML约束" class="headerlink" title="XML约束"></a>XML约束</h3><p>在XML技术里，可以编写一个文档来约束一个XML文档的书写规范（与xml语法无关），这称之为XML约束。目的是为了保证数据的规范性和安全性。</p><p>两种约束<br>（1）DTD约束：语法简洁，共能比较单一。文件后缀名.xml<br>（2）Schema约束：语法复杂，功能比较强大。文件后缀名.xsd</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- ELEMENT定义标签 --&gt;</span><br><span class="line">&lt;!-- users (user*)：定义了一个users标签，该标签内可以出现0次或多次子标签user --&gt;</span><br><span class="line">&lt;!ELEMENT users (user*) &gt;</span><br><span class="line">&lt;!-- user (name,age,sex)：定义了一个user标签，仅可分别按顺序依次出现1次name、age、sex标签 --&gt;</span><br><span class="line">&lt;!ELEMENT user (name,age,sex)&gt;</span><br><span class="line">&lt;!-- name (#PCDATA)：定义了一个name标签，该标签内可以出现字符串 --&gt;</span><br><span class="line">&lt;!ELEMENT name (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT age (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT sex (#PCDATA)&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- ATTLIST定义属性 --&gt;</span><br><span class="line">&lt;!-- user number ID #REQUIRED：在user标签内定义了一个number属性，ID表示number属性值必须唯一，#REQUIRED标签number属性必须出现 --&gt;</span><br><span class="line">&lt;!ATTLIST user id ID #REQUIRED&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">## css中的display属性有哪些值？各有什么作用？</span><br><span class="line"></span><br><span class="line">- none 此元素不会被显示。</span><br><span class="line">- block 此元素将显示为块级元素，此元素前后会带有换行符。</span><br><span class="line">- inline 默认。此元素会被显示为内联元素，元素前后没有换行符。</span><br><span class="line">- inline-block 行内块元素。（CSS2.1 新增的值）</span><br><span class="line">- list-item 此元素会作为列表显示。</span><br><span class="line">- run-in 此元素会根据上下文作为块级元素或内联元素显示。</span><br><span class="line">- compact CSS 中有值 compact，不过由于缺乏广泛支持，已经从 CSS2.1 中删除。</span><br><span class="line">- marker CSS 中有值 marker，不过由于缺乏广泛支持，已经从 CSS2.1 中删除。</span><br><span class="line">- table 此元素会作为块级表格来显示（类似 &lt;table&gt;），表格前后带有换行符。</span><br><span class="line">- inline-table 此元素会作为内联表格来显示（类似 &lt;table&gt;），表格前后没有换行符。</span><br><span class="line">- table-row-group 此元素会作为一个或多个行的分组来显示（类似 &lt;tbody&gt;）。</span><br><span class="line">- table-header-group 此元素会作为一个或多个行的分组来显示（类似 &lt;thead&gt;）。</span><br><span class="line"></span><br><span class="line">（视频教程推荐：[css视频教程](https://www.php.cn/course/list/12.html)）</span><br><span class="line"></span><br><span class="line">- table-footer-group 此元素会作为一个或多个行的分组来显示（类似 &lt;tfoot&gt;）。</span><br><span class="line">- table-row 此元素会作为一个表格行显示（类似 &lt;tr&gt;）。</span><br><span class="line">- table-column-group 此元素会作为一个或多个列的分组来显示（类似 &lt;colgroup&gt;）。</span><br><span class="line">- table-column 此元素会作为一个单元格列显示（类似 &lt;col&gt;）</span><br><span class="line">- table-cell 此元素会作为一个表格单元格显示（类似 &lt;td&gt; 和 &lt;th&gt;）</span><br><span class="line">- table-caption 此元素会作为一个表格标题显示（类似 &lt;caption&gt;）</span><br><span class="line">- inherit 规定应该从父元素继承 display 属性的值。</span><br></pre></td></tr></table></figure><h1 id="WebPPT知识"><a href="#WebPPT知识" class="headerlink" title="WebPPT知识"></a>WebPPT知识</h1><h2 id="第一章-Web开发技术概述"><a href="#第一章-Web开发技术概述" class="headerlink" title="第一章   Web开发技术概述"></a>第一章   Web开发技术概述</h2><h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><p>邮件服务器（收发电子邮件）、FTP服务器（文件传输）、域名服务器DNS（域名解析）和Web服务器（组织并展示相关的信息资源） 等。承担各种服务任务的计算机就叫做服务器。</p><p>互联网+：将互联网作为工具，让互联网与传统行业进行深度融合，创造新的发展生态。滴滴打车、支付宝等等</p><h3 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h3><ul><li>全称为World Wide Web，缩写为WWW译为“万维网”,简称为Web</li><li>是一个可通过互联网来访问的、由许多互相链接的超文本组成的系统。</li></ul><p>URI：Uniform Resource Identifier  统一资源标识符</p><p>HTTP: HyperText Transfer Protocol  超文本传输协议</p><p>Web 与 Internet的关系：Web不等于Internet，它只是Internet中的一个部分，而且和浏览器有关。以后只要提到Web，就一定是和浏览器有关的应用或其他事项。可以说Web是Internet中的一个子集或者说Web是互联网提供信息的一种手段。</p><h3 id="Web服务器"><a href="#Web服务器" class="headerlink" title="Web服务器"></a>Web服务器</h3><ul><li>又称WWW服务器、网站服务器、站点服务器或HTTP服务器</li><li>为用户提供信息浏览和信息处理服务。将信息用超文本（Hypertext）组织，为用户在Internet上搜索和浏览信息提供服务。</li><li>Web服务器实际上就是一个软件系统。但它必须安装在一台高性能和高可靠性的计算机上，所以人们通常将那台计算机就叫做Web服务器。</li></ul><p>常用的Web服务器有： ▪ Microsoft IIS  ▪ IBM  WebSphere ▪ Oracle  WebLogic        ▪ Apache 开源  ▪ Tomcat 开源             ▪ Jboss  开源▪ 金蝶公司 Apusic</p><p>要使一台计算机成为Web服务器，必须安装上述专门的信息服务程序，并且安装UNIX、Linux或Windows 2003&#x2F;2008&#x2F;2012 Server等网络操作系统。一台计算机可以安装多个Web服务器。</p><h4 id="为什么有些Web服务器需要花钱购买？"><a href="#为什么有些Web服务器需要花钱购买？" class="headerlink" title="为什么有些Web服务器需要花钱购买？"></a>为什么有些Web服务器需要花钱购买？</h4><p>IIS、Tomcat、Apache和Jboss等，支持的并发访问用户数有限，适合作中小型网站系统的Web服务器，而WebLogic、WebSphere和金蝶Apusic等专业Web服务器，在并发用户大量增加的情况下，仍可保持较高的处理性能，适合作大型网站系统的Web服务器。购买专业版时又区分5用户、10用户、25用户、100用户的Web服务器，是指Web服务器最大支持的并发用户数。</p><h3 id="Web页面"><a href="#Web页面" class="headerlink" title="Web页面"></a>Web页面</h3><p>Web在提供信息服务之前，所有信息都必须以文件方式事先存放在Web服务器所管辖磁盘中某个文件夹下，其中包含了由超文本标记语言（HyperText Markup Language，HTML）组成的文本文件，这些文本文件称为超链接文件，又称网页文件或Web页面文件（Web page）。</p><p>静态网页 HTM.HTML</p><p>动态网页 ASP.ASPX.JSP.PHP</p><p>扩展名为HTM或HTML的页面文件为静态页面，ASP、ASPX、JSP、PHP等页面文件为动态网页，或者叫Web服务器页面。Web服务器页面需要Web服务器对它们进行重新处理后，动态生成新的HTML页面再传送给客户端供用户浏览。例如服务器动态页面中大都需要进行数据库访问的请求与处理，要将获取的数据合并处理后形成新的网页传回给浏览器。</p><h3 id="统一资源定位符（URL）"><a href="#统一资源定位符（URL）" class="headerlink" title="统一资源定位符（URL）"></a>统一资源定位符（URL）</h3><p>信息资源放在Web服务器之后，需要将它的地址告诉给用户，以便让用户来访问，这个地址就叫统一资源定位符（Uniform Resource Locators，URL），俗称为网址</p><p>URL字串&#x3D;协议名称（通常为http、ftp、file等）+主机名+文件名（含路径）</p><p>example：</p><ul><li><a href="http://www.yahoo.com.cn/index.htm">http://www.yahoo.com.cn/index.htm</a> ，http:&#x2F;&#x2F;指采用的传输协议是http，<a href="http://www.yahoo.com.cn为主机名,/index.htm%E4%B8%BA%E6%A0%B9%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6%E3%80%82">www.yahoo.com.cn为主机名，/index.htm为根目录下的文件。</a></li><li>file:&#x2F;&#x2F;&#x2F;C:&#x2F;windows&#x2F;Sandstone.htm也是一个URL地址，指向本地C盘中Windows目录下的Sandstone.htm文件， “file:&#x2F;&#x2F;”指采用的直接文件方式访问； “&#x2F;C:&#x2F;windows&#x2F;Sandstone.htm”表示文件从根目录开始的路径</li></ul><p>URL是对可从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。</p><p>eg：</p><p>URL地址中的主机名也可直接输入对应的IP地址，例如输入：<a href="http://202.202.0.36/">http://202.202.0.36/</a> （有时也包括端口号 <a href="http://202.202.0.36:81/">http://202.202.0.36:81/</a> ）  Web服务器默认TCP端口号为80，用于监听有无页面请求。   <a href="http://202.202.0.36/">http://202.202.0.36:80/</a>   和  <a href="http://202.202.0.36/">http://202.202.0.36/</a> 等同。</p><h4 id="为什么有时URL地址中没有文件名还能照常显示页面内容呢"><a href="#为什么有时URL地址中没有文件名还能照常显示页面内容呢" class="headerlink" title="为什么有时URL地址中没有文件名还能照常显示页面内容呢"></a>为什么有时URL地址中没有文件名还能照常显示页面内容呢</h4><p>这是因为在Web服务器的配置中，可以事先设定一个或多个默认文件名，浏览器会自动查找这些默认的文件名。</p><h4 id="URI和URL的区别"><a href="#URI和URL的区别" class="headerlink" title="URI和URL的区别"></a>URI和URL的区别</h4><p>统一资源标识符URI是一个用于标识某一互联网资源名称的字符串。 Web上可用的每种资源 -HTML文档、图像、视频片段、程序等都可由URI来定位。 URL网址只是属于URI的一种，用来定位所需访问的网页地址。</p><p>eg</p><ul><li>URI、URL：<a href="http://www.yahoo.com.cn/index.htm">http://www.yahoo.com.cn/index.htm</a>  </li><li>URI: <a href="http://www.yahoo.com.cn/gif/stone.jpg">http://www.yahoo.com.cn/gif/stone.jpg</a></li></ul><p>href&#x3D;“..&#x2F;Shweather.htm” 也可写成   href&#x3D;“&#x2F;web&#x2F;Shweather.htm” </p><p>URI绝对地址可直接在浏览器中输入，访问相关资源；相对地址则不可用在浏览器地址栏 URI相对地址只能用在页面文件中</p><h4 id="为什么需要URI相对地址"><a href="#为什么需要URI相对地址" class="headerlink" title="为什么需要URI相对地址?"></a>为什么需要URI相对地址?</h4><p>当网站目录层次较多、内容较长时，可以简化书写，避免出错，也可减少页面文件的字节数。页面内容要在浏览器中显示，从Web服务器下载到客户端，页面中的每个字节都是网络流量的组成部分。</p><h3 id="Web浏览器的工作原理"><a href="#Web浏览器的工作原理" class="headerlink" title="Web浏览器的工作原理"></a>Web浏览器的工作原理</h3><p>Browser就是Web客户端程序，要浏览Web页面必须在本地计算机上安装浏览器软件，用于与Web服务器建立连接，并与之进行通信。浏览器根据访问地址确定信息资源的位置，并将用户感兴趣的信息资源取回来，对 HTML 文件进行解释，然后将文字图像显示出来，或者将多媒体信息还原出来。</p><h4 id="在网络带宽相同的情况下同一台计算机使用不同的浏览器访问同一个网站，为什么访问速度会不一样？"><a href="#在网络带宽相同的情况下同一台计算机使用不同的浏览器访问同一个网站，为什么访问速度会不一样？" class="headerlink" title="在网络带宽相同的情况下同一台计算机使用不同的浏览器访问同一个网站，为什么访问速度会不一样？"></a>在网络带宽相同的情况下同一台计算机使用不同的浏览器访问同一个网站，为什么访问速度会不一样？</h4><p>浏览器是个软件，是软件就有软件复杂度的问题，就有软件运行效率的问题，如算法是否先进，代码是否简洁有效等等，另外浏览器的安全级别的设置也会大大影响访问速度。如果安全级别高了，都要去检查当然就慢了。还有如果浏览器中加载了很多插件也会拖累浏览器。</p><h4 id="浏览器Cookie"><a href="#浏览器Cookie" class="headerlink" title="浏览器Cookie"></a>浏览器Cookie</h4><ul><li>浏览器和服务器之间是通过HTTP进行通信的。HTTP是一种无记忆的协议，即用户目前正在浏览的页面对在此之前浏览过的页面没有丝毫的记忆和了解。</li><li>实际情况是有时需要浏览器能够记住一些信息，且这些信息无需用户记住。</li><li>浏览器中引入了Cookie的概念，浏览器允许用户通过Cookie读写一些信息，这在一定程度上实现了浏览器的记忆功能。</li></ul><h4 id="https-x2F-x2F-与-http-x2F-x2F-的区别"><a href="#https-x2F-x2F-与-http-x2F-x2F-的区别" class="headerlink" title="https:&#x2F;&#x2F;  与  http:&#x2F;&#x2F; 的区别"></a>https:&#x2F;&#x2F;  与  http:&#x2F;&#x2F; 的区别</h4><p>HTTPS（Hyper Text Transfer Protocol over Secure Socket Layer安全套接字），是以安全为目标的HTTP通道，是HTTP的安全版。即HTTP下加入套接字SSL层，对传输的网页进行加密处理，被广泛用于安全敏感的通讯，例如交易支付方面。</p><h3 id="C-x2F-S模式与B-x2F-S模式"><a href="#C-x2F-S模式与B-x2F-S模式" class="headerlink" title="C&#x2F;S模式与B&#x2F;S模式"></a>C&#x2F;S模式与B&#x2F;S模式</h3><p>C&#x2F;S模式Client&#x2F;Server客户端&#x2F;服务器  需要下载安装运行的各种游戏软件   各种移动APP软件   Foxmail邮件客户端软件 ……</p><p>优点:可异种平台集成；分布式管理；能充分发挥客户端PC的处理能力；运行安全、稳定、速度快，且在适当情况下可脱机操作。</p><p>缺点或不足:必须在客户端安装大量的应用程序（客户端软件）；需要在客户端安装支持系统运行的动态链接库等；存在移植困难、用户界面风格不统一、操作复杂、不利于推广使用、维护和升级过程繁琐、信息内容和形式单一和不易应用新技术等不足。</p><p>B&#x2F;S模式Browser&#x2F;Server浏览器&#x2F;服务器  各种页游   网易126邮箱、163邮箱、Web QQ邮箱、 gmail邮箱等等   通过浏览器运行的各种业务系统 ……</p><p>B&#x2F;S模式是一种基于Web的协同计算模式，是一种三层架构的瘦客户机&#x2F;肥服务器的计算模式。在这种结构下，用户工作界面是通过Web浏览器来实现，少部分事务逻辑在前端（Browser）实现，主要事务逻辑在服务器端（Server）实现，形成所谓三层(3-tiers)结构。这样就大大简化了客户端电脑载荷，减轻了系统维护与升级的成本和工作量，降低了用户的总体成本（TCO）。</p><p>优点:具有良好的开放性；无需下载安装，利用浏览器单一的访问点，用户可在任何时间和地点使用系统；系统维护方便，有效地降低了整个系统的运行和维护成本。</p><p>缺点或不足:运行速度没有C&#x2F;S模式快，且受网络带宽的影响较大；会出现更多安全性问题。</p><p>注意点：面向大众的网站系统应尽可能多地被各种用户访问，需考虑浏览器的兼容性，还需考虑在网络带宽在有限和不稳定的情况下，仍然可被快速访问，因此除了考虑互联网上使用的安全性外，其稳定性、可靠性、有效性等也是网站开发中必须重点考虑的问题。面向某个企业的Web App，浏览器的兼容性则可不作为重点考虑。</p><h3 id="Web访问的原理"><a href="#Web访问的原理" class="headerlink" title="Web访问的原理"></a>Web访问的原理</h3><h4 id="静态网页"><a href="#静态网页" class="headerlink" title="静态网页"></a>静态网页</h4><p>该网页文件里没有特殊程序代码，只有HTML标记和客户端脚本代码，这种网页以后缀.htm或.html的文件存放，也可实现各种动态的效果，如.GIF动画、FLASH、滚动字母等，这些动态效果只是视觉上的。静态网页访问速度快，容易被搜索引擎收录。</p><h4 id="动态网页"><a href="#动态网页" class="headerlink" title="动态网页"></a>动态网页</h4><p>网页文件中不仅含有HTML标记和客户端脚本代码，而且含有需Web服务器进行处理的代码（文件扩展名一般为ASPX、JSP、PHP等）。用户登录、发布新闻、发布公司产品、交流互动、博客、网上调查等都需要动态网页来实现。</p><h3 id="Web开发平台的组成"><a href="#Web开发平台的组成" class="headerlink" title="Web开发平台的组成"></a>Web开发平台的组成</h3><ul><li>Microsoft .NET开发平台</li><li>Oracle Java EE开发平台      Servlet、JSP和EJB是J2EE平台的三大核心技术。Java EE 是在 Java SE 的基础上构建的</li><li>LAMP开发平台（Linux+Apache+MySQL+PHP） ……….</li></ul><h3 id="Web前端开发技术"><a href="#Web前端开发技术" class="headerlink" title="Web前端开发技术"></a>Web前端开发技术</h3><p>HTML CSS  DHTML&#x2F;JavaScript    ActiveX  XML  XHTML</p><p>DHTML可实现功能： 1）动态交互功能，使网页产生动态效果。 2）让用户站点易于维护。 3）可减轻服务器负荷，更大发挥网络能力</p><p>微软ActiveX控件技术是一种可重用的软件技术。将一个或一组功能封装起来，以对象方式供开发者使用，例如将文件加密和解密做成一个ActiveX控件，网上银行将密码输入框做成一个ActiveX控件，防止木马读取密码等。有大量商用或免费ActiveX控件供开发人员使用，也可用VC、VB等来开发一个ActiveX控件。ActiveX控件可在页面中直接使用，例如ActiveMovie控件可用于播放声音与视频，只需在控件的属性中指定参数值，就可在Web页面中控制其播放。 IE、Netscape、Firefox等浏览器都支持ActiveX技术。</p><p>当浏览的网页遇到ActiveX控件时，会检查用户本地系统的注册表，查看其是否已安装在本地机上。若已安装，浏览器显示该网页并激活控件。若未在用户本地安装，浏览器将查找并安装到本地。下载控件时，浏览器会缺省地显示一个消息框，通知用户将要开始下载，用户可以选择终止下载或继续下载（浏览器的Internet选项中设置）。</p><p>HTML的不足：HTML不能适应信息检索和存档要求；无法描述矢量图形、科技符号和一些其他特殊显示效果；文档结构混乱而缺乏条理，导致浏览器的设计越来越复杂。</p><p>XML弥补了HTML的不足，将网络上传输的文档规范化，并赋予标记一定的含义，与此同时，还要保留其简捷、适于网上传输和浏览的优点。XML是标记语言，可根据需要自定义新的标记。XML已在文件配置、数据存储、异构数据交换等众多方面得到广泛应用。</p><h4 id="后端开发技术"><a href="#后端开发技术" class="headerlink" title="后端开发技术"></a>后端开发技术</h4><p>CGI  PHP  JSP  ASP&#x2F;ASP.NET  ADO&#x2F;ADO.NET   Web Service  WCF</p><h2 id="第二章-Web开发环境的建立"><a href="#第二章-Web开发环境的建立" class="headerlink" title="第二章   Web开发环境的建立"></a>第二章   Web开发环境的建立</h2><p>每个网站的内容都存放在一个物理路径中，这个物理路径也即主目录。一个网站所有文件不一定非要将它们全部放在一个目录下，可以分散存放在不同的硬盘分区中。例如右图中将photo放到F盘中，将student放在E盘中。那我们的Web服务器如何来管理分散存放的某个网站内容呢？这就要通过创建虚拟目录来管理分散存放的网站目录。</p><p>.NET Framework  有3个组成部分：CLR（Common Language Runtime，公共语言运行库）：负责管理内存、线程执行、代码执行、代码安全验证、编译和其它系统服务。托管代码:需要以CLR环境来支撑运行的程序代码；非托管代码:用VB、VC++等工具开发的程序。.NET Framework 类库：提供很多现成的方法供开发人员编程使用，如复制、移动、删除一个文件、杀死一个进程、连接数据库等ASP.NET：使用托管代码来开发网站</p><p>源代码的版本控制简称为源码控制，它在多人协作开发环境中是非常重要的，它包含了对应用程序中每个源文件修改的历史记录，可对多个开发者的行为进行协调。在需要比较两种版本的文件或找回早期版本的文件时，源代码的控制是非常有用的。</p><h2 id="第三章-HTML与CSS"><a href="#第三章-HTML与CSS" class="headerlink" title="第三章   HTML与CSS"></a>第三章   HTML与CSS</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ 文档类型：&lt;!DOCTYPE HTML ……&gt;</span><br><span class="line">+ 标识这是一个HTML文档：&lt;html&gt;  …… &lt;/html&gt; </span><br><span class="line">+ 网页头部标识：&lt;head&gt;  …… &lt;/head&gt;   </span><br><span class="line">+ 网页内容：&lt;body&gt; ……  &lt;/body&gt;</span><br><span class="line">+ 浏览器窗口标题：&lt;title&gt; 窗口标题&lt;/title&gt;  </span><br><span class="line">+ 注释：&lt;!-- ……  --&gt;</span><br></pre></td></tr></table></figure><p>HTML标记、标签（tag）和HTML元素（element）是两个不同的概念，在HTML文档对象编程模型中把HTML标记称为元素，实际使用中常常不加区分。在面向对象编程中，每个标记都是一个对象。</p><p>不是所有的网页都是可以通过工具制作出来的，还需要手工编写代码。通过工具可以制作功能不太复杂的简单网页，较为复杂的页面只能通过手工编写代码来完成，有时还需要在网站后台编写网页代码动态生成网页传送给浏览器显示。</p><h3 id="HTML5特性"><a href="#HTML5特性" class="headerlink" title="HTML5特性"></a>HTML5特性</h3><ul><li>语义特性  HTML5可使网页有更好的结构，标签更为丰富。</li><li>设备兼容特性  可获取地理位置；使外部应用与浏览器内部数据直接连接，例如视频影音可直接与麦克风及摄像头相联。</li><li>本地存储特性  本地存储功能使HTML5网页运行更快，占用带宽更少。</li><li>连接特性  Server-Sent Event和WebSockets可实现服务器将数据“推送”到客户端。</li><li>网页多媒体特性  提供Audio、Video等多媒体功能。</li><li>性能与集成特性   通过XMLHttpRequest2等技术，帮助Web应用和网站在多样化的环境中更快速地工作。</li><li>三维、图形及特效特性   提供SVG、Canvas、WebGL及CSS3的3D功能，用户会惊叹于在浏览器中所呈现的惊人视觉效果。</li></ul><p>HTML注重的是内容本身，而不是显示方式。CSS注重解决网页字体大小、颜色、边框等格式问题，以提供给用户尽量美观、易读的网页。</p><p>依优先级最高的是内联样式，其次是联入样式表，然后是导入外部样式表。外链样式和联入样式中，最后定义的样式优先级最高。内联样式会向标记中添加更多属性及内容，对于网页设计者来说很难维护，应尽量减少使用内联样式</p><h3 id="使用CSS的优点"><a href="#使用CSS的优点" class="headerlink" title="使用CSS的优点"></a>使用CSS的优点</h3><ol><li>网页代码和网页格式分离，外链样式被浏览器保存在缓存里，加快了网页下载速度。</li><li>将网站的样式放在外部文件中，网站的各个网页都引用这个文件，只要修改这个文件中的样式，整个网站的网页格式就随之变化，保证了网站显示风格的一致。避免了一个个网页的修改，大大减少了重复工作量。</li></ol><h3 id="CSS的选择符"><a href="#CSS的选择符" class="headerlink" title="CSS的选择符"></a>CSS的选择符</h3><p> CSS中的选择符有：</p><ul><li>HTML标记</li><li>具有上下文关系的HTML标记</li><li>用户自定义类选择符</li><li>用户定义的ID选择符</li><li>虚类</li><li>虚元素</li></ul><h4 id="虚类"><a href="#虚类" class="headerlink" title="虚类"></a>虚类</h4><p>是一种特殊的类选择符，虚类的形式为：选择符:虚类{ 属性值对 }虚类主要针对超链接A标记来使用，可指定超链接标记A以不同的方式显示链接</p><p>超链接有4种不同的样式状态</p><ol><li>a:link    链接访问前的样式</li><li>a:visited 链接访问后的样式</li><li>a:active  链接活动时的样式</li><li>a:hover   鼠标在链接上的样式</li></ol><p>可将虚类和自定义类名组合起来使用，以实现页面中各个超链接按不同样式来呈现。</p><h4 id="虚元素"><a href="#虚元素" class="headerlink" title="虚元素"></a>虚元素</h4><p>有2个特殊的选择符first-letter和first-line，用于P、div、span等块级元素的首字母和首行效果。</p><p>格式为：</p><ul><li>选择符:first-letter {属性值对}</li><li>选择符.类:first-letter {属性值对}</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ol type=&quot;A&quot;&gt;</span><br><span class="line">&lt;li&gt;  输入部件 &lt;/li&gt;</span><br><span class="line">&lt;li&gt;   输出部件 &lt;/li&gt;</span><br><span class="line">&lt;li&gt;   存储器  &lt;/li&gt;</span><br><span class="line">&lt;/ol&gt;</span><br></pre></td></tr></table></figure><ol type="A"><li>  输入部件 </li><li>   输出部件 </li><li>   存储器  </li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul type=&quot;circle&quot;&gt;</span><br><span class="line"> &lt;li&gt; 算术逻辑部件(ALU)&lt;/li&gt;</span><br><span class="line">&lt;li&gt; 辅助存储器 &lt;/li&gt;</span><br><span class="line">&lt;li&gt;中央处理器(CPU)&lt;/li&gt;</span><br><span class="line">&lt;li&gt;辅助存储器 &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><ul type="circle"> <li> 算术逻辑部件(ALU)</li><li> 辅助存储器 </li><li>中央处理器(CPU)</li><li>辅助存储器 </li></ul><h3 id="定位属性"><a href="#定位属性" class="headerlink" title="定位属性"></a>定位属性</h3><table><thead><tr><th>样式属性</th><th>含义</th><th>取值</th></tr></thead><tbody><tr><td>position</td><td>绝对定位还是相对定位</td><td>absolute：将浏览器显示区域的左上角或框架页面显示区域的左上角作为原点Origin来定位。relative：表示相对位置，相对本元素的父元素来定位。父元素左上角为原点。static（默认值）： 表示静态位置，按照HTML文件中各元素的先后顺序放置。</td></tr><tr><td>left、top</td><td>x坐标、y坐标</td><td>position为absolute时，以Origin为原点的x坐标、y坐标position为relative时，以父元素左上角为原点的x坐标、y坐标。</td></tr><tr><td>z-index</td><td>设定元素的遮挡序号。</td><td>取值为整数，可正可负，值较高的元素覆盖较低的元素</td></tr></tbody></table><h3 id="表格制作"><a href="#表格制作" class="headerlink" title="表格制作"></a>表格制作</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>row 1, cell 1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>row 1, cell 2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>row 2, cell 1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>row 2, cell 2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><table border="1">     <tr>         <td>row 1, cell 1</td>         <td>row 1, cell 2</td>     </tr>     <tr>         <td>row 2, cell 1</td>         <td>row 2, cell 2</td>     </tr> </table><p>CSS3新增columns属性，可实现多列自动布局，自动将内容按指定的列数排列。column-count：设置列的具体个数column-gap：指定的列之间的间隙column-rule：列之间的宽度，样式和颜色的规则</p><h2 id="第四章-DHTML"><a href="#第四章-DHTML" class="headerlink" title="第四章  DHTML"></a>第四章  DHTML</h2><h3 id="JavaScript编程基础"><a href="#JavaScript编程基础" class="headerlink" title="JavaScript编程基础"></a>JavaScript编程基础</h3><p>HTML和CSS可用来创建网页，用户只能查看不能修改网页内容和外观，无法和网页进行交互。如点击某按钮，执行完点击事件后，就要让它disable，不再接受用户的点击，HTML和CSS是无法实现的，必须借助客户端脚本语言JavaScript(简称JS) 以及HTML DOM来完成。</p><p>JS嵌入在HTML文件中，能对鼠标点击、表单提交等用户事件做出反应和处理。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol><li>简单性    JS是简化的编程语言，变量类型简单，不声明也能使用。</li><li>基于对象  JS不完全面向对象，不支持类和继承，是基于对象而不是面向对象的语言</li><li>可移植性  JS可在浏览器上不经修改直接运行。</li><li>动态性    可用来设计客户端交互式动态页面。</li><li>安全性    JS是一种安全性语言，对本地资源的访问和操作有限，只能通过浏览器实现信息浏览或动态交互。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">验证手机号码：&quot;^1[3|4|5|7|8][0-9]\\d&#123;8&#125;$&quot;</span><br><span class="line">验证身份证号(15或18位)：&quot;\\d&#123;14&#125;[[0-9],0-9xX]&quot;</span><br></pre></td></tr></table></figure><p>&#x2F;\D&#x2F; 表示不是0-9</p><p>!&#x2F;\D&#x2F;.test(str)</p><p>我们不能像在传统的语言里那样用class来定义类, 但我们可利用JS的闭包封装机制来实现JS中的类</p><p>JS自定义对象有两种方式：</p><ol><li>把函数function当成对象</li><li>用prototype对象来实现JS的自定义对象。Prototype是函数的子对象， 很神奇，它可以给函数对象动态地添加属性和方法。</li></ol><h3 id="HTML-DOM基础（Document-Object-Model）"><a href="#HTML-DOM基础（Document-Object-Model）" class="headerlink" title="HTML DOM基础（Document Object Model）"></a>HTML DOM基础（Document Object Model）</h3><p> HTML DOM 是一个可让脚本程序动态访问和更新HTML文档内容、结构和样式的技术。它是跨平台、可适应不同程序语言的文件对象模型，采用直观一致的方式，将HTML文档进行模型化处理，是一种提供存取和更新文档内容、结构和样式的编程接口。</p><p>prompt、alert、confirm方法实现对话框功能，其中prompt为接受用户输入字符串的对话框；confirm实现具有确认和取消按钮的对话框；alert为仅输出文本对话框。</p><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>cookie是放在浏览器缓存中的一个文件，里面存放着各个参数名及参数值。cookie的参数是以分号相隔的,例:name&#x3D;wcl;sex&#x3D;male;color&#x3D;red;expires&#x3D;Sun May 27 22:04:25 UTC+0800 2008Cookie可用来存放当前页面的参数信息，也可用来存放同一网站打开的多个页面间的共享信息。可以对cookie设置失效期限，既可永久保留，也可关闭网站后就删除，也可在指定时间内失效。expires指定cookie的失效日期，当没有失效日期时，关闭浏览器即失效。例如：用户登录时需要从学生、任课教师、班主任、辅导员中选择一种角色登录，用cookie保存选定角色后，下次登录系统，就取cookie中的保存的用户角色作为默认值。</p><h3 id="文档对象"><a href="#文档对象" class="headerlink" title="文档对象"></a>文档对象</h3><h4 id="动态生成8行16列表格"><a href="#动态生成8行16列表格" class="headerlink" title="动态生成8行16列表格"></a>动态生成8行16列表格</h4><script>var rows = 8; cols = 16;for (var i = 1; i <= rows; i++){document.write("<tr>") :for (var j = 1: j <= cols; j++){document.write("<td>"+ i +"，”+ j + "</td>").}document.write("</tr>"):</script><p>通过优化网页代码，节省网络流量——网页减肥</p><p>文档对象的事件除了响应键盘、鼠标常规</p><p>操作事件外，还增加了其他大量事件，例如鼠标的拖拉操作事件、浏览器鼠标右键快捷菜单事件oncontextmenu等。</p><h3 id="HTML-DOM树简介"><a href="#HTML-DOM树简介" class="headerlink" title="HTML DOM树简介"></a>HTML DOM树简介</h3><p> HTML DOM是一种结构化的对象模型，采用DOM技术访问和更新HTML页面内容时，可依据HTML源代码，建立页面的树型结构模型，然后按照树型结构的层次关系来操纵Web页面。</p><p>在DOM树型结构中，每个节点都是一个对象，各节点对象都有属性和方法。</p><p>attributes节点属性的对象集合              chileNodes子节点的对象集合</p><p>DOM树型结构节点有只读属性和读写属性两类。通过只读属性可以浏览节点，并可获得节点的类型及名称等信息；通过读写属性可以访问文字节点的内容。</p><p>用DOM树方法可以动态创建HTML文档或HTML元素，并可通过JS程序随时改变文档的节点结构或内容，建立动态的网页生成效果。</p><h3 id="jQuery简介"><a href="#jQuery简介" class="headerlink" title="jQuery简介"></a>jQuery简介</h3><p>把一些通用的函数事先写好，放在外部单独JS文件中，在手工编写网页代码时，就可重复使用这些通用函数，大大简化网页代码的编写工作，提高网页开发的效率。</p><p>利用jQuery，也即JS开发库，HTML DOM的很多复杂编程操作都可轻松实现，大大减轻Web前端开发人员的编程难度，提高了编程效率。</p><p>jQuery是一个快捷、小巧和特性丰富的avaScript库，凭借简洁语法和跨平台的兼容性，大大简化了JS开发人员遍历HTML文档、操作DOM、处理事件、执行动画和开发Ajax的操作。其独特而优雅的代码风格改变了JS程序员的设计思路和编写程序的方式。</p><p>table tr:nth-child(even) 就是指表格中的偶数行，然后用jQuery的addClass方法添加CSS类名alternateColor，它已在style块中定义好了。</p><h4 id="jQuery选择器"><a href="#jQuery选择器" class="headerlink" title="jQuery选择器"></a>jQuery选择器</h4><ol><li>元素选择器   $(“div”)表示选择所有div元素</li><li>ID选择器   $(“#button1”)将选择ID为button1的元素。<code>$(“div #main”)选中ID为main的div元素。</code></li><li>类选择器   $(“.important”)将选择页面上所有应用了important类的元素。</li><li>后代选择器        若在一个选择器后面有一个空格，再跟另外一个选择器，则表示选择包含在第一个选择器中的第二个选择器。   $(”div p”)将选择div中出现的所有p元素。</li><li>子元素选择器  若一个选择器后面是一个大于号&gt;，后面再跟另一个选择器，则表示选择直接包在第一个选择器中的第二个选择器。  $(‘#ss &gt; li’)  选择Id为SS元素中的所有li元素。</li></ol><h2 id="第五章-XML基础"><a href="#第五章-XML基础" class="headerlink" title="第五章 XML基础"></a>第五章 XML基础</h2><p>XML是一种类似于HTML的标记语言XML是用来描述数据的XML的标记非预先定义，须自行定义标记</p><h3 id="XML的特点"><a href="#XML的特点" class="headerlink" title="XML的特点"></a>XML的特点</h3><ol><li>XML的可扩展性</li><li>标记的自描述性</li><li>XML语言的规则性</li><li>文档的结构化</li><li>允许Meta数据(元数据)</li><li>XML文档的多样显示</li><li>允许XML DOM操作  XML DOM的作用就是使用脚本语言如何对XML文档的节点和数据进行增删查改等各项操作。</li></ol><h3 id="XML中有关名词的相互关系"><a href="#XML中有关名词的相互关系" class="headerlink" title="XML中有关名词的相互关系"></a>XML中有关名词的相互关系</h3><p>XML DTD用以说明XML文档中数据的类型和格式,目前已被XML Schema所替代。</p><h3 id="避免命名冲突"><a href="#避免命名冲突" class="headerlink" title="避免命名冲突"></a>避免命名冲突</h3><ol><li>使用前缀</li><li>使用命名空间（Namespaces）为 <table> 标签添加了一个 xmlns 属性，这样就为前缀赋予了一个与某个命名空间相关联的限定名称。&lt;f:table xmlns:f&#x3D;”<a href="http://www.w3school.com.cn/furniture&quot;&gt;">http://www.w3school.com.cn/furniture&quot;&gt;</a></li></ol><h3 id="XML-DOM"><a href="#XML-DOM" class="headerlink" title="XML DOM"></a>XML DOM</h3><p>对于XML文档，可利用CSS的样式或XSLT格式转换后利用浏览器解析和浏览它，如何对XML文档进行数据的添加、删除、修改、查询等操作，就需要使用XML DOM技术了。 XML DOM实际上就是访问XML文档的标准应用程序接口。先看例子。</p><p>XML DOM是W3C提出的针对XML的文档对象模型，是一个与语言无关、与平台无关的标准接口规范，定义了一套标准的用于XML的对象和一种标准的访问与处理XML文档的方法。</p><p>对于XML应用开发来说，DOM 就是一个对象化的XML数据接口，它定义了XML文档的逻辑结构，可动态创建XML文档；遍历文档结构；添加、修改、删除文档内容；改变文档的显示方式等。无论是在浏览器里还是在浏览器外，无论是在服务器还是在客户端，只要有用到XML的地方，都可利用DOM接口进行编程应用。</p><p>DOM将XML文档作为树结构来看待。XML文档中的每个成分都是一个节点。例如整个文档是一个文档根节点；每个XML标记是一个元素节点；包含在XML元素中的文本是文本节点；每一个XML属性是一个属性节点；注释属于注释节点。</p><h3 id="XML-DOM与-SAX"><a href="#XML-DOM与-SAX" class="headerlink" title="XML DOM与 SAX"></a>XML DOM与 SAX</h3><p>访问XML文档的标准应用程序接口有两种：DOM（Document Object Model）和SAX（Simple API for XML）</p><p>DOM接口中的XML分析器，在对XML文档进行分析之后，不管这个文档有多简单或者多复杂，其中的信息都会被转化成一棵对象节点树——DOM 树。在这棵节点树中，有一个Document根节点，所有其他的节点都是根节点的后代节点。节点树生成之后，就可通过XML DOM接口访问、修改、添加、删除树中的节点和属性以及文本内容等。应用程序可在任何时候访问XML文档中的任何一部分数据，也即可随机访问。与XML DOM不同，SAX提供的访问模式是一种顺序模式，这是一种快速读写XML数据的方式。当使用SAX分析器对XML文档进行分析时，会触发一系列事件，并激活相应的事件处理函数，应用程序通过编写的事件处理函数实现对XML文档的访问，因而SAX接口也被称作事件驱动接口。由于DOM分析器把整个XML文档转化成DOM树放在了内存中，当XML文档很大或结构比较复杂时，对内存的需求就比较高。SAX分析器在对XML文档进行分析时，触发了一系列的事件，由于事件触发本身是有时序性的，SAX提供的是一种顺序访问机制，对于分析过的部分，不能再倒回去重新处理，因此SAX分析器缺乏灵活性但实现简单，对内存要求比较低。</p><h3 id="XML-DOM对象"><a href="#XML-DOM对象" class="headerlink" title="XML DOM对象"></a>XML DOM对象</h3><ol><li>Document对象</li><li>Node对象（节点对象） Node对象的子对象有Document、Element、Attribute、Text、Comment等。</li><li>NodeList对象（节点列表）</li><li>NamedNodeMap（有名节点映射）</li></ol><h3 id="XML与数据库的关系"><a href="#XML与数据库的关系" class="headerlink" title="XML与数据库的关系"></a>XML与数据库的关系</h3><ol><li>XML不是数据库，数据库系统有它自己的一套管理模式，而XML仅仅是用来存放数据的文件，一个XML文档相当于数据库中的一个表。因此XML不可能取代数据库，但将数据库和XML结合起来，能够完成很多以前无法完成的工作，例如异构数据交换、应用系统集成等。</li><li>数据若放在数据库中共享，则受到数据库连接请求失败、防火墙隔离等各种限制。XML是文本文件，可以穿透任何防火墙进行传输，已成为互联网上的事实数据交换标准。</li><li>随着XML的广泛应用，各数据库产品都被重新设计，使之能很好支持XML，如Oracle、SQL Server、DB2、Sybase、MySQL等。另外还出现了支持native（原生） XML文档进行存储管理的专属XML数据库系统，如X-Hive、XML Repository、eXcelon、BaseX、 Sedna、 XMLDB等，提供对标签和路径的操作，文档存储和检索迅捷，可提供高质量的全文搜索。</li><li>开发一个访问数据库的XML应用系统需要同时借助XML编程接口和数据库编程接口，前者用于对XML文档的解析、定位和查询，所需技术包括DOM和SAX；后者则是用于访问数据库，如数据库中数据的更新和检索等等，需要利用的技术有ODBC、JDBC、ADO&#x2F;ADO.NET等。</li><li>XML文档可通过ADO.NET等各种数据接口方式存放到数据库中，也可将数据表中的数据形成一个XML文档通过XSL来呈现。</li></ol><h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><p>在XML中，需要许多开始标记和结束标记来标识数据，在互联网网上传输数据时效率不高，出现了JSON(JavaScript Object Notation) 轻量级的数据交换格式，易于阅读和编写，同时也易于机器解析和生成， 作为XML文档的一种有力补充。</p><h2 id="第六章-NET-Web应用程序开发"><a href="#第六章-NET-Web应用程序开发" class="headerlink" title="第六章 .NET Web应用程序开发"></a>第六章 .NET Web应用程序开发</h2><h3 id="C"><a href="#C" class="headerlink" title="C#"></a>C#</h3><p>ASP.NET中采用强类型语言VB.NET、C#等，采用完全面向对象方式编程。C#是由C和C++发展而来的面向对象和类型安全的编程语言。C#读作C Sharp，它和Java非常相近。</p><p>using System使用了由Microsoft.NET类库中提供的System名称空间，用来组织类库的分层。分层的类库之间用操作符“.”表示上下级分层关系。使用“using”后，就可无障碍地使用名称空间中的各种类型成员。名称空间除具有避免名称冲突之功能外，更重要的是在引用名称空间后，就可在程序代码中方便地使用系统提供的各种类库成员。</p><p>名称空间除避免名称冲突外，也方便了程序代码的编写</p><h4 id="C-中的数据类型"><a href="#C-中的数据类型" class="headerlink" title="C#中的数据类型"></a>C#中的数据类型</h4><p>数据类型变量直接包含数据，而引用类型变量存储对于对象的引用</p><p>数据类型</p><p><strong>简单类型</strong>（如char、int和float）枚举类型结构类型</p><p><strong>引用类型</strong>类类型，接口类型，代表（delegate）类型，数组类型。</p><p>对于引用类型，两个变量可引用相同的对象，因而可能出现对一个变量的操作影响到其他变量所引用对象的情况</p><p>C#语言是一种强类型的语言，在使用变量前必须对该变量的类型进行声明，建议在声明变量时就对变量进行初始化。</p><h4 id="变量名"><a href="#变量名" class="headerlink" title="变量名"></a>变量名</h4><p>必须以英文字母或@开头，由字母、数字、下划线组成，不能有空格、标点、运算符号、C#中关键字名、C#中库函数名，且大小写敏感。</p><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>C#中定义常量用const修饰符，例如“public const double y&#x3D;1.234;”。枚举类型是由一组特定常量构成的一种数据结构，是值类型的特殊形式。当需要一个有指定常量集合组成的数据类型时，可使用枚举类型。枚举类型不能实现接口、不能定义方法、属性、事件。</p><h4 id="C-表达式"><a href="#C-表达式" class="headerlink" title="C#表达式"></a>C#表达式</h4><p>算术表达式</p><p>赋值表达式</p><p>关系表达式</p><p>逻辑表达式。</p><h4 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h4><p>分支语句有3种：</p><p>①三元运算符，例如：a&#x3D;(b&gt;5)?100:10表示b&gt;5时a&#x3D;100，否则a&#x3D;10；</p><p>②if语句（一次仅测试一个条件）；</p><p>③switch语句（一次将测试变量与多个值比较）。</p><p>循环语句有4种。可用break和continue语句跳出循环或继续执行循环。foreach语句可以遍历一个集合中的所有元素。</p><h3 id="ASP-NET常用控件的使用介绍"><a href="#ASP-NET常用控件的使用介绍" class="headerlink" title="ASP.NET常用控件的使用介绍"></a>ASP.NET常用控件的使用介绍</h3><ul><li>标准控件是和界面设计制作有关的控件</li><li>数据访问操作及数据可视化方面控件 </li><li>对用户输入的内容进行验证的控件</li><li>提供站点导航、动态菜单、树型菜单的控件</li><li>用户登录界面的设计制作控件</li><li>WEB门户定制控件，可拖动区域在屏幕上重新布局</li><li>提供Ajax编程的控件</li><li>提供动态数据操控的的控件</li><li>提供WEB页面上的报表处理控件</li><li>HTML中的常规控件</li></ul><p><strong>客户端控件</strong>：Web服务器对客户端控件不做任何处理，交由客户端浏览器来处理。</p><p><strong>服务器端控件</strong>：需要占用Web服务器的内存、CPU等系统资源等来处理服务端控件，最终转变成客户端控件，再交由客户端浏览器来处理。为提供网页访问速度，页面中尽量使用客户端控件。</p><p>当某控件的EnableViewState属性为true时，表示该控件的值在页面刷新或回传重新显示页面后不会丢失，但却耗费网络资源和服务器资源。因此当页面回传后无须保值处理时应设为false。</p><h2 id="第七章-AJAX技术"><a href="#第七章-AJAX技术" class="headerlink" title="第七章  AJAX技术"></a>第七章  AJAX技术</h2><p>Ajax：Asynchronous Javascript and XML</p><p>该技术的目标是让用户动态地与页面进行交互，加快服务器的响应速度，减少用户的等待时间，是一种创建交互式Web应用程序的开发技术。其技术的最简单描述就是实现局部刷新。</p><p>Ajax的局部刷新：通过异步数据交换和处理，显著提高Web应用程序运行效率。Ajax不是新技术，是各个已有核心技术的创新应用。</p><p>Ajax的核心是支持异步请求的XmlHttpRequest对象，使开发者可使用JavaScript向服务器提出异步请求并处理响应。</p><p>实现Ajax技术的应用开发主要有：直接基于XMLHttpRequest对象，利用各种Ajax框架，简化Ajax开发</p><h1 id="CGI脚本"><a href="#CGI脚本" class="headerlink" title="CGI脚本"></a><strong>CGI脚本</strong></h1><p><a href="https://www.jb51.net/article/10514.htm">https://www.jb51.net/article/10514.htm</a></p><p>CGI 意思为 Common Gateway Interface, 一种基于浏览器的输入、在Web服务器上运行的程序方法. CGI脚本 使你的浏览器与用户能交互，为了在数据库中寻找一个名词, 提供你写入的评论，或者从一个表单中选择几个条目并且能得到一个明确的回答. 如果你曾经遇到过在web上填表或进行搜索, 你就是用的CGI脚本. 你那时也许没有意识到，因为大部分工作是在服务器上运行的，你看到的只是结果.</p><h2 id="CGI脚本是什么"><a href="#CGI脚本是什么" class="headerlink" title="CGI脚本是什么?"></a><strong>CGI脚本是什么?</strong></h2><p>CGI脚本简单地讲是个运行在Web服务器上的程序, 有浏览器的输入触发. 这个脚本通常象服务器和系统中其他程序如数据库的桥梁。</p><p>CGI 脚本难道不是一个真正的脚本?按照你的服务器的支持, 他们可能是一个编译好的程序或者批命令文件或者其他可执行的东西. 为了简单起见，我们统称他们为脚本scripts.</p><hr><p>CGI 脚本是任何运行在web服务器上的程序. CGI意思是Common Gateway Interface。</p><hr><p>CGI脚本是用下列两种方法使用的: 作为一个表单的ACTION 或 作为一个页中的直接link。</p><h2 id="CGI脚本是怎样工作的"><a href="#CGI脚本是怎样工作的" class="headerlink" title="CGI脚本是怎样工作的?"></a>CGI脚本是怎样工作的?</h2><ol><li>一个URL指向一个CGI脚本. 一个CGI脚本的URL能如普通的URL一样在任何地方出现。</li><li>服务器接收请求, 按照那个URL指向的脚本文件(注意文件的位置和扩展名),执行脚本.</li><li>脚本执行基于输入数据的操作，包括查询数据库、计算数值或调用系统中其他程序.</li><li>脚本产生某种Web服务器能理解的输出结果.</li><li>服务器接收来自脚本的输出并且把它传回浏览器，让用户了解结果。</li></ol><h1 id="一个服务器同时运行多个网站三种方式"><a href="#一个服务器同时运行多个网站三种方式" class="headerlink" title="一个服务器同时运行多个网站三种方式"></a>一个服务器同时运行多个网站三种方式</h1><p>1.IP一样，端口不一样<br>2.端口一样IP不一样<br>3.端口一样，IP一样，绑定的域名不一样</p><h1 id="关于Ajax"><a href="#关于Ajax" class="headerlink" title="关于Ajax"></a>关于Ajax</h1><p>readyStae状态：</p><p>0: (Uninitialized) the send( ) method has not yet been invoked.<br>1: (Loading) the send( ) method has been invoked, request in progress.<br>2: (Loaded) the send( ) method has completed, entire response received.<br>3: (Interactive) the response is being parsed.<br>4: (Completed) the response has been parsed, is ready for harvesting. </p><p>0 － （未初始化）还没有调用send()方法<br>1 － （载入）已调用send()方法，正在发送请求<br>2 － （载入完成）send()方法执行完成，已经接收到全部响应内容<br>3 － （交互）正在解析响应内容<br>4 － （完成）响应内容解析完成，可以在客户端调用了</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hadoop的一些基础操作</title>
      <link href="/2022/11/13/hadoop%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/"/>
      <url>/2022/11/13/hadoop%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="Linux-常用命令"><a href="#Linux-常用命令" class="headerlink" title="Linux 常用命令"></a>Linux 常用命令</h1><h2 id="Linux系统的文件结构"><a href="#Linux系统的文件结构" class="headerlink" title="Linux系统的文件结构"></a>Linux系统的文件结构</h2><p>&#x2F;bin        二进制文件，系统常规命令<br>&#x2F;boot       系统启动分区，系统启动时读取的文件<br>&#x2F;dev        设备文件<br>&#x2F;etc        大多数配置文件<br>&#x2F;home       普通用户的家目录<br>&#x2F;lib        32位函数库<br>&#x2F;lib64      64位库<br>&#x2F;media      手动临时挂载点<br>&#x2F;mnt        手动临时挂载点<br>&#x2F;opt        第三方软件安装位置<br>&#x2F;proc       进程信息及硬件信息<br>&#x2F;root       临时设备的默认挂载点<br>&#x2F;sbin       系统管理命令<br>&#x2F;srv        数据<br>&#x2F;var        数据<br>&#x2F;sys        内核相关信息<br>&#x2F;tmp        临时文件<br>&#x2F;usr        用户相关设定</p><h2 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h2><p>  cd &#x2F;                 &#x2F;&#x2F;切换到根目录<br>  cd &#x2F;bin              &#x2F;&#x2F;切换到根目录下的bin目录<br>  cd ..&#x2F;               &#x2F;&#x2F;切换到上一级目录 或者使用命令：cd ..<br>  cd ~                 &#x2F;&#x2F;切换到home目录<br>  cd -                 &#x2F;&#x2F;切换到上次访问的目录<br>  cd xx(文件夹名)       &#x2F;&#x2F;切换到本目录下的名为xx的文件目录，如果目录不存在报错<br>  cd &#x2F;xxx&#x2F;xx&#x2F;x         &#x2F;&#x2F;可以输入完整的路径，直接切换到目标目录，输入过程中可以使用tab键快速补全</p><h3 id="查看目录（ls）"><a href="#查看目录（ls）" class="headerlink" title="查看目录（ls）"></a>查看目录（ls）</h3><p>  ls                   &#x2F;&#x2F;查看当前目录下的所有目录和文件<br>  ls -a                &#x2F;&#x2F;查看当前目录下的所有目录和文件（包括隐藏的文件）<br>  ls -l                &#x2F;&#x2F;列表查看当前目录下的所有目录和文件（列表查看，显示更多信息），与命令”ll”效果一样<br>  ls &#x2F;bin              &#x2F;&#x2F;查看指定目录下的所有目录和文件 </p><p>  mkdir tools          &#x2F;&#x2F;在当前目录下创建一个名为tools的目录<br>  mkdir &#x2F;bin&#x2F;tools     &#x2F;&#x2F;在指定目录下创建一个名为tools的目录</p><p>  pwd                         &#x2F;&#x2F;显示当前位置路径</p><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p>  rm 文件名              &#x2F;&#x2F;删除当前目录下的文件<br>  rm -f 文件名           &#x2F;&#x2F;删除当前目录的的文件（不询问）</p><p>  cat a.txt          &#x2F;&#x2F;查看文件最后一屏内容<br>  less a.txt         &#x2F;&#x2F;PgUp向上翻页，PgDn向下翻页，”q”退出查看<br>  more a.txt         &#x2F;&#x2F;显示百分比，回车查看下一行，空格查看下一页，”q”退出查看<br>  tail -100 a.txt    &#x2F;&#x2F;查看文件的后100行，”Ctrl+C”退出查看</p><p>  tar -zxvf a.tar                      &#x2F;&#x2F;解包至当前目录<br>  tar -zxvf a.tar -C &#x2F;usr——        &#x2F;&#x2F;指定解压的位置<br>  unzip test.zip             &#x2F;&#x2F;解压*.zip文件<br>  unzip -l test.zip          &#x2F;&#x2F;查看*.zip文件的内容 </p><h1 id="Hadoop操作"><a href="#Hadoop操作" class="headerlink" title="Hadoop操作"></a>Hadoop操作</h1><h2 id="启动Hadoop"><a href="#启动Hadoop" class="headerlink" title="启动Hadoop"></a>启动Hadoop</h2><p>cd &#x2F;usr&#x2F;local&#x2F;hadoop<br>.&#x2F;sbin&#x2F;start-dfs.sh #启动hadoop</p><h2 id="HDFS中为hadoop用户创建一个用户目录"><a href="#HDFS中为hadoop用户创建一个用户目录" class="headerlink" title="HDFS中为hadoop用户创建一个用户目录"></a>HDFS中为hadoop用户创建一个用户目录</h2><p>cd &#x2F;usr&#x2F;local&#x2F;hadoop<br>.&#x2F;bin&#x2F;hdfs dfs -mkdir -p &#x2F;user&#x2F;hadoop</p><h2 id="显示HDFS中与当前用户hadoop对应的用户目录下的内容"><a href="#显示HDFS中与当前用户hadoop对应的用户目录下的内容" class="headerlink" title="显示HDFS中与当前用户hadoop对应的用户目录下的内容"></a>显示HDFS中与当前用户hadoop对应的用户目录下的内容</h2><p> .&#x2F;bin&#x2F;hdfs dfs -ls .</p><p>.&#x2F;bin&#x2F;hdfs dfs -ls &#x2F;user&#x2F;hadoop</p><h2 id="创建-x2F-删除一个input目录"><a href="#创建-x2F-删除一个input目录" class="headerlink" title="创建&#x2F;删除一个input目录"></a>创建&#x2F;删除一个input目录</h2><p> .&#x2F;bin&#x2F;hdfs dfs -mkdir input</p><p>它在HDFS中的完整路径是“&#x2F;user&#x2F;hadoop&#x2F;input”。如果要在HDFS的根目录下创建一个名称为input的目录，则需要使用如下命令：</p><p>.&#x2F;bin&#x2F;hdfs dfs -mkdir &#x2F;input</p><p>使用rm命令删除一个目录，比如，可以使用如下命令删除刚才在HDFS中创建的“&#x2F;input”目录（不是“&#x2F;user&#x2F;hadoop&#x2F;input”目录）：</p><p>.&#x2F;bin&#x2F;hdfs dfs -rm -r &#x2F;input</p><h2 id="文件操作-1"><a href="#文件操作-1" class="headerlink" title="文件操作"></a>文件操作</h2><p>把本地文件系统的“&#x2F;home&#x2F;hadoop&#x2F;myLocalFile.txt”上传到HDFS中的当前用户目录的input目录下，也就是上传到HDFS的“&#x2F;user&#x2F;hadoop&#x2F;input&#x2F;”目录下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/hdfs dfs -put /home/hadoop/myLocalFile.txt  input</span><br></pre></td></tr></table></figure><p>查看一下文件是否成功上传到HDFS中</p><p>.&#x2F;bin&#x2F;hdfs dfs -ls input</p><p>查看HDFS中的myLocalFile.txt这个文件的内容：</p><p>.&#x2F;bin&#x2F;hdfs dfs -cat input&#x2F;myLocalFile.txt</p><p>把HDFS中的myLocalFile.txt文件下载到本地文件系统中的“&#x2F;home&#x2F;hadoop&#x2F;下载&#x2F;”这个目录下</p><p>.&#x2F;bin&#x2F;hdfs dfs -get input&#x2F;myLocalFile.txt  &#x2F;home&#x2F;hadoop&#x2F;下载</p><p>使用如下命令，到本地文件系统查看下载下来的文件myLocalFile.txt：</p><p>cd ~<br>cd 下载<br>ls<br>cat myLocalFile.txt</p><p>把HDFS的“&#x2F;user&#x2F;hadoop&#x2F;input&#x2F;myLocalFile.txt”文件，拷贝到HDFS的另外一个目录“&#x2F;input”中</p><p>.&#x2F;bin&#x2F;hdfs dfs -cp input&#x2F;myLocalFile.txt  &#x2F;input</p><p>使用hadoop jar命令运行程序</p><p>cd &#x2F;usr&#x2F;local&#x2F;hadoop<br>.&#x2F;bin&#x2F;hadoop jar .&#x2F;myapp&#x2F;WordCount.jar input output</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据科学导论</title>
      <link href="/2022/11/13/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/"/>
      <url>/2022/11/13/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<p>数据科学导论</p><span id="more"></span><h1 id="第1章-大数据概述"><a href="#第1章-大数据概述" class="headerlink" title="第1章 大数据概述"></a><strong>第1章 大数据概述</strong></h1><p>大数据是人们获得新的认知，创造新的价值的源泉；大数据还是改变市场、组织机构，以及政府与公民关系的方法。作者认为，大数据的核心就是预测。这个核心代表着我们分析信息时的三个转变：第1个转变就是，在大数据时代，我们可以分析更多的数据，有时候甚至可以处理和某个特别现象相关的所有数据，而<strong>不再依赖于随机采样</strong>。第2个改变就是，研究数据如此之多，以至于我们<strong>不再热衷于追求精确度</strong>。第3个转变，因前两个转变而促成，即我们<strong>不再热衷于寻找因果关系</strong></p><h2 id="大数据从哪里来？"><a href="#大数据从哪里来？" class="headerlink" title="大数据从哪里来？"></a><strong>大数据从哪里来？</strong></h2><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16684337925301668433791777.png"></p><p>1Byte &#x3D; 8 Bit</p><p>1KB &#x3D; 1,024 Bytes</p><p>1MB &#x3D; 1,024 KB &#x3D; 1,048,576 Bytes</p><p>1GB &#x3D; 1,024 MB &#x3D; 1,048,576 KB &#x3D; 1,073,741,824 Bytes</p><p>1TB &#x3D; 1,024 GB &#x3D; 1,048,576 MB &#x3D; 1,099,511,627,776 Bytes</p><p>1PB &#x3D; 1,024 TB &#x3D; 1,048,576 GB &#x3D;1,125,899,906,842,624 Bytes</p><p>1EB &#x3D; 1,024 PB &#x3D; 1,048,576 TB &#x3D; 1,152,921,504,606,846,976 Bytes</p><p>1ZB &#x3D; 1,024 EB &#x3D; 1,180,591,620,717,411,303,424 Bytes</p><p>1YB &#x3D; 1,024 ZB &#x3D; 1,208,925,819,614,629,174,706,176 Bytes</p><table><thead><tr><th>1TB</th><th>1块1TB硬盘</th><th>20万张照片</th></tr></thead><tbody><tr><td>1PB</td><td>两个数据中心机柜</td><td>16个Blackblaze  pod 存储单元</td></tr><tr><td>1EB</td><td>2000个机柜</td><td>占据一个街区的4层数据中心</td></tr><tr><td>1ZB</td><td>1000个数据中心</td><td>重庆高新区的4&#x2F;5区域</td></tr><tr><td>1YB</td><td>100万个数据中心</td><td>两个重庆市主城九区</td></tr></tbody></table><h2 id="大数据的发展历程"><a href="#大数据的发展历程" class="headerlink" title="大数据的发展历程"></a><strong>大数据的发展历程</strong></h2><table><thead><tr><th><strong>信息化浪潮</strong></th><th><strong>发生时间</strong></th><th><strong>标志</strong></th><th><strong>解决问题</strong></th><th><strong>代表企业</strong></th></tr></thead><tbody><tr><td>第一次浪潮</td><td><strong>1980</strong>年前后</td><td>个人计算机</td><td>信息处理</td><td>Intel、AMD、IBM、苹果、微软、联想、戴尔、惠普等</td></tr><tr><td>第二次浪潮</td><td><strong>1995</strong>年前后</td><td>互联网</td><td>信息传输</td><td>雅虎、谷歌、阿里巴巴、百度、腾讯等</td></tr><tr><td>第三次浪潮</td><td><strong>2010</strong>年前后</td><td>物联网、云计算和大数据</td><td>信息爆炸</td><td>将涌现出一批新的市场标杆企业</td></tr></tbody></table><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16684338645291668433863849.png"></p><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16684338815291668433881456.png"></p><h2 id="数据科学是什么？"><a href="#数据科学是什么？" class="headerlink" title="数据科学是什么？"></a>数据科学是什么？</h2><p>简单来讲：数据科学是一门将数据变得有用的学科</p><h2 id="什么是大数据？"><a href="#什么是大数据？" class="headerlink" title="什么是大数据？"></a><strong>什么是大数据？</strong></h2><p><strong>维基百科：</strong>或称巨量数据、海量数据，指的是所涉及的数据量规模巨大到<strong>无法通过人工，在合理时间内</strong>达到截取、管理、处理、并整理成为人类所能解读的信息。</p><p><strong>Gartner：</strong>“大数据”是需要<strong>新处理模式</strong>才能具有更强的决策力、洞察发现力和流程优化能力的海量、高增长率和多样化的信息资产。</p><p><strong>IDC定义：</strong>为了更为经济的从高频率获取的、大容量的、不同结构和类型的数据中获取价值，而设计的<strong>新一代架构和技术</strong>。</p><p><strong>麦肯锡：</strong>一种规模大到在获取、存储、管理、分析方面大大<strong>超出了传统数据库</strong>软件工具能力范围的数据集合，具有<strong>海量</strong>的数据规模、<strong>快速</strong>的数据流转、<strong>多样</strong>的数据类型和价值<strong>密度低</strong>四大特征。</p><h2 id="大数据的特征"><a href="#大数据的特征" class="headerlink" title="大数据的特征"></a><strong>大数据的特征</strong></h2><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16684340315291668434030792.png" style="zoom: 50%;" /><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16684341725301668434171674.png"></p><h2 id="大数据的技术支撑"><a href="#大数据的技术支撑" class="headerlink" title="大数据的技术支撑"></a>大数据的技术支撑</h2><p><strong>存储设备容量不断增加</strong></p><p><strong>CPU处理能力大幅提升</strong></p><p><strong>网络带宽不断增加</strong></p><p><strong>数据产生方式的改变</strong></p><h2 id="大数据的影响"><a href="#大数据的影响" class="headerlink" title="大数据的影响"></a><strong>大数据的影响</strong></h2><p><strong>大数据对科学研究的影响</strong></p><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16684350731961668435072261.png"></p><p><strong>大数据对思维模式的影响</strong></p><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16684351291981668435128695.png"></p><h1 id="第2章-大数据相关工程技术与应用"><a href="#第2章-大数据相关工程技术与应用" class="headerlink" title="第2章 大数据相关工程技术与应用"></a><strong>第2章 大数据相关工程技术与应用</strong></h1><p>大数据无处不在，包括金融、汽车、零售、餐饮、电信、能源、政务、医疗、体育、娱乐等在内的社会各行各业都已经融入了大数据的印迹</p><h2 id="典型的大数据应用实例"><a href="#典型的大数据应用实例" class="headerlink" title="典型的大数据应用实例"></a>典型的大数据应用实例</h2><p>2009年，美国谷歌公司在《自然》上发表了关于<strong>流感预测</strong>的论文，成为大数据在医疗卫生应用的典范。</p><p>利用<strong>5000****万</strong>条美国人最频繁检索的词条和美国疾病预防控制中心（CDC）流感传播时期的数据进行了比较，判断是否流感暴发。</p><p>结果显示，数据<strong>不仅可以预测流感的暴发情况，而且可以具体到特定地区和州</strong>。</p><p>从谷歌流感趋势看大数据的应用价值 “谷歌流感趋势”，通过跟踪搜索词相关数据来判断全美地区的流感情况</p><p>麻省理工学院、密歇根大学和一家医院创建了一个数据模型，利用心脏病患者的心电图数据，<strong>预测在未来一年内患者心脏病发作的几率</strong>。</p><p>在过去，<strong>缺乏对已有数据的比较分析</strong>，使得70%的心脏病患者再度发病缺乏预判。</p><p>现在通过<strong>机器学习和数据挖掘</strong>，该模型可以通过累积的数据进行分析，<strong>发现高风险指标</strong>。</p><p>10多年前，康奈尔大学的Sherman教授通过一些小规模食谱的分析，认为气候是影响我们选择调味品最重要的因素</p><p>气候本身限制了调味食材的生长（例如八角主要生长在阴湿、土壤疏松的山地，东北就不易培植）</p><p>气候条件影响我们对调味食材的需求（例如成都湿度大，大家普遍爱吃花椒，因为它散寒除湿）。</p><p>通过大数据，印第安纳大学的Ahn教授分析了多个国家和地区56498份菜谱，他*发现西方和东方一些国家气候相近但饮食天差地别。</p><p>西方食材：牛奶、黄油、香草、鸡蛋、蔗糖浆和小麦</p><p>东方食材：酱油、葱、香油、米、大豆和姜。</p><p>从美食圈国内知名网站“美食街”上下载了我国20个菜系共计8498份菜谱，包含2911种食材。</p><p>地理上的相近性对于食材使用的影响远远大于气候的相近性。</p><p>结果暗示，如果没有交流，即便气候条件相近，产生的文化结果也会大不一样。</p><p>大数据的行业应用——<strong>交通领域</strong></p><p>大数据技术可以构建城市智慧交通。车辆、行人、道路基础设施、公共服务场所都被整合在智慧交通网络中。洛杉矶利用磁性道路传感器和交通摄像头的数据来控制交通灯信号，从而优化城市的交通流量。通过控制了全市的4500个交通灯，将交通拥堵状况减少了约16%。</p><p>大数据的行业应用——<strong>通讯领域</strong></p><p>利用大数据的采集和分析技术进行实时追踪，例如中国移动的天盾系统能通过大数据有效识别欺诈电话，识别准确率达95%,月均诈骗电话识别总量9200个,月均识别受害人4300个,平均每月挽回客户损失800万。</p><p>大数据的行业应用——<strong>医疗领域</strong></p><p>大数据分析应用的计算能力可以更好的去理解和预测疾病、可以帮助病人对于病情进行更好的治疗。例如，智慧养老及慢性病管理、医药研发、基因工程等</p><p>大数据的行业应用——<strong>金融领域</strong></p><p>大数据在金融领域主要是应用在金融交易方面。高频交易（HFT）是大数据应用比较多的领域。其中大数据分析和挖掘算法可用于交易决策、风险控制、精准营销等。</p><p>大数据的行业应用——<strong>制造领域</strong></p><p>利用工业大数据提升制造业水平，包括产品故障诊断与预测、分析工艺流程、改进生产工艺、优化生产过程能耗、工业供应链分析与优化、生产计划与排程。</p><p>大数据的行业应用——<strong>生活领域</strong></p><p>借助大数据技术更好的了解客户以及他们的爱好和行为。通过搜集浏览器的日志和传感器数据，建立数据模型并预测。</p><h1 id="第3章-大数据采集和预处理"><a href="#第3章-大数据采集和预处理" class="headerlink" title="第3章 大数据采集和预处理"></a><strong>第3章 大数据采集和预处理</strong></h1><h2 id="大数据采集"><a href="#大数据采集" class="headerlink" title="大数据采集"></a><strong>大数据采集</strong></h2><p>（1）数据采集的概念</p><p>​    数据采集（Data Acquisition，DAQ），是指从传感器和其他待测设备等模拟和数字被测单元中自动采集非电量或者电量信号，送到上位机中进行分析，处理。</p><p>（2）数据采集的目</p><p>​    是为了测量电压、电流、温度、压力或声音等物理现象。基于PC的数据采集，通过模块化硬件、应用软件和计算机的结合进行测量。</p><p>3）数据采集系统</p><p>​    数据釆集系统由硬件和软件两部分组成。从硬件方向来看，目前数据采集系统的结构形式主要有两种：</p><p>1）<strong>微型计算机数据采集系统</strong>。由传感器、模拟多路开关、程控放大器、采样保持器、A／D转换器、计算机及外设等部分组成。</p><p>2）<strong>集散型数据采集系统</strong>。由若干个<strong>数据采集站</strong>和<strong>一台上位机</strong>及<strong>通信线路</strong>组成。</p><h2 id="数据抽取转换加载技术"><a href="#数据抽取转换加载技术" class="headerlink" title="数据抽取转换加载技术"></a>数据抽取转换加载技术</h2><p><strong>ETL概述</strong></p><p>数据抽取转换加载（ETL），是英文 Extract-Transform-Load的缩写，用来描述将数据从来源端经过抽取（extract）、转换（transform）、加载（load）至目的端的过程。</p><p> ETL是构建数据仓库的重要一环，用户从数据源抽取出所需的数据，经过数据清洗，最终按照预先定义好的数据模型，将数据加载。</p><p>ETL是用来实现异构多数据源的数据集成的工具</p><p>  其主要的功能包括：</p><p><strong>数据的抽取</strong></p><p>将数据从不同的网络、不同的操作平台、不同的数据库及数据格式、不同的应用中抽取出来。</p><p><strong>数据的转换</strong></p><p>数据转换（数据的合并、汇总、过滤、转换等）、重新格式化和计算数据、重新构建关键数据以及总结与定位数据。</p><p><strong>数据的装载</strong></p><p>将数据跨网络、操作平台装载到目标数据库中。</p><p>ETL的实现有多种方法，常用的有三种：</p><p>（1）借助<strong>ETL工具</strong>(如Oracle的OWB、SQL Server 2000的DTS、SQL Server2005的SSIS服务、Informatic等)实现</p><p>（2）利用<strong>SQL方式</strong>实现</p><p>（3）通过<strong>ETL工具和SQL相结合</strong>。</p><p>优缺点比较：</p><p>借助ETL工具可以快速的建立起ETL工程，屏蔽了复杂的编码任务，提高了速度，降低了难度，但是缺少灵活性。SQL的方法优点是灵活，提高ETL运行效率，但是编码复杂，对技术要求比较高。第三种是综合了前面二种的优点，会极大地提高ETL的开发速度和效率。</p><p><strong>数据抽取<strong><strong>——</strong></strong>数据抽取的概念</strong></p><p>​    数据抽取就是一个从数据源中抽取数据的过程。具体来说，就是搜索整个数据源，使用某些标准选择合乎要求的数据，并把这些数据传送到目标文件中。</p><p>Ø对于数据仓库来说，必须根据增量装载工作和初始完成装载的变化来抽取数据。</p><p>Ø对于操作型系统来说，则需要一次性抽取和数据转换，这两个因素增加了数据抽取工作的复杂性。</p><h2 id="数据爬虫技术"><a href="#数据爬虫技术" class="headerlink" title="数据爬虫技术"></a>数据爬虫技术</h2><p>爬虫是一种获取数据的工具，通过URL（统一资源定位符，互联网资源存放位置的标准地址）对互联网进行尽可能广泛的遍历。在网络爬虫的系统框架中，主过程由控制器，解析器，资源库三部分组成。</p><p>Ø<strong>控制器</strong>：主要工作是负责给多线程中的各个爬虫线程分配工作任务。</p><p>Ø<strong>解析器</strong>：主要工作是下载网页，进行页面的处理，主要是将一些JS脚本标签、CSS代码内容、空格字符、HTML标签等内容处理掉，爬虫的基本工作是由解析器完成。</p><p>Ø<strong>资源库</strong>：用来存放下载到的网页资源，一般都采用大型的数据库存储，如Oracle数据库，并对其建立索引。</p><h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a><strong>基本流程</strong></h3><p><strong>1．发起请求</strong></p><p>​    通过HTTP库向目标站点发起请求，即发送一个Request，请求可以包含额外的headers等信息，等待服务器响应。爬虫从已经初始化好的网页链接队列中取出种子链接（如<a href="http://www.csdn.net等),通过这些种子链接不断地从互联网中获得新的网页数据./">http://www.csdn.net等），通过这些种子链接不断地从互联网中获得新的网页数据。</a></p><p><strong>2．获取响应内容</strong></p><p>​    如果服务器能正常响应，会得到一个Response，Response的内容便是所要获取的页面内容，类型可能有HTML，Json字符串，二进制数据（如图片视频）等类型。通过网页链接下载相应网页数据，通过分析网页数据提取新的链接存储到链接的后续队列中，且将访问过的网页链接进行已访问标记。</p><p><strong>3．解析内容</strong></p><p>​    依次不间断地从队列中获取链接并逐一访问，理论上链接集合中的所有链接均被访问后，爬虫将停止工作。得到的内容可能是HTML，可以用正则表达式、网页解析库进行解析。可能是Json，可以直接转为Json对象解析，可能是二进制数据，可以做保存或者进一步的处理。</p><p><strong>4．保存数据</strong></p><p>​    保存形式多样，可以存为文本，也可以保存至数据库，或者保存特定格式的文件。</p><h3 id="不同种类的爬虫"><a href="#不同种类的爬虫" class="headerlink" title="不同种类的爬虫"></a><strong>不同种类的爬虫</strong></h3><h4 id="通用爬虫"><a href="#通用爬虫" class="headerlink" title="通用爬虫"></a><strong>通用爬虫</strong></h4><p>（1）从互联网中选出一部分网站页面，将这些页面的URL地址作为URL种子集，将URL种子集中的URL链接依次加入到URL爬取队列中</p><p>（2）爬虫工作从爬取队列中读出页面的URL地址</p><p>（3）将网页的URL链接地址进行DNS域名解析，变为网站服务器IP地址</p><p>（4）网页下载器根据IP地址复制下载页面内容。</p><p>（5）从互联网进行网页下载</p><p>（6）这些页面内容被存储到页面库中，等待对其建立索引。</p><p>（7）为了避免抓取到相同的页面，会有一个存放已经抓取过的网页URL信息的队列。</p><p>（8）从被下载的页面中解析出其包含的URL链接，根据上文提到的已抓取URL队列，判断这些URL链接是否爬取过。</p><p>（9）如果还没有被爬取，则在URL爬取队列末尾加入该链接，等待后续爬虫任务抓取该网页内容。</p><p>（10）直至URL爬取队列为空，爬虫过程停止。</p><p>一个通用爬虫的整体工作流程，从宏观的角度来看动态爬取网页的过程，考虑到爬虫工作和互联网所有网页之间的关系，大致可以将这些网页划分为以下五类：</p><p>  1）<strong>已下载网页集合</strong>：是指爬虫系统已经从互联网下载到本地等待进行索引工作的网页集合。</p><p>  2）<strong>已过期网页集合</strong>：是指考虑到爬虫过程持续时间过长而网页在这个过程中发生了改变，特别是指同一个URL链接代表的已经被爬取下载到本地的网页，和实际该URL链接在互联网中链向的网页内容不一致的情况。</p><p>  3）<strong>待下载网页集合</strong>：是指处于URL待爬取队列中的URL地址指向的网页，爬虫系统网页下载器即将下载这些网页。</p><p>  4）<strong>可知网页集合</strong>：是指那些没有出现在URL待爬取队列中、也没有被爬虫系统下载的网页，但是通过已被爬取下载的网页或者在URL待爬取队列中的网页的链接关系，可以发现这些可知网页，稍后会被爬虫系统抓取并建立索引。</p><p>  5）<strong>不可知网页集合</strong>：是指爬虫无法爬取到的一些网页。不可知网页在实际情况中占据了很高的比例。</p><h4 id="主题爬虫"><a href="#主题爬虫" class="headerlink" title="主题爬虫"></a><strong>主题爬虫</strong></h4><p>主题爬虫目的是抓取与事先规定的某个主题范围相关的网页，在主题爬虫过程中，建立初始URL集合，集合中的URL链接必须紧扣要爬取的主题</p><p>与通用网络爬虫不同之处，主题爬虫对要爬取的页面使用某些算法进行主题判断，将主题无关的网页排除，在系统不断爬取网页的过程中，将与主题相关的网页URL链接加入URL待抓取队列中，然后根据指定的搜索策略选择抓取待抓取队列中网页，如此循环，直到满足爬虫停止条件。</p><p>主题爬虫需要尽可能多地识别并爬取相关主题的网页，避免下载主题无关的网页。</p><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16684358131971668435812768.png"></p><h4 id="分布式爬虫"><a href="#分布式爬虫" class="headerlink" title="分布式爬虫"></a><strong>分布式爬虫</strong></h4><p>在面对海量数据时，商业搜索引擎为了在较短的时间内抓取到尽可能多的网页数据，其后台爬虫模式离不开分布式的网络爬虫架构。分布式网路爬虫架构体系使用<strong>多层级模式</strong>，保证了爬取网页的及时性与覆盖面。</p><p>一个大型分布式爬虫分为3个层级：<strong>分布式数据中心、分布式抓取服务器及分布式爬虫程序</strong>，多个爬虫程序运行在一台抓取服务器上，多个抓取服务器构成抓取集群，也就是分布式数据中心。</p><p>常见的分布式爬虫系统架构，根据不同机器之间分工协同方式的差异可以分为两种：<strong>主从式分布爬虫和对等式分布爬虫</strong>。两者各有优势，也各有缺陷。</p><p><strong>主从式分布爬虫</strong></p><p>   对于主从式来讲，不同的机器分工明确，有一台Master机器是控制节点负责将URL任务分发到其他Slave机器、维护URL待爬取队列和管理各个Slave机器的负载均衡，Slave机器执行下载网页的工作，Slave机器与Slave机器不能直接通信。主从式分布爬虫模式下，Master机器容易成为爬虫系统的瓶颈导致整个爬虫性能的下降。</p><p>Master往往容易成为系统瓶颈</p><p><strong>对等分布式爬虫</strong></p><p>​    对于对等式来讲，所有的抓取机器在分工上没有不同，每台机器可以独立完成网页爬取任务。每台抓取器之间的分工有一定的运算逻辑(如哈希取模，hash[域名]%m，m为抓取机器数量)，将运算值发送到对应编号相同机器上，由运算的结果来决定由哪台服务器做抓取网页的工作。</p><p>这种方式的扩展性不佳，当有一台服务器死机或者添加新的服务器，那么所有URL的哈希求余的结果就都要变化。</p><h3 id="大数据爬虫的相关技术"><a href="#大数据爬虫的相关技术" class="headerlink" title="大数据爬虫的相关技术"></a><strong>大数据爬虫的相关技术</strong></h3><p><strong>（1）爬虫协议</strong></p><p>​    爬虫协议即Robots协议，其全称为“网络爬虫排除协议”，网站通过Robots协议告诉我们网站中哪些数据可以被爬取，哪些数据不可以被爬取。当我们使用爬虫时也应当尊重网站的意愿并帮助其保护隐私。若网站没有设置爬虫协议，那么我们就默认允许各种爬虫操作。</p><p>​    爬虫协议的内容为一个robots.txt，我们在浏览器上输入“<a href="https://www.csdn.net/robots.txt%E2%80%9D%EF%BC%8C%E5%8D%B3%E5%8F%AF%E6%9F%A5%E7%9C%8BCSDN%E8%AE%BA%E5%9D%9B%E7%9A%84%E7%88%AC%E8%99%AB%E5%8D%8F%E8%AE%AE%E4%BA%86%E3%80%82%E5%A6%82%E5%8F%B3%E5%9B%BE%E6%89%80%E7%A4%BA%E3%80%82">https://www.csdn.net/robots.txt”，即可查看CSDN论坛的爬虫协议了。如右图所示。</a></p><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16684358911971668435890906.png"></p><p><strong>（2）链接提取</strong></p><p>​    链接提取我们可以采用正则表达式的方式。对于一个链接例如“<a href=”**https://www.csdn.net/**” target=”_blank”><strong>大数据</strong></a>”需要提取两部分内容，一个是“a”标签中链接描述的信息，以及“href”中对应的链接。</p><p><strong>（3）链接去重</strong></p><p>   爬虫每次进行页面分析都会获取新的链接，在这些链接集合中难免会有重复，通过链接去重可以提升数据采集的准确率，提高效率。</p><p><strong>（4）非网页数据获取</strong></p><p>   所谓的非网页数据，主要包括Excel、txt、Word、PDF、PPT以及RSS等，除txt文件可以直接进行数据读取之外，其他非网页数据必须要借助相应的读取引擎进行内容获取。PDF的读取引擎是Apache PDFBox或者是xpdf，Word、Excel、ppt的读取引擎为Apache POI。</p><p><strong>（5）网页去重</strong></p><p>  对于网页相似一般有三种情况。完全相似、内容相似和局部相似。</p><p>n第一种完全相似，指不仅仅内容上一致，在网页布局格式上也一致，此类完全重复一般发生在同一个站点的多个域名下。</p><p>第二种内容相似，指文档内容相同，页面布局格式不同，这种情况一般发生于转载。</p><p>第三种局部相似，指对于网页的内容有部分相似，这类情况大多发生于文章段落的引用。</p><p>   针对这种情况，google采用了一种Simhash算法，利用赋予文档指纹的概念，来解决大数据爬虫网页去重这个问题，即指纹相似度越高，重复率越高。</p><p>（具体介绍可以参考Google在2007年发表的论文《Detecting Near-Duplicates for Web Crawling》）</p><p><strong>（6）广告识别</strong></p><p>​    网页中存在大量噪声，包括头部导航栏、侧边栏和广告信息等。导航栏和侧边栏可以通过正文提取时，根据文字分布情况过滤，但是广告信息复杂多变，其存在不光对我们信息的读取造成影响而且占用不必要的内存空间。如何有效过滤广告也是我们应该了解的技术。</p><p>   在实际应用中，我们可以借鉴Adblock plus的思想。Adblock plus是著名的广告过滤插件，其对于浏览器在对广告鉴别方式有比较好的借鉴作用：判定页面的元素是不是广告，并不需要通过分析网页结构、机器学习的方式，而是如果大家都浏览过这些页面，而且判定这些页面中某些元素是广告，那么Adblock plus则认定这就是广告。</p><h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a><strong>数据预处理</strong></h2><p>实际的数据库极易受噪声、缺失值和不一致数据的侵扰，因为数据库太大，并且多半来自多个异种数据源。低质量的数据将会导致低质量的挖掘结果。因此我们需要使用数据预处理技术：<br>（1）数据清理<br>     可以用来清除数据中的噪声<br>（2）数据集成<br>     将数据由多个数据源合并成一个一致的数据存储，如数据仓库或数据立方体<br>（3）数据变换<br>     例如，规范化可以改进涉及距离度量的挖掘算法的精度和有效性，如0.0到1.0。<br>（4）数据归约<br>     可以通过如聚集、删除冗余特征或聚类等方法来降低数据的规模。</p><h2 id="数据清理"><a href="#数据清理" class="headerlink" title="数据清理"></a><strong>数据清理</strong></h2><p>现实世界的数据一般是不完整的、有噪声的和不一致的。数据清理例程试图填充缺失的值、光滑噪声并识别离群点、纠正数据中的不一致。</p><h3 id="缺失值"><a href="#缺失值" class="headerlink" title="缺失值"></a><strong>缺失值</strong></h3><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16684360111951668436010585.png"></p><h3 id="噪声数据"><a href="#噪声数据" class="headerlink" title="噪声数据"></a><strong>噪声数据</strong></h3><p>噪声(noise)是被测量的变量的随机误差或方差。我们可以使用基本的数据统计描述技术(例如，盒图或者散点图)和数据可视化方法来识别可能代表噪声的离群点。</p><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16684360470071668436045433.png"></p><h3 id="数据集成"><a href="#数据集成" class="headerlink" title="数据集成"></a><strong>数据集成</strong></h3><p>   数据分析任务多半要涉及到数据集成。数据集成将多个数据源中的数据结合起来存放在一个一致的数据存储中。这些数据源可能包括多个数据库、数据立方体或一般文件。</p><p>   将多个数据源中的数据集成起来，能够减少或避免结果数据集中数据的冗余和不一致性。这有助于提高其后挖掘的精度和速度。</p><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16684360712301668436071195.png"></p><h3 id="数据变换"><a href="#数据变换" class="headerlink" title="数据变换"></a><strong>数据变换</strong></h3><p>数据变换就是将数据转换成适合于挖掘的形式。数据变换可能涉及到如下内容：</p><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16684361041961668436103586.png"></p><h3 id="数据规约"><a href="#数据规约" class="headerlink" title="数据规约"></a><strong>数据规约</strong></h3><p>在数据清理、集成与变换后，我们能够得到整合了多数据源同时数据质量完好的数据集。但是，集成与清洗无法改变数据集的规模。我们依然需通过技术手段降低数据规模，这就是数据归约（Data Reduction）。</p><p>  用一句话来说，数据归约就是缩小数据挖掘所需的数据集规模，具体方式有<strong>维度规约</strong>与<strong>数量规约</strong>。</p><h1 id="第四章-分布式平台Hadoop"><a href="#第四章-分布式平台Hadoop" class="headerlink" title="第四章 分布式平台Hadoop"></a><strong>第四章 分布式平台Hadoop</strong></h1><h2 id="Hadoop简介"><a href="#Hadoop简介" class="headerlink" title="Hadoop简介"></a><strong>Hadoop简介</strong></h2><p>Hadoop最初是由Apache Lucene项目的创始人Doug Cutting开发的文本搜索库。Hadoop源自始于2002年的Apache Nutch项目——一个开源的网络搜索引擎并且也是Lucene项目的一部分</p><p>在2004年，Nutch项目也模仿<strong>GFS</strong>开发了自己的分布式文件系统<strong>NDFS</strong>（Nutch Distributed File System），也就是HDFS的前身</p><p>2004年，谷歌公司又发表了另一篇具有深远影响的论文，阐述了MapReduce分布式编程思想</p><p>2005年，Nutch开源实现了谷歌的MapReduce</p><p>2006年2月，Nutch中的NDFS和MapReduce开始独立出来，成为Lucene项目的一个子项目，称为Hadoop，同时，Doug Cutting加盟雅虎</p><p>2008年1月，Hadoop正式成为Apache顶级项目，Hadoop也逐渐开始被雅虎之外的其他公司使用</p><p>2008年4月，Hadoop打破世界纪录，成为最快排序1TB数据的系统，它采用一个由910个节点构成的集群进行运算，排序时间只用了209秒</p><p>在2009年5月，Hadoop更是把1TB数据排序时间缩短到62秒。Hadoop从此名声大震，迅速发展成为大数据时代最具影响力的开源分布式开发平台，并成为事实上的大数据处理标准。</p><h2 id="Hadoop的特性"><a href="#Hadoop的特性" class="headerlink" title="Hadoop的特性"></a><strong>Hadoop的特性</strong></h2><p>Hadoop是一个能够对大量数据进行分布式处理的软件框架，并且是以一种可靠、高效、可伸缩的方式进行处理的，它具有以下几个方面的特性：<br>（1）高可靠性<br>      Hadoop成立之初就是假设计算和存储会失败，它维护多个工作数据副本，确保能够针对失败的节点重新分布处理。<br>（2）高扩展性<br>      Hadoop是在可用的计算机集群间分配数据并完成计算任务的，这些集群可以方便地扩展到数以千计的节点中。<br>（3）高效性<br>      Hadoop能够在节点之间动态地移动数据，并保证各个节点的动态负载平衡，因此处理速度非常快。</p><p>（4）高容错性<br>Hadoop能够自动将数据保存为多个副本，并且能够自动将失败的任务重新分配。<br>（5）低成本<br>与一体机、商用数据仓库以及QlikView、SpotView等数据集市相比，Hadoop是开源的，项目的软件成本因此大大降低。</p><p>•Hadoop被视为事实上的大数据处理标准，本章介绍了Hadoop的发展历程，并阐述了Hadoop的高可靠性、高效性、高可扩展性、高容错性、成本低、运行在Linux平台上、支持多种编程语言等特性</p><p>•Hadoop目前已经在各个领域得到了广泛的应用，雅虎、Facebook、百度、淘宝、网易等公司都建立了自己的Hadoop集群</p><p>•经过多年发展，Hadoop项目已经变得非常成熟和完善，包括Common、Avro、Zookeeper、HDFS、MapReduce、HBase、Hive、Chukwa、Pig等子项目，其中，HDFS和MapReduce是Hadoop的两大核心组件。</p><h1 id="第5章-分布式文件系统HDFS"><a href="#第5章-分布式文件系统HDFS" class="headerlink" title="第5章 分布式文件系统HDFS"></a><strong>第5章 分布式文件系统HDFS</strong></h1><p>分布式文件系统把文件分布存储到<strong>多个计算机节点上</strong>，成千上万的计算机节点构成计算机集群</p><p>与之前使用多个处理器和专用高级硬件的并行化处理装置不同的是，目前的分布式文件系统所采用的<strong>计算机集群</strong>，都是由<strong>普通硬件</strong>构成的，这就大大降低了硬件上的开销</p><p>分布式文件系统在物理结构上是由计算机集群中的多个节点构成的，这些节点分为两类，一类叫“主节点”(Master Node)或者也被称为“名称结点”(NameNode)，另一类叫“从节点”（Slave Node）或者也被称为“数据节点”(DataNode)</p><p>总体而言，HDFS要实现以下目标：</p><p>•兼容廉价的硬件设备</p><p>•流数据读写</p><p>•大数据集</p><p>•简单的文件模型</p><p>•强大的跨平台兼容性</p><p>HDFS特殊的设计，在实现上述优良特性的同时，也使得自身具有一些应用局限性，主要包括以下几个方面：</p><p>•不适合低延迟数据访问</p><p>•无法高效存储大量小文件</p><p>•不支持多用户写入及任意修改文件</p><p>•分布式文件系统是大数据时代解决大规模数据存储问题的有效解决方案，HDFS开源实现了GFS，可以利用由廉价硬件构成的计算机集群实现海量数据的分布式存储</p><p>•HDFS具有兼容廉价的硬件设备、流数据读写、大数据集、简单的文件模型、强大的跨平台兼容性等特点。但是，也要注意到，HDFS也有自身的局限性，比如不适合低延迟数据访问、无法高效存储大量小文件和不支持多用户写入及任意修改文件等</p><p>•块是HDFS核心的概念，一个大的文件会被拆分成很多个块。HDFS采用抽象的块概念，具有支持大规模文件存储、简化系统设计、适合数据备份等优点</p><p>•HDFS采用了主从（Master&#x2F;Slave）结构模型，一个HDFS集群包括一个名称节点和若干个数据节点。名称节点负责管理分布式文件系统的命名空间；数据节点是分布式文件系统HDFS的工作节点，负责数据的存储和读取</p><p>•HDFS采用了冗余数据存储，增强了数据可靠性，加快了数据传输速度。HDFS还采用了相应的数据存放、数据读取和数据复制策略，来提升系统整体读写响应性能。HDFS把硬件出错看作一种常态，设计了错误恢复机制</p><h1 id="第6章-MapReduce基础"><a href="#第6章-MapReduce基础" class="headerlink" title="第6章 MapReduce基础"></a><strong>第6章 MapReduce基础</strong></h1><p>在MapReduce出现之前，已经有HPC(High Performance Computing)这样非常成熟的并行计算框架了，那么为什么Google还需要MapReduce？MapReduce相较于传统的并行计算框架有什么优势？</p><table><thead><tr><th></th><th><strong>传统并行计算框架</strong></th><th><strong>MapReduce</strong></th></tr></thead><tbody><tr><td>集群架构&#x2F;容错性</td><td>共享式(共享内存&#x2F;共享存储)，<strong>容错性差</strong></td><td>非共享式，<strong>容错性好</strong></td></tr><tr><td>硬件&#x2F;价格&#x2F;扩展性</td><td>刀片服务器、高速网、SAN，价格贵，<strong>扩展性差</strong></td><td>普通PC机，便宜，<strong>扩展性好</strong></td></tr><tr><td>编程&#x2F;学习难度</td><td>what-how，<strong>难</strong></td><td>what，<strong>简单</strong></td></tr><tr><td>适用场景</td><td>实时、计算密集型</td><td>非实时、数据密集型</td></tr></tbody></table><p>高性能计算(High Performance Computing)机群，简称HPC机群。构建高性能计算系统的主要目的就是提高运算速度，要达到每秒万亿次级的计算速度，对系统的处理器、内存带宽、运算方式、系统I&#x2F;O、存储等方面的要求都十分高，这其中的每一个环节都将直接影响到系统的运算速度。</p><h2 id="MapReduce模型简介"><a href="#MapReduce模型简介" class="headerlink" title="MapReduce模型简介"></a>MapReduce模型简介</h2><p>MapReduce将复杂的、运行于大规模集群上的并行计算过程高度地抽象到了两个函数：Map和Reduce</p><p>编程容易，不需要掌握分布式并行编程细节，也可以很容易把自己的程序运行在分布式系统上，完成海量数据的计算</p><p>MapReduce采用“<strong>分而治之</strong>”策略，一个存储在分布式文件系统中的大规模数据集，会被切分成许多独立的分片（split），这些分片可以被多个Map任务并行处理</p><p>MapReduce设计的一个理念就是“<strong>计算向数据靠拢</strong>”，而不是“数据向计算靠拢”，因为，移动数据需要大量的网络传输开销</p><p>MapReduce框架采用了<strong>Master&#x2F;Slave架构</strong>，包括一个Master和若干个Slave。Master上运行JobTracker，Slave上运行TaskTracker</p><p>Hadoop框架是用Java实现的，但是，MapReduce应用程序则不一定要用Java来写</p><table><thead><tr><th><strong>函数</strong></th><th><strong>输入</strong></th><th><strong>输出</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>Map</td><td>&lt;*k*1,v1&gt;  如：  &lt;行号,”a b c”&gt;</td><td>List(&lt;*k*2,*v*2&gt;)  如：  &lt;“a”,1&gt;  &lt;“b”,1&gt;  &lt;“c”,1&gt;</td><td>1.将小数据集进一步解析成一批&lt;key,value&gt;对，输入Map函数中进行处理  2.每一个输入的&lt;*k*1,*v*1&gt;会输出一批&lt;*k*2,*v*2&gt;。&lt;*k*2,*v*2&gt;是计算的中间结果</td></tr><tr><td>Reduce</td><td>&lt;*k*2,List(*v*2)&gt;  如：&lt;“a”,&lt;1,1,1&gt;&gt;</td><td>&lt;*k*3,*v*3&gt;  &lt;“a”,3&gt;</td><td>输入的中间结果&lt;<em>k*2,List(<em>v</em>2)&gt;中的List(<em>v</em>2)表示是一批属于同一个</em>k*2的value</td></tr></tbody></table><p>MapReduce体系结构主要由四个部分组成，分别是：Client、JobTracker、TaskTracker以及Task</p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16682469591221668246958771.png" style="zoom:80%;" /><p>MapReduce主要有以下4个部分组成：</p><p><strong>1</strong>）Client</p><ul><li>用户编写的MapReduce程序通过Client提交到JobTracker端</li><li>用户可通过Client提供的一些接口查看作业运行状态</li></ul><p><strong>2</strong>）JobTracker</p><p>JobTracker负责资源监控和作业调度</p><p>JobTracker 监控所有TaskTracker与Job的健康状况，一旦发现失败，就将相应的任务转移到其他节点</p><p>JobTracker 会跟踪任务的执行进度、资源使用量等信息，并将这些信息告诉任务调度器（TaskScheduler），而调度器会在资源出现空闲时，选择合适的任务去使用这些资源</p><p><strong>3</strong>）TaskTracker</p><p>TaskTracker 会周期性地通过<strong>“心跳”</strong>将本节点上资源的使用情况和任务的运行进度汇报给JobTracker，同时接收JobTracker 发送过来的命令并执行相应的操作（如启动新任务、杀死任务等）</p><p>TaskTracker 使用<strong>slot</strong>等量划分本节点上的资源量（CPU、内存等）。一个Task 获取到一个slot 后才有机会运行，而Hadoop调度器的作用就是将各个TaskTracker上的空闲slot分配给Task使用。slot 分为<strong>Map slot</strong> 和<strong>Reduce slot</strong> 两种，分别供<strong>MapTask</strong> 和<strong>Reduce Task</strong> 使用</p><p><strong>4</strong>）Task</p><p>Task 分为Map Task 和Reduce Task 两种，均由TaskTracker 启动</p><h2 id="MapReduce工作流程"><a href="#MapReduce工作流程" class="headerlink" title="MapReduce工作流程"></a>MapReduce工作流程</h2><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16682470581291668247057468.png" style="zoom:80%;" /><p>不同的Map任务之间不会进行通信</p><p>不同的Reduce任务之间也不会发生任何信息交换</p><p>用户不能显式地从一台机器向另一台机器发送消息</p><p>所有的数据交换都是通过MapReduce框架自身去实现的</p><p><strong>关于Split（分片）</strong></p><p>HDFS 以固定大小的block 为基本单位存储数据，而对于MapReduce 而言，其处理单位是split。split 是一个逻辑概念，它只包含一些元数据信息，比如数据起始位置、数据长度、数据所在节点等。它的划分方法完全由<strong>用户自己决定，</strong>每片的默认最大值和每块的默认值<strong>128M</strong>相同。</p><p><strong>Map任务的数量</strong></p><p><strong>Map任务的数量</strong></p><p>•Hadoop为每个split创建一个Map任务，split 的多少决定了Map任务的数目。大多数情况下，理想的分片大小是一个HDFS块</p><p><strong>Reduce任务的数量</strong></p><p>•最优的Reduce任务个数取决于集群中可用的reduce任务槽(slot)的数目</p><p>•通常设置比reduce任务槽数目稍微小一些的Reduce任务个数（这样可以预留一些系统资源处理可能发生的错误）</p><h2 id="Shuffle"><a href="#Shuffle" class="headerlink" title="Shuffle"></a><strong>Shuffle</strong></h2><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16682471871231668247186494.png" style="zoom:80%;" /><ul><li>此阶段，将map的输出经过“整理”后给到reduce，也称为“<strong>混洗</strong>”。分为map端操作和reduce端操作。</li><li>在map端，map的输出先写入缓存，当每次缓存快满时，由缓存“<strong>溢写</strong>”至磁盘，每次溢写都先进行“分区”，并对每个分区的数据进行“<strong>排序</strong>”和“<strong>合并</strong>”（可选）。一般会产生多个溢写的文件，这些文件会在map端先被“归并”为一个大的磁盘文件，通知reduce任务来领取自己的分区。</li><li>在reduce端，每个reduce任务会从多个map任务领取文件，然后将这些文件进行“<strong>归并</strong>”，交给reduce任务。</li></ul><h2 id="Map端的Shuffle过程"><a href="#Map端的Shuffle过程" class="headerlink" title="Map端的Shuffle过程"></a><strong>Map端的Shuffle过程</strong></h2><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16682472431311668247242784.png" style="zoom:80%;" /><p>•每个Map任务分配一个缓存</p><p>•MapReduce默认100MB缓存</p><p>•设置溢写比例0.8</p><p>•分区默认采用哈希函数</p><p>•排序是默认的操作</p><p>•排序后可以合并（Combine）</p><p>•合并不能改变最终结果</p><p>•在Map任务全部结束之前进行归并</p><p>•归并得到一个大的文件，放在本地磁盘</p><p>•文件归并时，如果溢写文件数量大于预定值（默认是3）则可以再次启动Combiner，少于3不需要</p><p>•JobTracker会一直监测Map任务的执行，并通知Reduce任务来领取数据</p><p>合并（Combine）和归并（Merge）的区别：</p><p>两个键值对&lt;“a”,1&gt;和&lt;“a”,1&gt;，如果合并，会得到&lt;“a”,2&gt;，如果归并，会得到&lt;“a”,&lt;1,1&gt;&gt;</p><h2 id="Reduce端的Shuffle过程"><a href="#Reduce端的Shuffle过程" class="headerlink" title="Reduce端的Shuffle过程"></a><strong>Reduce端的Shuffle过程</strong></h2><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16682473361261668247335655.png" style="zoom: 80%;" /><p>•Reduce任务通过RPC向JobTracker询问Map任务是否已经完成，若完成，则领取数据</p><p>•Reduce领取数据先放入缓存，来自不同Map机器，先归并，再合并，写入磁盘</p><p>•多个溢写文件归并成一个或多个大文件，文件中的键值对是排序的</p><p>•当数据很少时，不需要溢写到磁盘，直接在缓存中归并，然后输出给Reduce</p><h2 id="MapReduce应用程序执行过程"><a href="#MapReduce应用程序执行过程" class="headerlink" title="MapReduce应用程序执行过程"></a>MapReduce应用程序执行过程</h2><ol><li>用户编写Map和Reduce程序，选择一个节点作为Master来运行JobTracker；选择其他若干节点作为TaskTracker运行Map或Reduce程序</li><li>把Map和Reduce程序任务分发到各个Map或Reduce节点中</li><li>RR从HDFS读取InputFormat产生的分片所对应的文件数据，转换为键值对</li><li>Map任务处理RR产生的键值对，Map输出结果经过Shuffle(分区、排序、合并)后把分区好的数据写入Map任务所在节点的本地硬盘中(不是HDFS中，中间结果只需临时存储，不需要分布式存储)</li><li>Map任务执行完毕后通知JobTracker，JobTracker通知Reduce任务读取Map输出的已分区的键值对文件中属于本Reduce任务处理的分区数据；对读取的数据归并后，执行Reduce处理</li><li>Reduce输出的键值对进行归并和合并后，由OutputFormat检查并写入HDFS中</li></ol><h2 id="MapReduce的具体应用"><a href="#MapReduce的具体应用" class="headerlink" title="MapReduce的具体应用"></a>MapReduce的具体应用</h2><p>MapReduce可以很好地应用于各种计算问题</p><p>•关系代数运算（选择、投影、并、交、差、连接）</p><p>•分组与聚合运算</p><p>•矩阵-向量乘法</p><p>•矩阵乘法</p><p><strong>用MapReduce实现关系的自然连接</strong></p><p>假设有关系R(A，B)和S(B,C)，对二者进行自然连接操作</p><p>使用Map过程，把来自R的每个元组&lt;a,b&gt;转换成一个键值对&lt;b, &lt;R,a&gt;&gt;，其中的键就是属性B的值。把关系R包含到值中，这样做使得我们可以在Reduce阶段，只把那些来自R的元组和来自S的元组进行匹配。类似地，使用Map过程，把来自S的每个元组&lt;b,c&gt;，转换成一个键值对&lt;b,&lt;S,c&gt;&gt;</p><p>所有具有相同B值的元组被发送到同一个Reduce进程中，Reduce进程的任务是，把来自关系R和S的、具有相同属性B值的元组进行合并</p><p>Reduce进程的输出则是连接后的元组&lt;a,b,c&gt;，输出被写到一个单独的输出文件中</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>•MapReduce执行的全过程包括以下几个主要阶段：从分布式文件系统读入数据、执行Map任务输出中间结果、通过 Shuffle阶段把中间结果分区排序整理后发送给Reduce任务、执行Reduce任务得到最终结果并写入分布式文件系统。在这几个阶段中，Shuffle阶段非常关键，必须深刻理解这个阶段的详细执行过程</p><p>•MapReduce具有广泛的应用，比如关系代数运算、分组与聚合运算、矩阵-向量乘法、矩阵乘法等</p><h1 id="第7章-大数据存储技术"><a href="#第7章-大数据存储技术" class="headerlink" title="第7章 大数据存储技术"></a><strong>第7章 大数据存储技术</strong></h1><h2 id="云计算是云数据库兴起的基础"><a href="#云计算是云数据库兴起的基础" class="headerlink" title="云计算是云数据库兴起的基础"></a>云计算是云数据库兴起的基础</h2><h3 id="云计算概念"><a href="#云计算概念" class="headerlink" title="云计算概念"></a>云计算概念</h3><p>•通过整合、管理、调配分布在网络各处的计算资源，通过互联网以统一界面，同时向大量的用户提供服务</p><h3 id="云计算特点"><a href="#云计算特点" class="headerlink" title="云计算特点"></a>云计算特点</h3><p>超大规模计算、虚拟化、高可靠性和安全性、通用性、动态扩展性、按需服务、降低成本</p><h3 id="云计算应用场景"><a href="#云计算应用场景" class="headerlink" title="云计算应用场景"></a>云计算应用场景</h3><ul><li>Google个人云服务</li><li>华为云开发环境</li><li>各类云盘</li></ul><h3 id="云计算八大优势"><a href="#云计算八大优势" class="headerlink" title="云计算八大优势"></a>云计算八大优势</h3><ol><li>按需服务</li><li>随时服务</li><li>通用性</li><li>高可靠性</li><li>极其廉价</li><li>超大规模</li><li>虚拟化</li><li>高扩展性</li></ol><h2 id="云数据库概念"><a href="#云数据库概念" class="headerlink" title="云数据库概念"></a>云数据库概念</h2><p><strong>云数据库</strong>是部署和虚拟化在<strong>云计算环境中的数据库</strong>。云数据库是在云计算的大背景下发展起来的一种新兴的共享基础架构的方法，它极大地增强了数据库的存储能力，消除了人员、硬件、软件的重复配置，让软、硬件升级变得更加容易。云数据库具有<strong>高可扩展性</strong>、<strong>高可用性</strong>、采用多租形式和支持资源有效分发等特点。 </p><h3 id="云数据库与云存储有什么区别？"><a href="#云数据库与云存储有什么区别？" class="headerlink" title="云数据库与云存储有什么区别？"></a><strong>云数据库与云存储有什么区别？</strong></h3><p><strong>从对应的层面来讲</strong></p><ol><li>云存储：是在资源层，即云的<strong>IaaS层</strong>，提供的是存储资源能力。</li><li>云数据库：是在平台层，即云的<strong>PaaS层</strong>，提供的是中间件服务能力。本地的数据库迁移到云端对应云数据库，而本地的硬盘迁移到云端只能对应云存储。</li></ol><p><strong>从提供的服务来说</strong></p><ol><li>云存储：提供<strong>存储能力</strong>，更多面对的场景是非结构化类数据，如文件，图片，视频等。</li><li>云数据库：提供基础的<strong>数据库和数据对象管理能力</strong>，既包括oracle, mysql,sql server等关系型数据库，也可以包括类似mongodb，hbase等半结构化数据库。</li></ol><p><strong>从两者的关系来说</strong></p><ul><li>对于云存储当前基本都基于类似hdfs分布式文件系统进行封装，提供存储服务能力接口。也可以基于hdfs上面再架构一层，形成一个数据库，再将数据库能力暴露出去，形成云数据库，类似HBase。但是对于常见的关系型数据库，也可以做为云数据库，但是他们底层可以不依赖的云存储能力。</li></ul><h3 id="云数据库具有以下特性："><a href="#云数据库具有以下特性：" class="headerlink" title="云数据库具有以下特性："></a>云数据库具有以下特性：</h3><ol><li>动态可扩展</li><li>高可用性</li><li>较低的使用代价</li><li>易用性</li><li>高性能</li><li>免维护</li><li>安全</li></ol><h2 id="云数据库是个性化数据存储需求的理想选择"><a href="#云数据库是个性化数据存储需求的理想选择" class="headerlink" title="云数据库是个性化数据存储需求的理想选择"></a>云数据库是个性化数据存储需求的理想选择</h2><p>企业类型不同，对于存储的需求也千差万别，而云数据库可以很好地满足不同企业的个性化存储需求：</p><p>•首先，云数据库可以满足大企业的海量数据存储需求</p><p>•其次，云数据库可以满足中小企业的低成本数据存储需求</p><p>•另外，云数据库可以满足企业动态变化的数据存储需求 </p><p>到底选择自建数据库还是选择云数据库，取决于企业自身的具体需求</p><p>•对于一些大型企业，目前通常采用自建数据库</p><p>•对于一些财力有限的中小企业而言，IT预算比较有限，云数据库这种前期零投入、后期免维护的数据库服务，可以很好满足它们的需求 </p><p>•从数据模型的角度来说，云数据库并非一种全新的数据库技术，而只是以服务的方式提供数据库功能</p><p><strong>云数据库并没有专属于自己的数据模型</strong>，云数据库所采用的数据模型可以是关系数据库所使用的关系模型（微软的SQL Azure云数据库、阿里云RDS都采用了关系模型），也可以是NoSQL数据库所使用的非关系模型（Amazon Dynamo云数据库采用的是“键&#x2F;值”存储）</p><p>•同一个公司也可能提供采用不同数据模型的多种云数据库服务</p><p>•许多公司在开发云数据库时，后端数据库都是直接使用现有的各种关系数据库或NoSQL数据库产品</p><h2 id="云数据库厂商"><a href="#云数据库厂商" class="headerlink" title="云数据库厂商"></a>云数据库厂商</h2><table><thead><tr><th>企业</th><th>产品</th></tr></thead><tbody><tr><td>Amazon</td><td>Dynamo、SimpleDB、RDS</td></tr><tr><td>Google</td><td>Google  Cloud SQL</td></tr><tr><td>Microsoft</td><td>Microsoft  SQL Azure</td></tr><tr><td>Oracle</td><td>Oracle  Cloud</td></tr><tr><td>Yahoo!</td><td>PNUTS</td></tr><tr><td>Vertica</td><td>Analytic  Database v3.0 for the Cloud</td></tr><tr><td>EnerpriseDB</td><td>Postgres  Plus in the Cloud</td></tr><tr><td>阿里</td><td>阿里云RDS</td></tr><tr><td>百度</td><td>百度云数据库</td></tr><tr><td>腾讯</td><td>腾讯云数据库</td></tr></tbody></table><p>Amazon是云数据库市场的先行者。Amazon除了提供著名的S3存储服务和EC2计算服务以外，还提供基于云的数据库服务：</p><p>•Amazon RDS：云中的关系数据库</p><p>•Amazon SimpleDB：云中的键值数据库</p><p>•Amazon DynamoDB：云中的NoSQL数据库</p><p>•Amazon Redshift：云中的数据仓库</p><p>•Amazon ElastiCache：云中的分布式内存缓存</p><h2 id="HBase分布式数据库"><a href="#HBase分布式数据库" class="headerlink" title="HBase分布式数据库"></a><strong>HBase</strong>分布式数据库</h2><h3 id="BigTable是一个分布式存储系统"><a href="#BigTable是一个分布式存储系统" class="headerlink" title="BigTable是一个分布式存储系统"></a>BigTable是一个分布式存储系统</h3><p>BigTable起初用于解决典型的互联网搜索问题</p><p>•<strong>建立互联网索引</strong></p><p>1 爬虫持续不断地抓取新页面，这些页面每页一行地存储到BigTable里</p><p>2 MapReduce计算作业运行在整张表上，生成索引，为网络搜索应用做准备</p><p>•<strong>搜索互联网</strong></p><p>3 用户发起网络搜索请求</p><p>4 网络搜索应用查询建立好的索引，从BigTable得到网页</p><p>5 搜索结果提交给用户</p><p>Bigtable是一个稀疏、分布式、持久化存储的多维有序映射表，表的索引是<strong>行关键字、列关键字和时间戳</strong> 。Bigtable中存储的表项都是未经解析的字节数组</p><p><strong>数据模型</strong></p><p><strong>行关键字</strong>可以是任意字符串，最大支持64KB。Bigtable按照行关键字的字典序组织数据，利用这个特性可以通过选择合适的行关键字，使数据访问具有良好的局部性。如Webtable中，通过将<strong>反转的URL</strong>作为行关键字，可以将同一个域名下的网页聚集在一起。</p><p>​    表的行区间可以动态划分，每个行区间称为一个<strong>子表</strong>。子表是Bigtable<strong>数据分布和负载均衡的基本单位</strong>，不同的子表可以有不同的大小。为了限制子表的移动和恢复成本，每个子表默认的最大尺寸为200MB。</p><p><strong>列族</strong></p><p>列关键字一般都表示<strong>一种数据类型</strong>，列关键字的集合称作<strong>列族</strong>，列族是<strong>访问控制的基本单位</strong> 。存储在同一列族下的数据属于同一种类型，列族下的数据被压缩在一起保存。数据在被存储之前必须先创建列族，并且表中的列族不宜过多，通常几百个，但表中可以有无限多个列 。在Bigtable中列关键字的命名语法为：“<strong>列族：限定词</strong>”，列族名称必须是可打印的字符串，限定词则可以是任意字符串。如Webtable中名为anchor的列族，该列族的每一个列关键字代表一个锚链接；anchor列族的限定词是引用网页的站点名，每列的数据项是链接文本 。</p><p><strong>时间戳</strong></p><p>​    Bigtable中的表项可以包含<strong>同一数据的不同版本</strong>，采用时间戳进行索引。时间戳是64位整型，既可以由系统赋值也可由用户指定。表项的不同版本按照时间戳倒序排列，即最新的数据排在最前面。</p><p><strong>体系结构</strong></p><p><strong>Bigtable集群包括三个主要部分：</strong></p><p><strong>供客户端使用的库</strong>，客户端需要读写数据时，直接与片服务器联系。因为客户端并不需要从主服务器获取片的位置信息，所以大多数客户端从来不需要访问主服务器，主服务器的负载一般很轻。</p><p><strong>主服务器（master server）</strong>，主服务器负责将片分配给片服务器，监控片服务器的添加和删除，平衡片服务器的负载，处理表和列族的创建等。注意，主服务器不存储任何片，不提供任何数据服务，也不提供片的定位信息。</p><p><strong>片服务器（tablet server）</strong>，每个片服务器负责一定量的片，处理对片的读写请求，以及片的分裂或合并。每个片实际由若干SSTable文件和memtable组成，而且这些SSTable和memtable都是已排序的。片服务器可以根据负载随时添加和删除。这里片服务器并不真实存储数据，而相当于一个连接Bigtable和GFS的代理，客户端的一些数据操作都通过片服务器代理间接访问GFS。</p><p>Bigtable的实现依托于Google的几个基础组件：</p><p><strong>Google File System（GFS）</strong>，一个分布式文件系统，用于存储日志和文件；</p><p><strong>Google Sorted Strings Table（SSTable）</strong>，一个不可修改的有序键值映射表，提供查询、遍历的功能；</p><p><strong>Chubby</strong>，一个高可靠用于分布式的锁服务，其目的是解决分布式一致性的问题，通过Paxos算法实现。Chubby用于片定位，片服务器的状态监控，访问控制列表存储等任务。</p><p>HBase是一个高可靠、高性能、面向列、可伸缩的<strong>分布式数据库</strong>，是谷歌BigTable的开源实现，主要用来存储非结构化和半结构化的松散数据。HBase的目标是处理非常庞大的表，可以通过水平扩展的方式，利用廉价计算机集群处理由超过10亿行数据和数百万列元素组成的数据表 </p><p>HBase和BigTable的底层技术对应关系</p><table><thead><tr><th></th><th><strong>BigTable</strong></th><th><strong>HBase</strong></th></tr></thead><tbody><tr><td>文件存储系统</td><td>GFS</td><td>HDFS</td></tr><tr><td>海量数据处理</td><td>MapReduce</td><td>Hadoop  MapReduce</td></tr><tr><td>协同服务管理</td><td>Chubby</td><td>Zookeeper</td></tr></tbody></table><h3 id="为什么需要HBase"><a href="#为什么需要HBase" class="headerlink" title="为什么需要HBase?"></a>为什么需要HBase?</h3><p>•HBase数据库是BigTable的开源实现，和BigTable一样，支持大规模海量数据，分布式并发数据处理效率极高，易于扩展且支持动态伸缩，适用于廉价设备。</p><p>•Hadoop可以很好地解决大规模数据的<strong>离线批量处理</strong>问题，但是，受限于Hadoop MapReduce编程框架的<strong>高延迟</strong>数据处理机制，使得Hadoop无法满足大规模数据实时处理应用的需求</p><p>•HDFS面向批量访问模式，不是随机访问模式</p><p>•传统的通用关系型数据库无法应对在数据规模剧增时导致的系统<strong>扩展性和性能问题</strong>（分库分表也不能很好解决）</p><p>•传统关系数据库在数据结构变化时一般需要<strong>停机维护</strong>，空列浪费存储空间</p><p>•因此，业界出现了一类面向半结构化数据存储和处理的高可扩展、低写入&#x2F;查询延迟的系统，例如，键值数据库、文档数据库和列族数据库（如BigTable和HBase等）</p><p>•HBase已经成功应用于互联网服务领域和传统行业的众多在线式数据分析处理系统中。</p><h3 id="HBase与传统的关系数据库的区别主要体现在以下几个方面："><a href="#HBase与传统的关系数据库的区别主要体现在以下几个方面：" class="headerlink" title="HBase与传统的关系数据库的区别主要体现在以下几个方面："></a>HBase与传统的关系数据库的区别主要体现在以下几个方面：</h3><p>（1）数据类型：关系数据库采用关系模型，具有丰富的数据类型和存储方式，HBase则采用了更加简单的数据模型，它把数据存储为<strong>未经解释的字符串</strong></p><p>（2）数据操作：关系数据库中包含了丰富的操作，其中会涉及复杂的多表连接。HBase操作则<strong>不存在复杂的表与表之间的关系</strong>，只有简单的插入、查询、删除、清空等，因为HBase在设计上就避免了复杂的表和表之间的关系</p><p>（3）存储模式：关系数据库是基于行模式存储的。HBase是基于<strong>列存储的</strong>，每个列族都由几个文件保存，不同列族的文件是分离的</p><p>（4）数据索引：关系数据库通常可以针对不同列构建复杂的多个索引，以提高数据访问性能。HBase通过<strong>行键</strong>建立索引，通过巧妙的设计，HBase中的所有访问方法，或者通过行键访问，或者通过行键扫描，从而使得整个系统不会慢下来。</p><p>（5）数据维护：在关系数据库中，更新操作会用最新的当前值去替换记录中原来的旧值，旧值被覆盖后就不会存在。而在HBase中执行更新操作时，并不会删除数据旧的版本，而是生成一个新的版本，<strong>旧有的版本仍然保留</strong></p><p>（6）可伸缩性：关系数据库很难实现横向扩展，纵向扩展的空间也比较有限。相反，HBase和BigTable这些分布式数据库就是为了实现<strong>灵活的水平扩展</strong>而开发的，能够轻易地通过在集群中增加或者减少硬件数量来实现性能的伸缩。</p><h3 id="HBase访问接口"><a href="#HBase访问接口" class="headerlink" title="HBase访问接口"></a>HBase访问接口</h3><table><thead><tr><th>类型</th><th>特点</th><th>场合</th></tr></thead><tbody><tr><td><strong>Native  Java API</strong></td><td>最常规和高效的访问方式</td><td>适合Hadoop  MapReduce作业并行批处理HBase表数据</td></tr><tr><td><strong>HBase  Shell</strong></td><td>HBase的命令行工具，最简单的接口</td><td>适合HBase管理使用</td></tr><tr><td><strong>Thrift  Gateway</strong></td><td>利用Thrift序列化技术，支持C++、PHP、Python等多种语言</td><td>适合其他异构系统在线访问HBase表数据</td></tr><tr><td><strong>REST  Gateway</strong></td><td>解除了语言限制</td><td>支持REST风格的Http  API访问HBase</td></tr><tr><td><strong>Pig</strong></td><td>使用Pig  Latin流式编程语言来处理HBase中的数据</td><td>适合做数据统计</td></tr><tr><td><strong>Hive</strong></td><td>简单</td><td>当需要以类似SQL语言方式来访问HBase的时候</td></tr></tbody></table><h3 id="HBase数据模型"><a href="#HBase数据模型" class="headerlink" title="HBase数据模型"></a>HBase数据模型</h3><p>•HBase是一个稀疏、多维度、排序的映射表，这张表的索引是行键、列族、列限定符和时间戳</p><p>•每个值是一个未经解释的字符串，没有数据类型</p><p>•用户在表中存储数据，每一行都有一个可排序的行键和任意多的列</p><p>•表在水平方向由一个或者多个列族组成，一个列族中可以包含任意多个列，同一个列族里面的数据存储在一起</p><p>•列族支持动态扩展，可以很轻松地添加一个列族或列，无需预先定义列的数量以及类型，所有列均以字符串形式存储，用户需要自行进行数据类型转换</p><p>•HBase中执行更新操作时，并不会删除数据旧的版本，而是生成一个新的版本，旧有的版本仍然保留（这是和HDFS只允许追加不允许修改的特性相关的）</p><p>•<strong>表</strong>：HBase采用表来组织数据，表由行和列组成，列划分为若干个列族</p><p>•<strong>行</strong>：每个HBase表都由若干行组成，每个行由行键（row key）来标识。</p><p>•<strong>列族</strong>：一个HBase表被分组成许多“列族”（Column Family）的集合，它是基本的访问控制单元</p><p>•<strong>列限定符</strong>：列族里的数据通过列限定符（或列）来定位</p><p>•<strong>单元格</strong>：在HBase表中，通过行、列族和列限定符确定一个“单元格”（cell），单元格中存储的数据没有数据类型，总被视为字节数组byte</p><p>•<strong>时间戳</strong>：每个单元格都保存着同一份数据的多个版本，这些版本采用时间戳进行索引</p><p>•HBase中需要根据行键、列族、列限定符和时间戳来确定一个单元格，因此，可以视为一个“四维坐标”，即[行键, 列族, 列限定符, 时间戳]</p><h2 id="NoSQL-数据库"><a href="#NoSQL-数据库" class="headerlink" title="NoSQL 数据库"></a><strong>NoSQL</strong> <strong>数据库</strong></h2><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16682443091221668244308664.png" style="zoom:33%;" /><p>NoSQL，指的是非关系型的数据库，也称作Not Only SQL。</p><p>NoSQL产生的原因</p><p>① 关系数据库<strong>无法满足海量数据</strong>的管理需求；</p><p>②关系数据库<strong>无法满足高并发</strong>的需求；</p><p>③关系数据库<strong>无法满足高扩展性和高可用性</strong>需求。</p><p>纵向扩展</p><p>横向扩展：采用集群的方式，但部署、管理、配置很复杂，没有办法自动化实现。</p><h3 id="CAP定理："><a href="#CAP定理：" class="headerlink" title="CAP定理："></a>CAP定理：</h3><p>又称作布鲁尔定理（Brewer‘s theorem），对于一个分布式计算系统来说，不可能同时满足以下三点，最多只能同时较好的满足两点。</p><ul><li><p>一致性(Consistency) (所有节点在同一时间具有相同的数据)</p></li><li><p>可用性(Availability) (保证每个请求不管成功或者失败都有响应)</p></li><li><p>分区容忍(Partition tolerance) (系统一部分节点信息的丢失或失败不会影响系统的继续运行)</p></li></ul><p>根据 CAP 原理将 NoSQL 数据库分成了满足 CA 原则、满足 CP 原则和满足 AP 原则三 大类：</p><ol><li>CA - 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。</li><li>CP - 满足一致性，分区容忍性的系统，通常性能不是特别高。</li><li>AP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。</li></ol><h3 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a><strong>BASE</strong></h3><p>BASE是NoSQL数据库通常对可用性及一致性的弱要求原则，核心思想是，在保证可用性的基础上，即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。它是AP（可用性+分区容忍性）的优化方案，能满足绝大部分业务需求。</p><p>BASE：Basically Available, Soft-state, Eventually Consistency。 由 Eric Brewer 定义。 </p><p>Basically Available：分布式系统在出现故障时，允许损失部分可用性，即保证核心可用。</p><p>Soft-state 软状态：允许系统存在中间状态（数据不一致），不会影响系统整体可用性。</p><p>Eventually Consistency 最终一致性：系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。</p><h3 id="关系数据库与NoSQL比较"><a href="#关系数据库与NoSQL比较" class="headerlink" title="关系数据库与NoSQL比较"></a><strong>关系数据库与</strong>NoSQL比较</h3><p><strong>关系型数据库的优势：</strong></p><p>1.保持数据的<strong>一致性</strong>（事务处理）[关系型数据库的最大优势]</p><p>2.由于以标准化为前提，数据<strong>更新的开销很小</strong>（相同的字段基本上都只有一处）</p><p>3.可以进行Join等<strong>复杂查询</strong>(不同服务器之间不能进行Join处理)</p><p>4.存在很多实际成果和专业技术信息（<strong>成熟的技术</strong>）</p><p>5.把所有的数据都通过行和列的二元表现形式表示出来，让人<strong>容易理解</strong></p><p><strong>关系型数据库不擅长的处理</strong>：</p><ol><li><p>大量数据的写入处理</p></li><li><p>为有数据更新的表做索引或表结构（schema）变更</p></li><li><p>字段不固定时应用</p></li><li><p>对简单查询需要快速返回结果的处理</p></li></ol><p>关系库无法满足海量数据的管理需求，无法满足高并发的需求，无法满足高扩展性和高可用性需求</p><p><strong>NoSQL数据库的优势：</strong></p><p>1.关系型数据库有类似Join这样的多表查询机制的限制导致扩展很艰难，NoSQL数据库不支持Join处理，各个数据都是独立设计的，<strong>很容易把数据分散在多个服务器上</strong>。</p><p>2.NoSQL的存储格式是键值存储形式、面向文档形式、面向列形式等，所以可以存储基础类型以及对象或者是集合等<strong>各种格式</strong>，而关系数据库则只支持基础类型</p><p>3.<strong>大量数据</strong>的写入处理</p><p>4.对数据进行<strong>缓存</strong>(Cache)处理</p><p>5.对数组类型的数据进行<strong>高速</strong>处理</p><p>6.对数据进行<strong>全部保存</strong>处理</p><p><strong>NoSQL数据库的不足：</strong></p><p>1.不提供关系型数据库对事务的处理</p><p>2.属于新的技术维护的工具和资料有限、将产生一定用户的学习和使用成本</p><h2 id="键值数据库"><a href="#键值数据库" class="headerlink" title="键值数据库"></a>键值数据库</h2><p><strong>数据模型</strong></p><p>键&#x2F;值对</p><p>键是一个字符串对象</p><p>值可以是任意类型的数据，比如整型、字符型、数组、列表、集合等</p><p>通过键查询，不能通过值来查询。</p><p>优点：扩展性好，灵活性好，大量写操作时性能高</p><p>缺点：无法存储结构化信息，条件查询效率较低，不能存储数据之间的关系</p><p><strong>相关产品</strong>：Redis、Riak、SimpleDB、Chordless、Scalaris、Memcached</p><p><strong>典型应用：涉及频繁读写、拥有简单数据模型的应用；内容缓存，比如会话、配置文件、参数、购物车等；存储配置和用户数据信息的移动应用</strong></p><p>Redis被人们称为“强化版的Memcached”，开源的使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存、分布式、可选持久性，提供多种语言的 API，数据恢复、更多数据类型。</p><p>Redis内部使用一个redisObject对象来表示所有的key和value。redisObject主要的信息包括数据类型（type）、编码方式(encoding)、数据指针（ptr）、虚拟内存（vm）等。type代表一个value对象具体是何种数据类型，encoding是不同数据类型在redis内部式。</p><p>与Memcached仅支持简单的key-value结构的数据记录不同，Redis支持的数据类型要丰富得多，常用的数据类型主要有五种：<strong>String、List、Hash、Set和Sorted Set</strong>。</p><ol><li>字符串（String）是Redis值的最基础的类型。Redis中使用的字符串是通过包装的，基于c语言字符数组实现的简单动态字符串(simple dynamic string, SDS)一个抽象数据结构。下图为C语言字符串内存结构示意图</li></ol><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16682448881211668244887485.png"></p><ol start="2"><li>Hash是一个String类型的field和value之间的映射表，即redis的Hash数据类型的key（hash表名称）对应的value实际的内部存储结构为一个HashMap，因此Hash特别<strong>适合存储对象</strong>。相对于把一个对象的每个属性存储为String类型，将整个对象存储在Hash类型中会占用更少内存。适用于一个对象来存储用户信息，商品信息，订单信息等等。</li></ol><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16682449361221668244935146.png" style="zoom:67%;" /><ol start="3"><li>List类型其实就是每一个元素都是String类型的双向链表。我们可以从链表的头部和尾部添加或者删除元素。这样的List既可以作为栈，也可以作为队列使用。适用于如好友列表，粉丝列表，消息队列，最新消息排行等。</li><li>Redis 集合（Set类型）是一个无序的String类型数据的集合，类似List的一个列表，与List不同的是Set不能有重复的数据。实际上，Set的内部是用HashMap实现的，Set只用了HashMap的key列来存储对象。集合有取交集、并集、差集等操作，因此可以求共同好友、共同兴趣、分类标签等。</li><li>SortSet顾名思义，是一个排好序的Set，它在Set的基础上增加了一个顺序属性score，这个属性在添加修改元素时可以指定，每次指定后，SortSet会自动重新按新的值排序。SortSet的内部使用HashMap和跳跃表(SkipList)来保证数据的存储和有序，HashMap里放的是成员到score的映射，而跳跃表里存放的是所有的成员，排序依据是HashMap里存的score。适合需要有序且唯一的业务或操作，例：网易云音乐的排行榜功能</li></ol><table><thead><tr><th><strong>分值</strong></th><th><strong>2.0</strong></th><th><strong>3.2</strong></th><th><strong>4.0</strong></th><th><strong>7.0</strong></th><th><strong>8.2</strong></th><th><strong>9.1</strong></th></tr></thead><tbody><tr><td>元素</td><td>歌曲1</td><td>歌曲2</td><td>歌曲3</td><td>歌曲4</td><td>歌曲5</td><td>歌曲6</td></tr></tbody></table><h2 id="列族数据库"><a href="#列族数据库" class="headerlink" title="列族数据库"></a>列族数据库</h2><p><strong>典型应用</strong>：分布式数据存储与管理；可以容忍副本中存在短期不一致情况的应用程序；拥有动态字段的应用程序：拥有潜在大量数据的应用程序，大到几百TB的数据</p><p>优点：查找速度快，可扩展性强，容易进行分布式扩展，复杂性低</p><p>缺点：功能较少，大都<strong>不支持强事务一致性</strong></p><table><thead><tr><th><strong>相关产品</strong></th><th>BigTable、HBase、Cassandra、HadoopDB、GreenPlum、PNUTS</th></tr></thead><tbody><tr><td><strong>使用者</strong></td><td>Ebay（Cassandra）、Instagram（Cassandra）、NASA（Cassandra）、Twitter（Cassandra  and HBase）、Facebook（HBase）、Yahoo!（HBase）</td></tr></tbody></table><h2 id="文档数据库"><a href="#文档数据库" class="headerlink" title="文档数据库"></a>文档数据库</h2><p>文档数据库可看作特殊的键值数据库，值是文档。</p><p>“文档”其实是一个数据记录，这个记录能够对包含的数据类型和内容进行自我描述。比如XML文档、HTML文档和JSON 文档。</p><table><thead><tr><th><strong>典型应用</strong></th><th>存储、索引并管理面向文档的数据或者类似的半结构化数据  比如，用于后台具有大量读写操作的网站、使用JSON数据结构的应用、使用嵌套结构等非规范化数据的应用程序</th></tr></thead><tbody><tr><td><strong>优点</strong></td><td>性能好（高并发），灵活性高，复杂性低，数据结构灵活  提供嵌入式文档功能，将经常查询的数据存储在同一个文档中；既可以根据键来构建索引，也可以根据内容构建索引</td></tr><tr><td><strong>缺点</strong></td><td>缺乏统一的查询语法，不支持文档间事务</td></tr></tbody></table><table><thead><tr><th><strong>相关产品</strong></th><th>MongoDB、CouchDB、Terrastore、ThruDB、RavenDB、SisoDB、RaptorDB、CloudKit、Perservere、Jackrabbit</th></tr></thead><tbody><tr><td><strong>使用者</strong></td><td>百度云数据库（MongoDB）、SAP  （MongoDB）、Codecademy （MongoDB）、Foursquare  （MongoDB）、NBC  News （RavenDB）</td></tr></tbody></table><p>MongoDB 将数据存储为一个文档，数据结构由键值(key&#x3D;&gt;value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。</p><p>设计基于MongoDB的应用程序的数据模型时的关键就是选择合适的文档结构以及确定应用程序如何描述数据之间的关系。有两种方式可以用来描述这些关系： <strong>内嵌</strong>和<strong>引用</strong></p><p><strong>1.Embedded Data Models 内嵌数据模型</strong></p><p>内嵌方式指的是把相关联的数据保存在同一个文档结构之内。MongoDB的文档结构允许一个字段或者一个数组内的值为一个嵌套的文档。这种冗余的数据模型可以让应用程序在一个数据库操作内完成对相关数据的读取或修改。这样一来，应用程序就可以发送较少的请求给MongoDB数据库来完成常用的查询及更新请求。</p><p><strong>内嵌数据模型</strong>的适用情况</p><p>一般来说，下述情况建议使用内嵌数据：</p><p>数据对象之间有contains(包含)关系。 </p><p>数据对象之间有一对多的关系。 这些情况下 “多个”或者子文档会经常和父文档一起被显示和查看。请参见 一对多关系建模： 内嵌文档模型。</p><p>通常情况下，内嵌数据会对读操作有比较好的性能提高，也可以使应用程序在一个单个操作就可以完成对数据的读取。 同时，内嵌数据也对更新相关数据提供了一个原子性写操作。</p><p><strong>2.</strong> <strong>Normalized Data Models 规范化数据模型</strong></p><p>规范化数据模型指的是通过使用引用来表达对象之间的关系。</p><p>一般来说，在下述情况下可以使用规范化模型：</p><p>当内嵌数据会导致很多数据的重复，并且读性能的优势又不足于盖过数据重复的弊端时候。</p><p>需要表达比较复杂的多对多关系的时候。</p><p>大型多层次结构数据集。</p><p>引用比内嵌要更加灵活一些。 但客户端应用必须使用二次查询来解析文档内包含的引用。换句话说，对同样的操作来说，规范化模式会导致更多的网络请求发送到数据库服务器端。</p><p><strong>MongoDB特性与数据模型</strong></p><p><strong>1.</strong> <strong>原子性</strong></p><p>在MongoDB中，即使操作修改单个文档中的多个嵌入文档，写操作在单个文档的级别上也是原子操作。当单个写操作修改多个文档（例如db.collection.updateMany()）时，每个文档的修改都是原子的，但整个操作不是原子操作。</p><p>把相关数据定义到同一个文档里面的内嵌方式有利于这种原子性操作。对于那些使用引用来关联相关数据的数据模型，应用程序必须再用额外的读和写的操作去取回和修改相关的数据。</p><p><strong>内嵌数据模型</strong></p><p>嵌入式数据模型将所有相关数据组合在单个文档中，而不是跨多个文档和集合进行规范化。该数据模型有助于原子操作。</p><p><strong>多文档事务</strong></p><p>对于存储相关数据片段之间的引用的数据模型，应用程序必须发出单独的读取和写入操作以检索和修改这些相关的数据片段。从版本4.0开始，对于需要原子性来更新多个文档或读取多个文档之间的一致性的情况，MongoDB为副本集提供了多文档事务。</p><p><strong>2.</strong> <strong>分片</strong></p><p>MongoDB 使用 <strong>sharding （分片）</strong>来实现水平扩展。使用分片的集群可以支持海量的数据和高并发读写。用户可以使用分片技术把一个数据库内的某一个集合的数据进行分区，从而达到把数据分布到多个 mongod 实例（或分片上）的目的。</p><p>Mongodb 依据分片键分发数据和应用程序的事务请求。选择一个合适的分片键会对性能有很大的影响，也会促进或者阻碍MongoDB的定向分片查询和增强的写性能。所以在选择分片键时候要仔细考量分片键所用的字段。</p><p><strong>3.</strong> <strong>索引</strong></p><p>对常用操作可以使用索引来提高性能。对查询条件中常见的字段，以及需要排序的字段创建索引。MongoDB会对 _id 字段自动创建唯一索引。</p><p>创建索引时，需要考虑索引的下述特征：</p><p>每个索引<strong>至少需要8kB</strong>的数据空间。</p><p>添加索引会对写入操作产生一些<strong>负面的性能</strong>影响。 对于具有高写入读取比率的集合，索引的代价很大，因为每个插入也必须更新任何索引。</p><p>具有高读写比的集合通常受益于其他索引。 索引不会影响未设置索引的读取操作。</p><p>每个索引都会占一定的硬盘空间和内存（对于活跃的索引）。索引有可能会用到很多这样的资源，因此对这些资源要进行管理和规划，特别是在计算热点数据大小的时候</p><h2 id="图数据库"><a href="#图数据库" class="headerlink" title="图数据库"></a>图数据库</h2><table><thead><tr><th><strong>数据模型</strong></th><th>图结构</th></tr></thead><tbody><tr><td><strong>典型应用</strong></td><td>专门用于处理具有高度相互关联关系的数据，比较适合于社交网络、模式识别、依赖分析、推荐系统以及路径寻找等问题</td></tr><tr><td><strong>优点</strong></td><td>灵活性高，支持复杂的图形算法，可用于构建复杂的关系图谱</td></tr><tr><td><strong>缺点</strong></td><td>复杂性高，只能支持一定的数据规模</td></tr></tbody></table><table><thead><tr><th><strong>相关产品</strong></th><th>Neo4J、OrientDB、InfoGrid、Infinite  Graph、GraphDB</th></tr></thead><tbody><tr><td><strong>使用者</strong></td><td>Adobe（Neo4J）、Cisco（Neo4J）、T-Mobile（Neo4J）</td></tr></tbody></table><p>图由两个元素组成：节点和关系。</p><p>每个节点代表一个实体（人，地，事物，类别或其他数据），每个关系代表两个节点的关联方式。</p><p>Neo4J是由Java实现的开源图数据库，支持ACID，集群、备份和故障转移。Neo4J版本分为社区版和企业版，社区版只支持单机部署，功能受限。企业版支持主从复制和读写分离，包含可视化管理工具。</p><p><strong>Neo4J的特点</strong></p><p>它很容易表示连接的数据</p><p>检索&#x2F;遍历&#x2F;导航更多的连接数据是非常容易和快速的</p><p>它非常容易地表示半结构化数据</p><p>Neo4j CQL查询语言命令是人性化的可读格式，非常容易学习</p><p>使用简单而强大的数据模型</p><p>它不需要复杂的连接来检索连接的&#x2F;相关的数据，因为它很容易检索它的相邻节点或关系细节没有连接或索引。</p><p>Neo4J的使用实例</p><p>例如一部电影有若干演员和导演，那么建立图数据库后，可以容易地表示电影、演员、导演之间的关系，而且在查询时也会变得很方便。</p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16682460171281668246016634.png" style="zoom:33%;" /><p>例如一个购物网站。购物网站的业务需求大概具有这样的流程：首先商家上架了商品，然后顾客浏览或查找商品，顾客找到自己需要的商品之后，确定购买，接着使用他的账户支付款项，商家收到货款后，将商品快递给顾客，从而完成一笔交易。根据这个业务流程，也可以使用Neon4J建立数据模型。</p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16682460441221668246043554.png" style="zoom:67%;" /><h2 id="不同类型数据库比较分析"><a href="#不同类型数据库比较分析" class="headerlink" title="不同类型数据库比较分析"></a>不同类型数据库比较分析</h2><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16682460651211668246064749.png" style="zoom:50%;" /><p><strong>MySQL</strong>功能稳定，满足多样需求</p><p><strong>MongoDB</strong>提供更灵活的数据模型，支持较多功能。</p><p><strong>Hbase</strong> 依赖Hadoop的生态环境，有很好的扩展性。</p><p><strong>Redis</strong>是键值存储的代表，功能最简单，提供随机数据存储，伸缩性特别好</p><h1 id="第8章-大数据处理技术"><a href="#第8章-大数据处理技术" class="headerlink" title="第8章 大数据处理技术"></a>第8章 大数据处理技术</h1><h2 id="基于内存的分布式计算框架Spark"><a href="#基于内存的分布式计算框架Spark" class="headerlink" title="基于内存的分布式计算框架Spark"></a><strong>基于内存的分布式计算框架</strong>Spark</h2><p>AMP实验室于2009年开发，是<strong>基于内存计算</strong>的大数据并行计算框架，可用于构建大型的、低延迟的数据分析应用程序。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li><p>运行速度快：使用DAG执行引擎以支持循环数据流与内存计算。</p></li><li><p>容易使用：支持使用Scala、Java、Python和R语言进行编程，可以通过Spark Shell进行交互式编程 。</p></li><li><p>通用性：Spark提供了完整而强大的技术栈，包括SQL查询、流式计算、机器学习和图算法组件。</p></li><li><p>运行模式多样：可运行于独立的集群模式中，可运行于Hadoop中，也可运行于Amazon EC2等云环境中，并且可以访问HDFS、Cassandra、HBase、Hive等多种数据源</p></li></ul><h2 id="Scala简介"><a href="#Scala简介" class="headerlink" title="Scala简介"></a>Scala简介</h2><p>Scala （Scalable Language）是一门多范式编程语言，运行于Java平台（JVM，Java 虚拟机），兼容现有的Java程序</p><p><strong>Scala</strong>的特性：</p><p>具备强大的并发性，支持函数式编程，可以更好地支持分布式系统；</p><p>语法简洁，能提供API，自带了很多的算子，比如集合算子；</p><p><strong>兼容</strong>Java，运行速度快，能融合到Hadoop生态圈中 ；</p><p>Scala是Spark的主要编程语言</p><p>Scala的优势是提供了<strong>REPL</strong>（Read-Eval-Print Loop，交互式解释器），提高程序开发效率。</p><p>Scala解释器读到一个表达式，对它进行求值，将它打印出来，接着再继续读下一个表达式。这个过程被称做读取–求值–打印–循环，即：REPL。</p><p><strong>Hadoop</strong>缺点：</p><p>表达能力有限</p><p>磁盘IO开销大</p><p>延迟高</p><p>任务之间的衔接涉及IO开销</p><p>在前一个任务执行完成之前，其他任务就无法开始，难以胜任复杂、多阶段的计算任务</p><p><strong>Spark</strong>优点：</p><p>Spark的计算模式也属于MapReduce，但<strong>不局限于</strong>Map和Reduce操作，还提供了多种数据集操作类型，编程模型比Hadoop MapReduce更灵活</p><p>Spark提供了<strong>内存计算</strong>，可将中间结果放到内存中，对于迭代运算效率更高</p><p>Spark基于DAG的任务调度执行机制，要优于Hadoop MapReduce的迭代执行机制</p><p>表达能力有限。Hadoop把复杂的分布式编程高度抽象到两个函数Map和Reduce上，在降低使用难度的同时，但也带来了表达能有限的问题，实际操作的时候有些问题并不能单单靠这两个函数来解决问题。</p><p>执行迭代操作效率低。对于一些大型的机器学习，数据挖掘任务，往往需要更多轮次迭代才能得到结果。采用MapReduce实现这些算法的时候，每次迭代都是执行一次Map，Reduce任务的过程，这个过程的数据来源于分布式文件系统HDFS中，本此的迭代处理的结果也放在HDFS中，继续用于下一次的迭代。反复读写HDFS中的数据，大大降低了迭代操作的效率。</p><p>资源浪费。在MapReduce的框架设计中，Reduce任务必须等待所有的Map任务执行完毕后再开始执行，造成不必要资源的浪费。</p><p>实时性差。只是适用于离线批数据处理，无法支持交互式数据处理，实时数据的处理。</p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16681850981531668185097574.png" style="zoom:80%;" /><p>使用Hadoop进行迭代计算非常耗资源</p><p>Spark将数据载入内存后，之后的迭代计算都可以直接使用内存中的中间结果作运算，避免了从磁盘中频繁读取数据</p><h3 id="大数据处理包括三个类型："><a href="#大数据处理包括三个类型：" class="headerlink" title="大数据处理包括三个类型："></a>大数据处理包括三个类型：</h3><ul><li><p><strong>复杂的批量数据处理</strong>：通常时间跨度在数十分钟到数小时之间</p></li><li><p><strong>基于历史数据的交互式查询</strong>：通常时间跨度在数十秒到数分钟之间</p></li><li><p><strong>基于实时数据流的数据处理</strong>：通常时间跨度在数百毫秒到数秒之间</p><p>当同时存在以上三种场景时，就需要同时部署三种不同的软件。比如: MapReduce &#x2F; Impala &#x2F; Storm</p></li></ul><p><strong>问题：</strong> </p><ul><li><p>不同场景之间输入输出数据无法做到无缝共享，通常需要进行数据格式的转换</p></li><li><p>不同的软件需要不同的开发和维护团队，带来了较高的使用成本</p></li><li><p>难以对同一个集群中的各个系统进行统一的资源协调和分配</p></li></ul><p>Spark的设计遵循“<strong>一个软件栈满足不同应用场景</strong>”的理念，逐渐形成了一套完整的生态系统</p><p>既能够提供内存计算框架，也可以支持SQL即时查询、实时流式计算、机器学习和图计算等</p><p>Spark可以部署在资源管理器YARN之上，提供一站式的大数据解决方案</p><p>Spark所提供的生态系统足以应对上述三种场景，即同时支持批处理、交互式查询和流数据处理</p><h3 id="BDAS架构"><a href="#BDAS架构" class="headerlink" title="BDAS架构"></a>BDAS架构</h3><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16681854331521668185432924.png" style="zoom:80%;" /><h4 id="Spark生态系统组件的应用场景"><a href="#Spark生态系统组件的应用场景" class="headerlink" title="Spark生态系统组件的应用场景"></a>Spark生态系统组件的应用场景</h4><table><thead><tr><th><strong>应用场景</strong></th><th><strong>时间跨度</strong></th><th><strong>其他框架</strong></th><th><strong>Spark生态系统中的组件</strong></th></tr></thead><tbody><tr><td>复杂的批量数据处理</td><td>小时级</td><td>MapReduce、Hive</td><td>Spark  Core</td></tr><tr><td>基于历史数据的交互式查询</td><td>分钟级、秒级</td><td>Impala、Dremel、Drill</td><td>Spark  SQL</td></tr><tr><td>基于实时数据流的数据处理</td><td>毫秒、秒级</td><td>Storm、S4</td><td>Spark  Streaming</td></tr><tr><td>基于历史数据的数据挖掘</td><td>-</td><td>Mahout</td><td>MLlib</td></tr><tr><td>图结构数据的处理</td><td>-</td><td>Pregel、Hama</td><td>GraphX</td></tr></tbody></table><h4 id="Spark运行架构"><a href="#Spark运行架构" class="headerlink" title="Spark运行架构"></a>Spark运行架构</h4><p>①基本概念</p><p>②架构设计</p><p>③Spark运行基本流程</p><h3 id="RDD"><a href="#RDD" class="headerlink" title="RDD"></a>RDD</h3><p>（Resillient Distributed Dataset，弹性分布式数据集），是Spark中最基本的数据抽象，代表一个不可变（只读）、可分区、分布式对象集合。</p><p>只读：不能修改，只能通过转换操作生成新的 RDD。</p><p>弹性：计算过程中内存不够时它会和磁盘进行数据交换。</p><p>分区：不同分区可以保存到集群中不同的节点上，从而可以进行并行计算。</p><p>RDD支持两种操作:</p><p>转换（Transformation）：返回一个新的 RDD的操作。</p><p>行动（Action）：是向驱动器程序返回结果或把结果写入外部系统的操作。</p><h4 id="转换操作"><a href="#转换操作" class="headerlink" title="转换操作"></a>转换操作</h4><table><thead><tr><th>RDD转换</th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>map(func)</td><td>将一个RDD中的每个数据项，通过函数func映射变为一个新的元素</td></tr><tr><td>filter(func)</td><td>通过函数func选择过滤数据集中的成员</td></tr><tr><td>flatMap(func)</td><td>和map转换类似，但函数func可以把单个成员转换为多个成员。</td></tr><tr><td>union(other)</td><td>返回当前集合与otherDataset集合的union操作</td></tr><tr><td>distinct</td><td>去掉集合中重复成员，使新的集合中成员各不相同</td></tr><tr><td>groupByKey</td><td>对键-值（key-value）对集合按照键（key）进行groupBy操作</td></tr><tr><td>sortByKey</td><td>对键-值（key-value）对集合进行排序</td></tr><tr><td>join(other)</td><td>对两个键-值（key-value）对集合：（K,V），（K,W）进行连接操作，形成新的键-值对集合：（K，（V,W））</td></tr></tbody></table><h4 id="行动操作"><a href="#行动操作" class="headerlink" title="行动操作"></a>行动操作</h4><table><thead><tr><th><strong>Action</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>collect</td><td>返回RDD中的所有元素</td></tr><tr><td>count</td><td>返回RDD中元素的数量</td></tr><tr><td>countByKey</td><td>计算键-值对RDD每个键（key）对应的元素个数</td></tr><tr><td>first</td><td>返回RDD中第一个元素</td></tr><tr><td>take(n)</td><td>返回RDD中前n个元素</td></tr><tr><td>reduce(func)</td><td>通过函数func对RDD进行聚合操作</td></tr><tr><td>saveAsTextFile(path)</td><td>把RDD保存为一个文本文件，可以选择保存在本地文件系统、HDFS等。文件中的一行为RDD中的一个元素</td></tr><tr><td>foreach(func)</td><td>通过函数func对RDD中的每个元素进行计算，通常在更新累加器或者使用外部存储系统时用到</td></tr></tbody></table><h4 id="RDD典型的执行过程："><a href="#RDD典型的执行过程：" class="headerlink" title="RDD典型的执行过程："></a>RDD典型的执行过程：</h4><p>RDD读入外部数据源进行创建</p><p>RDD经过一系列的转换（Transformation）操作，每一次都会产生不同的RDD，供给下一个转换操作使用</p><p>最后一个RDD经过“动作”操作进行转换，并输出到外部数据源</p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16681857341561668185733997.png" style="zoom:80%;" /><p>RDD 的最重要的特性之一就是血缘关系（Lineage )，它描述了一个 RDD 是如何从父 RDD 计算得来的。如果某个 RDD 丢失了，则可以根据血缘关系，从父 RDD 计算得来。 图 2 给出了一个 RDD 执行过程的实例。系统从输入中逻辑上生成了 A 和 C 两个 RDD， 经过一系列转换操作，逻辑上生成了 F 这个 RDD。 Spark 记录了 RDD 之间的生成和依赖关系。当 F 进行行动操作时，Spark 才会根据 RDD 的依赖关系生成 DAG，并从起点开始真正的计算。</p><p>DAG（Directed Acyclic Graph，有向无环图）:RDD的每次转换都会生成一个新的RDD，RDD之间就会形成类似于流水线一样的前后依赖关系。DAG描述了整个流式计算的流程。</p><p>在部分分区数据丢失时，Spark可以通过DAG重新计算丢失的分区数据，而不是对RDD的所有分区进行重新计算。</p><h4 id="RDD之间的依赖关系"><a href="#RDD之间的依赖关系" class="headerlink" title="RDD之间的依赖关系"></a><strong>RDD</strong>之间的依赖关系</h4><p>窄依赖</p><p>宽依赖</p><p>窄依赖表现为一个父RDD的分区对应于一个子RDD的分区或多个父RDD的分区对应于一个子RDD的分区</p><p>宽依赖则表现为存在一个父RDD的一个分区对应一个子RDD的多个分区，宽依赖存在Shuffle操作</p><p><strong>Application</strong>：用户编写的Spark应用程序</p><p><strong>Job</strong>：一个Job包含多个RDD及作用于相应RDD上的各种操作</p><p><strong>Stage</strong>：是Job的基本调度单位，一个Job会分为多个Stage，或者称为TaskSet，代表了一组关联的、相互之间没有Shuffle依赖关系的任务组成的任务集。</p><p><strong>Task</strong>：是运行在Executor上的工作单元 ，1个Stage包含一组Task</p><p>Spark 根据DAG 图中的RDD 依赖关系，把一个作业分成多个阶段。</p><p>阶段划分的依据是窄依赖和宽依赖。窄依赖对于作业的优化很有利，宽依赖包含Shuffle过程，无法实现流水线方式处理。</p><p>阶段划分方法：</p><p>①在DAG中进行反向解析，遇到宽依赖就断开</p><p>②遇到窄依赖就把当前的RDD加入到Stage中</p><p>③将窄依赖尽量划分在同一个Stage中，可以实现流水线计算</p><p>Spark运行架构包括集群资源管理器（Cluster Manager）、运行任务的工作节点（Worker Node）、每个应用的任务控制节点（Driver）和每个工作节点上负责具体任务Task的执行进程（Executor）</p><p>资源管理器可以自带或Mesos或YARN</p><p>Executor优点：</p><p>一是利用多线程来执行具体的任务，减少任务的启动开销</p><p>二是Executor中有一个BlockManager存储模块，会将内存和磁盘共同作为存储设备，有效减少IO开销</p><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16681859551561668185954389.png"></p><p>一个Application由一个Driver和若干个Job构成，一个Job由多个Stage构成，一个Stage由多个Task组成</p><p>当执行一个Application时，Driver会向集群管理器申请资源，启动Executor，并向Executor发送应用程序代码和文件，然后在Executor上执行Task，运行结束后，执行结果会返回给Driver，或者写到HDFS或者其他数据库中</p><h3 id="Spark运行基本流程图"><a href="#Spark运行基本流程图" class="headerlink" title="Spark运行基本流程图"></a>Spark运行基本流程图</h3><p>（1）由Driver创建一个SparkContext，为应用构建起基本的运行环境，进行资源的申请、任务的分配和监控</p><p>（2）资源管理器为Executor分配资源，并启动Executor进程</p><p>（3）SparkContext根据RDD的依赖关系构建DAG图，DAG图提交给DAGScheduler解析成Stage，然后把一个个TaskSet提交给底层调度器TaskScheduler处理；Executor向SparkContext申请Task，Task Scheduler将Task发放给Executor运行，并提供应用程序代码</p><p>（4）Task在Executor上运行，执行结果反馈给TaskScheduler，然后反馈给DAGScheduler，运行完毕后写入数据并释放所有资源</p><h3 id="Spark架构优点："><a href="#Spark架构优点：" class="headerlink" title="Spark架构优点："></a>Spark架构优点：</h3><p>实现一键式安装和配置、线程级别的任务监控和告警</p><p>降低硬件集群、软件维护、任务监控和应用开发的难度</p><p>便于做成统一的硬件、计算平台资源池</p><p>说明：Spark Streaming是将流数据分解成一系列短小的批处理作业，无法实现毫秒级的流计算，因此，对于需要毫秒级实时响应的企业应用而言，仍然需要采用流计算框架（如Storm）</p><p>由于Hadoop生态系统中的一些组件所实现的功能，目前还是无法由Spark取代的，比如，Storm</p><p>现有的Hadoop组件开发的应用，完全转移到Spark上需要一定的成本</p><p>不同的计算框架统一运行在YARN中，可以带来如下好处：</p><p>计算资源按需伸缩</p><p>不用负载应用混搭，集群利用率高</p><p>共享底层存储，避免数据跨集群迁移</p><h2 id="流计算框架Storm"><a href="#流计算框架Storm" class="headerlink" title="流计算框架Storm"></a><strong>流计算框架</strong>Storm</h2><p>静态数据：支持决策分析而构建的数据仓库系统存放的大量历史数据就是静态数据。</p><p>流数据：数据以大量、快速、时变的流形式持续到达，比如：Web应用的电子商务网站用户点击流，网络监控的数据流、传感监测的PM2.5检测等。</p><p>流数据特征：</p><p>数据快速持续到达，潜在大小也许是无穷无尽的</p><p>数据来源众多，格式复杂</p><p>数据量大，但是不十分关注存储，一旦经过处理，要么被丢弃，要么被归档存储</p><p>注重数据的整体价值，不过分关注个别数据</p><p>数据顺序颠倒，或者不完整，系统无法控制将要处理的新到达的数据元素的顺序</p><p>对静态数据和流数据的处理，对应着两种截然不同的计算模式：批量计算和实时计算</p><p>批量计算：处理静态数据，如Hadoop</p><p>流数据必须采用实时计算，响应时间为秒级</p><p>大数据时代，数据格式复杂、来源众多、数据量巨大，对实时计算提出了很大的挑战。因此，针对流数据的实时计算——流计算，应运而生</p><h3 id="流计算："><a href="#流计算：" class="headerlink" title="流计算："></a><strong>流计算</strong>：</h3><p>实时获取来自不同数据源的海量数据，经过实时分析处理，获得有价值的信息</p><p>了及时处理流数据，就需要一个低延迟、可扩展、高可靠的处理引擎</p><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16681864361531668186435980.png"></p><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16681865171621668186516449.png"></p><p>①目前有三类常见的流计算框架和平台：</p><p>②商业级：IBM InfoSphere Streams和IBM StreamBase</p><p>③开源流计算框架，代表如下：</p><p>a)Twitter Storm：免费、开源的分布式实时计算系统，可简单、高效、可靠地处理大量的流数据</p><p>b)Yahoo! S4（Simple Scalable Streaming System）：开源流计算平台，是通用的、分布式的、可扩展的、分区容错的流式系统</p><p>④公司为支持自身业务开发的流计算框架：</p><p>a)Facebook Puma</p><p>b)Dstream（百度）</p><p>c)银河流数据处理平台（淘宝）</p><p>流计算的处理流程一般包含三个阶段：数据实时采集、数据实时计算、实时查询服务</p><p>目前有许多互联网公司发布的开源分布式日志采集系统均可满足每秒数百MB的数据采集和传输需求，如：</p><p>Facebook的Scribe</p><p>LinkedIn的Kafka</p><p>基于Hadoop的Chukwa和Flume</p><h3 id="流计算应用场景"><a href="#流计算应用场景" class="headerlink" title="流计算应用场景"></a><strong>流计算应用场景</strong></h3><p>实时个性化内容推荐：如百度、淘宝等大型网站中，每天都会产生大量流数据，包括用户的搜索内容、用户的浏览记录等数据。采用流计算进行实时数据分析，可以了解每个时刻的流量变化情况，可以分析用户的实时浏览轨迹，从而进行实时个性化内容推荐</p><p>实时交通：借助流计算的实时特性，可以根据交通情况制定路线，而且在行驶过程中，也可以根据交通情况的变化实时更新路线，为用户提供最佳的行驶路线</p><p>机器翻译</p><p>广告投放</p><p>自然语言处理</p><p>气候模拟预测等</p><h3 id="Storm特点："><a href="#Storm特点：" class="headerlink" title="Storm特点："></a>Storm特点：</h3><p> 整合性：Storm可方便地与队列系统和数据库系统进行整合</p><p> 简易的API：Storm的API使用简单又方便</p><p> 可扩展性：Storm的并行特性使其可以运行在分布式集群中</p><p> 容错性：Storm可自动进行故障节点的重启、任务的重新分配</p><p> 可靠的消息处理：Storm保证每个消息都能完整处理</p><p> 支持各种编程语言：Storm支持各种编程语言定义任务</p><p> 快速部署：Storm可以快速进行部署和使用</p><p> 免费、开源：Storm是一款开源框架，可以免费使用</p><h3 id="Storm主要术语"><a href="#Storm主要术语" class="headerlink" title="Storm主要术语"></a>Storm主要术语</h3><p><strong>Streams</strong>：Storm将流数据Stream描述成一个无限的Tuple (元组)序列，这些Tuple序列会以分布式的方式并行地创建和处理</p><p>每个tuple是一堆值，即Value List（值列表），每个值有一个名字，并且每个值可以是任何类型</p><p><strong>Spouts</strong>：Storm认为每个Stream都有一个源头，并把这个源头抽象为Spout（出水口）</p><p>通常Spout会从外部数据源（队列、数据库等）读取数据，然后封装成Tuple形式，发送到Stream中。</p><p>Spout是一个主动的角色，在接口内部有个nextTuple函数，Storm框架会不停的调用该函数</p><p><strong>Bolts</strong>：Storm将Streams的状态转换过程抽象为Bolt（门闩）。Bolt可以处理Tuple，也可以将处理后的Tuple作为新的Streams发送给其他Bolt</p><p>Bolt可以执行过滤、聚合、查询等操作</p><p><strong>Topology</strong>：<strong>Storm将Spouts和Bolts组成的网络抽象成Topology（拓扑结构），可以被提交到Storm集群执行。</strong>Topology为流转换图，图中节点是一个Spout或Bolt，边表示Bolt订阅了哪个Stream。当Spout或者Bolt发送元组时，它会把元组发送到每个订阅了该Stream的Bolt上进行处理</p><p>Topology的每个处理组件（Spout或Bolt）都包含处理逻辑，都是并行运行的， 而组件之间的连接则表示数据流动的方向。</p><p>Topology指定每个组件的并行度， Storm会在集群分配那么多的线程同时计算</p><p><strong>Stream Groupings</strong>：用于告知Topology如何在两个组件间（如Spout和Bolt之间，或者不同的Bolt之间）进行Tuple的传送。</p><p>每一个Spout和Bolt都可以有多个分布式任务，一个任务在什么时候、以什么方式发送Tuple就是由Stream Groupings来决定的</p><h3 id="Storm中的Stream-Groupings有如下几种方式："><a href="#Storm中的Stream-Groupings有如下几种方式：" class="headerlink" title="Storm中的Stream Groupings有如下几种方式："></a>Storm中的Stream Groupings有如下几种方式：</h3><p>(1)<strong>ShuffleGrouping</strong>：随机分组，随机分发Stream中的Tuple，保证每个Bolt的Task接收Tuple数量大致一致</p><p>(2)<strong>FieldsGrouping：按照字段分组</strong>，保证相同字段的Tuple分配到同一个Task中</p><p>(3)<strong>AllGrouping：广播发送</strong>，每一个Task都会收到所有的Tuple</p><p>(4)<strong>GlobalGrouping：全局分组</strong>，所有的Tuple都发送到同一个Task中</p><p>(5)<strong>NonGrouping：不分组</strong>，和ShuffleGrouping类似，当前Task的执行会和它的被订阅者在同一个线程中执行</p><p>(6)<strong>DirectGrouping：直接分组</strong>，直接指定由某个Task来执行Tuple的处理</p><h3 id="Storm框架设计"><a href="#Storm框架设计" class="headerlink" title="Storm框架设计"></a>Storm框架设计</h3><p>Storm运行任务的方式与Hadoop类似：Hadoop运行的是MapReduce作业，而Storm运行的是“Topology”</p><p>不同：MapReduce作业最终会完成计算并结束运行，而Topology将持续处理消息（直到人为终止）</p><p>Storm和Hadoop架构组件功能对应关系</p><table><thead><tr><th></th><th><strong>Hadoop</strong></th><th><strong>Storm</strong></th></tr></thead><tbody><tr><td>应用名称</td><td>Job</td><td>Topology</td></tr><tr><td>系统角色</td><td>JobTracker</td><td>Nimbus</td></tr><tr><td>TaskTracker</td><td>Supervisor</td><td></td></tr><tr><td>组件接口</td><td>Map&#x2F;Reduce</td><td>Spout&#x2F;Bolt</td></tr></tbody></table><p>Storm集群采用“Master—Worker”的节点方式：</p><p>Master节点运行名为<strong>Nimbus</strong>（雨云）的后台程序，负责在集群范围内分发代码、为Worker分配任务和监测故障。</p><p>Worker节点运行名为“Supervisor（监管器）的后台程序，负责监听它所在机器分配的工作，即根据Nimbus分配的任务决定启动或停止Worker进程，一个Worker节点上同时运行若干个Worker进程</p><p>Storm使用Zookeeper来作为分布式协调组件，负责Nimbus和多个Supervisor之间的所有协调工作。</p><p>借助Zookeeper，若Nimbus进程或Supervisor进程意外终止，重启时也能读取、恢复之前的状态并继续工作，使得Storm极其稳定</p><h3 id="Storm的工作流程："><a href="#Storm的工作流程：" class="headerlink" title="Storm的工作流程："></a>Storm的工作流程：</h3><p>①Storm客户端提交Topology任务到Nimbus节点；</p><p>②Nimbus节点将提交的Topology分成一个个Task 写入Zookeeper</p><p>③Supervisor会去Zookeeper集群上认领自己的Task，启动Worker进程；</p><p>④Worker进程执行具体Task</p><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16681872191671668187218804.png"></p><p>Spark Streaming可整合多种输入数据源，如Kafka、Flume、HDFS、TCP套接字。经处理后的数据可存储至文件系统、数据库，或显示在仪表盘里</p><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16681872471611668187246671.png"></p><p>Spark Streaming的基本原理是将实时输入数据流以时间片（秒级）为单位进行拆分，然后经Spark引擎以类似批处理的方式处理每个时间片数据</p><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16681872761561668187275361.png"></p><p>图 Spark Streaming执行流程</p><p>Spark Streaming最主要的抽象是DStream（Discretized Stream，离散化数据流），表示连续不断的数据流。在内部实现上，Spark Streaming的输入数据按照时间片（如1秒）分成一段一段的DStream，每一段数据转换为Spark中的RDD，并且对DStream的操作最终转变为对相应的RDD的操作。</p><h3 id="Spark-Streaming"><a href="#Spark-Streaming" class="headerlink" title="Spark Streaming"></a>Spark Streaming</h3><p>Spark Streaming和Storm最大的区别在于，Spark Streaming无法实现毫秒级的流计算，而Storm可以实现毫秒级响应</p><p>Spark Streaming构建在Spark上，采用小批量处理方式，可以同时兼容批量和实时数据处理的逻辑和算法</p><p>从编程的灵活性来讲，Storm是比较理想的选择，使用Apache Thrift，可以用任何编程语言来编写拓扑结构（Topology）</p><h2 id="Hive"><a href="#Hive" class="headerlink" title="Hive"></a>Hive</h2><p> Hive是一个构建于Hadoop之上的数据仓库工具。</p><p> 某种程度上可以看作是用户编程接口，本身不存储和处理数据。</p><p> 依赖分布式文件系统HDFS存储数据。</p><p> 依赖分布式并行计算模型MapReduce处理数据。</p><p> 定义了简单的类SQL 查询语言——HiveQL</p><p> 用户可以通过编写的HiveQL语句运行MapReduce任务</p><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16681874361521668187435625.png"></p><p>Hadoop生态系统中Hive与其他部分的关系</p><p>Hive在很多方面和关系数据库类似，但它的底层依赖的是HDFS和MapReduce。</p><p>Hive与关系数据库的对比</p><table><thead><tr><th><strong>对比项目</strong></th><th><strong>Hive</strong></th><th><strong>关系数据库</strong></th></tr></thead><tbody><tr><td>数据插入</td><td>支持批量导入</td><td>支持单条和批量导入</td></tr><tr><td>数据更新</td><td>不支持</td><td>支持</td></tr><tr><td>索引</td><td>支持</td><td>支持</td></tr><tr><td>分区</td><td>支持</td><td>支持</td></tr><tr><td>执行延迟</td><td>高</td><td>低</td></tr><tr><td>扩展性</td><td>好</td><td>有限</td></tr></tbody></table><p>（1）数据插入：因为Hive主要用来支持大规模数据集上的数据仓库应用程序的运行，常见操作是全表扫描，所以单条插入功能对Hive并不实用</p><p>（2）数据更新：更新是传统数据库中很重要的特性，Hive不支持数据更新。Hive是一个数据仓库工具，而数据仓库中存放的是静态数据，所以Hive不支持对数据进行更新。</p><p>（3）索引：Hive在hive 0.7版本后已经可以支持索引了。但Hive不像传统的关系型数据库那样有键的概念，它只提供有限的索引功能，使用户可以在某些列上创建索引来加速一些查询操作，Hive中给一个表创建的索引数据被保存在另外的表中。</p><p>•（4）分区：传统的数据库提供分区功能来改善大型表以及具有各种访问模式的表的可伸缩性，可管理性和提高数据库效率。Hive也支持分区功能，Hive表组织成分区的形式，根据分区列的值对表进行粗略的划分，使用分区可以加快数据的查询速度。</p><p>•（5）执行延迟：因为Hive构建于HDFS与MapReduce上，所以对比传统数据库来说Hive的延迟比较高，传统的SQL语句的延迟少于一秒，而HiveQL语句的延迟会达到分钟级。</p><p>•（6）扩展性：传统关系数据库很难横向扩展，纵向扩展的空间也很有限。相反Hive的开发环境是基于集群的，所以具有较好的可扩展性。</p><h3 id="Hive系统架构"><a href="#Hive系统架构" class="headerlink" title="Hive系统架构"></a>Hive系统架构</h3><p>①Hive组成模块</p><p>②Hive工作原理</p><ol><li><strong>用户接口模块</strong>：包括CLI、HWI、JDBC、ODBC、Thrift Server等</li></ol><p> CLI是Hive自带的一个命令行界面；</p><p> HWI（Hive Web Interface）是Hive的一个简单网页界面；</p><p> JDBC、ODBC以及Thrift Server可以向用户提供进行编程访问的接口。</p><ol start="2"><li><p><strong>驱动模块</strong>：包括编译器、优化器、执行器等，所有命令和查询都会进入到驱动模块，通过该模块对输入进行解析编译，对需求的计算进行优化，然后按照指定的步骤执行。</p></li><li><p><strong>元数据存储模块（Metastore）：</strong>是一个独立的关系数据库，通常是与MySQL数据库连接后创建的一个MySQL实例，也可以是Hive自带的derby数据库实例。</p><p>元数据存储模块中保存表模式和其他系统元数据，如表的名称、表的列及其属性、表的分区及其属性、表的属性、表中数据所在位置信息等。</p></li></ol><p>a)SQL语句转换成MapReduce的基本原理</p><p>b)Hive中SQL查询转换成MapReduce作业的过程</p><p>Hive常见的应用场景</p><p>(1)日志分析：大部分互联网公司使用hive进行日志分析，包括百度、淘宝等。</p><p>•  1)统计网站一个时间段内的pv、uv</p><p>•  2)多维度数据分析</p><p>(2)海量结构化数据离线分析</p><h1 id="第9章-数据分析方法"><a href="#第9章-数据分析方法" class="headerlink" title="第9章 数据分析方法"></a>第9章 数据分析方法</h1><h2 id="数据挖掘和机器学习简介"><a href="#数据挖掘和机器学习简介" class="headerlink" title="数据挖掘和机器学习简介"></a>数据挖掘和机器学习简介</h2><h3 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h3><p>研究计算机怎样模拟或实现人类的学习行为，以获取新的知识或技能，重新组织已有的知识结构使之不断改善自身的性能。它是人工智能的核心，是使计算机具有智能的根本途径，其应用遍及人工智能的各个领域。</p><h3 id="数据挖掘"><a href="#数据挖掘" class="headerlink" title="数据挖掘"></a>数据挖掘</h3><p>是指从大量的数据中通过算法搜索隐藏于其中信息的过程。</p><h3 id="机器学习算法的分类："><a href="#机器学习算法的分类：" class="headerlink" title="机器学习算法的分类："></a><strong>机器学习算法的分类：</strong></h3><ol><li><strong>有监督学习</strong>：训练数据既有特征(feature)又<strong>有标签</strong>(label)，通过训练，让机器可以自己找到特征和标签之间的联系，在面对只有特征没有标签的数据时，可以判断出标签。</li><li><strong>无监督学习</strong>：训练样本的标记信息未知，目标是通过对<strong>无标签</strong>训练样本的学习来揭示数据的内在性质及规律，为进一步的数据分析提供基础，此类学习任务中研究最多、应用最广的是”聚类” (clustering)，其他无监督算法还有：密度估计(densityestimation)、异常检测（anomaly detection) 等。</li><li><strong>半监督学习</strong>：训练集同时包含<strong>有标签</strong>样本数据和<strong>无标签</strong>样本数据，不需要人工干预，让学习器不依赖外界交互、自动地利用未标记样本来提升学习性能，就是半监督学习。</li></ol><h2 id="典型的机器学习和数据挖掘算法"><a href="#典型的机器学习和数据挖掘算法" class="headerlink" title="典型的机器学习和数据挖掘算法"></a>典型的机器学习和数据挖掘算法</h2><p>分类，聚类，回归分析，关联规则，神经网络，深度学习</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>基于已有的样本预测新样本的所属类别。</p><p>分类的主要用途和场景是“预测”。</p><p>例如</p><ul><li><p>将给定的电子邮件分配给“垃圾邮件”或“非垃圾邮件”类；</p></li><li><p>根据观察到的患者特征（性别，血压，某些症状的存在或不存在等）为给定患者分配诊断。</p></li><li><p>信用评级、风险等级、欺诈预测等</p></li></ul><p><strong>分类算法的训练和评价</strong></p><ul><li><em>留出法（Holdout）</em>: 将数据集D划分为两个互斥的集合，其中一个集合作为训练集S， 另一个作为测试集T。在S上训练出模型后， 用T来评估其测试误差，作为对泛化误差的估计。</li><li>交叉验证（k-fold Cross-validation): 将数据集分割成k个子样本。在每次运行时，使用一个不同的子样本作为测试集，其余的K-1子样本作为训练集。 用k次运行的平均来估计这个方法的性能。这种方法减少了训练集&#x2F;测试集的随机性，有益于大数据集。</li></ul><p>常用的分类算法包括朴素贝叶斯、逻辑回归、决策树、随机森林、支持向量机等。</p><p><strong>决策树</strong></p><p>决策树是一种树形结构，其中每个内部节点表示一个属性上的判断，每个分支代表一个判断结果的输出，最后每个叶节点代表一种分类结果。</p><p>决策树是一种监督学习方法，就是给出一堆样本，每个样本都有一组属性和一个分类结果，也就是分类结果已知，那么通过学习这些样本得到一个决策树，这个决策树能够对新的数据给出正确的分类。</p><p>最经典的决策树算法有ID3、C4.5、CART，其中ID3算法是最早被提出的，可以处理离散属性样本的分类，C4.5和CART算法则可以处理更加复杂的分类问题。</p><p><img src="https://files.catbox.moe/kiqygk.png"></p><h4 id="决策树-ID3"><a href="#决策树-ID3" class="headerlink" title="决策树-ID3"></a><strong>决策树-ID3</strong></h4><p>Iterative Dichotomiser 3，迭代二叉树3代，是Ross Quinlan发明的一种决策树算法。</p><p>决策树学习的关键在于如何选择最优的划分属性，即对于二元分类而言，尽量使划分的样本属于同一类别，即“纯度”最高的属性。</p><p>“信息熵（information entropy）：度量特征（features）的纯度。</p><p>1948年，香农 (Shannon)在他著名的《通信的数学原理》论文中指出：“信息是用来消除随机不确定性的东西”，并提出了“信息熵”的概念（借用了热力学中熵的概念），来解决信息的度量问题。</p><p>变量的不确定性越大，熵也就越大，把它搞清楚所需要的信息量也就越大。</p><p><img src="https://files.catbox.moe/inkwtc.png"></p><p>信息增益（information gain）使用属性a对样本集D进行划分所获得的“信息增益”的计算方法是，用样本集的总信息熵减去属性a的每个分支的信息熵与权重（该分支的样本数除以总样本数）的乘积。</p><p>信息增益越大，意味着用属性a进行划分所获得的“纯度提升”越大。因此，优先选择信息增益最大的属性来划分。</p><p><img src="https://files.catbox.moe/2h8ywx.png"></p><p><img src="https://files.catbox.moe/hhi12q.png"></p><p>决策树算法在学习的过程中为了尽可能的正确的分类训练样本，不停地对结点进行划分，会导致整棵树的分支过多，也就导致了过拟合。</p><p>剪枝（pruning）的目的是为了避免决策树模型的过拟合。</p><p>决策树的剪枝策略：</p><ul><li><p><strong>预剪枝（<em>pre-pruning</em>）</strong>：在构造决策树的过程中，先对每个结点在划分前进行估计，如果当前结点的划分不能带来决策树模型<strong>泛化性能</strong>的提升，则不对当前结点进行划分并且将当前结点标记为叶结点。</p></li><li><p><strong>后剪枝（<em>post-pruning</em>）</strong>：先把整颗决策树构造完毕，然后自底向上的对非叶结点进行考察，若将该结点对应的子树换为叶结点能够带来<strong>泛化性能</strong>的提升，则把该子树替换为叶结点。</p></li></ul><p>泛化能力（generalization ability）是指机器学习算法对新鲜样本的适应能力。学习的目的是学到隐含在数据背后的规律，对具有同一规律的学习集以外的数据，经过训练的网络也能给出合适的输出，该能力称为泛化能力。</p><p><strong>ID3</strong>算法的缺点</p><p>缺点：信息增益偏向取值较多的属性</p><p>原因：当某个属性的取值较多时，根据此特征划分更容易得到确定性更强的子集划分结果，因此划分之后的熵更低，则信息增益更大，因此信息增益比较偏向取值较多的属性。</p><p>解决方法 :信息增益比（ C4.5算法 ）</p><h3 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h3><p><strong>聚类</strong>把全体数据实例组织成一些相似组，而这些相似组被称作簇。</p><p>聚类技术通常又被称为无监督学习，与监督学习不同的是，在簇中那些表示数据类别的分类或者分组信息是没有的。</p><p>数据之间的相似性是通过定义一个距离或者相似性系数来判别的。</p><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h4><ul><li><strong>商业</strong>，聚类分析发现不同的客户群，通过对不同的客户群的特征的刻画，被用于研究消费者行为，寻找新的潜在市场。</li><li><strong>在生物</strong>，聚类分析对动植物和基因进行分类，以获取对种群固有结构的认识。</li><li><strong>在保险行业</strong>，聚类分析通过平均消费来鉴定汽车保险单持有者的分组，同时可以根据住宅类型、价值、地理位置来鉴定城市的房产分组。</li><li><strong>在互联网应用</strong>，聚类分析被用来在网上进行文档归类。</li><li><strong>在电子商务</strong>，聚类分析通过分组聚类出具有相似浏览行为的客户，并分析客户的共同特征，帮助企业了解客户，向客户提供更合适的服务。</li><li><strong>网络社区发现</strong>，社会关系网络中，能够显示根据兴趣、职业、地域、背景而形成的真实的社会团体。从而可以进行人物分析、职业推荐、圈子推荐、好友推荐、校友发现以及精准广告投放。</li></ul><h4 id="什么是好的聚类方法"><a href="#什么是好的聚类方法" class="headerlink" title="什么是好的聚类方法?"></a>什么是好的聚类方法?</h4><ul><li><p>好的聚类方法需要产生高质量的聚类结果，这些簇必须满足：</p></li><li><p>高的内部相似度（簇内越紧密越好）</p></li><li><p>低的外部相似度 （簇间越分离越好）</p></li></ul><p><strong>聚类质量度量指标</strong></p><ol><li><p><strong>Compactness(紧密性)</strong></p><p><strong>以簇内误差的平方和（Sum of the Squared Error ,SSE）</strong></p><p><strong>作为度量标准(计算每一个类各点到聚类中心的距离)：</strong></p></li><li><p><strong>Separation(间隔性)</strong></p><p><strong>如：计算各聚类中心两两之间平均距离。</strong></p></li></ol><h4 id="聚类算法类型"><a href="#聚类算法类型" class="headerlink" title="聚类算法类型"></a><strong>聚类算法类型</strong></h4><ol><li><strong>划分法 (partitioning methods)</strong></li><li><strong>层次法(hierarchical methods)</strong></li><li><strong>基于密度的方法(density-based methods)</strong></li><li><strong>基于网格的方法(grid-based methods)</strong></li></ol><h4 id="划分聚类方法"><a href="#划分聚类方法" class="headerlink" title="划分聚类方法"></a><strong>划分聚类方法</strong></h4><p> 给定一个有<em>n</em>个对象的数据集，划分聚类技术将构造数据<em>k</em>个划分， 每一个划分就代表一个簇，<em>k</em>&lt;<em>n</em>。</p><p> 条件：每一个簇至少包含一个对象；每一个对象属于且仅属于一个簇。</p><p> 代表算法： K-means(k-均值聚类)、 K-medoids等算法。</p><p>K-means步骤：</p><p>1、首先确定一个k值，即希望将数据集经过聚类得到k个集合。</p><p>2、从数据集中随机选择k个数据点作为质心（每个簇的均值向量，即向量各维取平均即可）。</p><p>3、对数据集中每一个点，计算其与每一个质心的距离（如欧式距离），离哪个质心近，就划分到那个质心所属的集合。</p><p>4、把所有数据归好集合后，一共有k个集合。然后重新计算每个集合的质心。</p><p>5、如果新计算出来的质心和原来的质心之间的距离小于某一个设置的阈值（表示重新计算的质心的位置变化不大，趋于稳定，或者说收敛），算法终止。</p><p>6、如果新质心和原质心距离变化很大，需要迭代3~5步骤</p><p><strong>K-Means方法的优劣</strong></p><p>优点:</p><p>容易理解，聚类效果不错。</p><p>算法复杂度低。时间复杂度为O(tkn), 其中n对样本数, k是类簇数, t是 迭代次数。通常情况下 k, t &lt;&lt; n.</p><p>不足：</p><p>必须事先给定簇的数量k；</p><p>对初始的簇中心敏感，不同选取方式会得到不同结果；</p><p>不能处理噪声和离群点；</p><p>不适合于发现非凸形状的簇</p><h4 id="层次聚类方法"><a href="#层次聚类方法" class="headerlink" title="层次聚类方法"></a>层次聚类方法</h4><p>凝聚的层次聚类：一种自底向上的策略，首先将每个对象作为一个簇， 然后合并这些原子簇为越来越大的簇，直到某个终结条件被满足。</p><p>分裂的层次聚类：采用自顶向下的策略，首先将所有对象置于一个簇中，然后逐渐细分为越来越小的簇，直到达到了某个终结条件。</p><p>代表的算法：BRICH、CURE、ROCK等算法。</p><p>BIRCH 算法：利用了一个树结构来帮助快速的聚类，这个特殊的树结构叫聚类特征树（CF-tree）。</p><p>BIRCH算法：适合于数据量大，类别数K也比较多的情况。运行速度很快，只需要单遍扫描数据集就能进行聚类</p><h4 id="密度聚类方法"><a href="#密度聚类方法" class="headerlink" title="密度聚类方法"></a>密度聚类方法</h4><p>只要一个区域中的点的密度大于某个阈值，就把它加到与之相近的聚类中去。这类算法能克服基于距离的算法只能发现“类圆形”的聚类的缺点，可发现任意形状的聚类，且对噪声数据不敏感。**</p><p><strong>代表算法：</strong></p><p><strong>DBSCAN、OPTICS、DENCLUE</strong></p><h5 id="DBSCAN"><a href="#DBSCAN" class="headerlink" title="DBSCAN"></a>DBSCAN</h5><h6 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h6><p>DBSCAN将簇定义为密度相连的点的最大集合，能够把具有足够高密度的区域划分为簇，并可在噪声的空间数据库中发现任意形状的聚类。</p><p>①初始状态，给出一个数据集D，并设置半径ε和密度阈值MinPts，将D中的所有对象标记为”unvisited”（未被访问）</p><p>②随机从D中选取一个未被访问的对象p，并标记为“visited”（已被访问）；</p><p>③检查p的ε-邻域内是否至少包含MinPts个对象（即p是否是核心对象），若不是，则将p标记为噪声点；</p><p>④否则，为p创建一个新的簇C，把p的ε-邻域中所有对象放入候选集合N中，并迭代的将N中不属于其它簇的对象加入到新簇C中，将N中的”unvisited”的对象q标记为”visited”，若q的ε-邻域是否至少包含MinPts个对象，则将q的ε-邻域中所有的对象加入到C中，直到C不再扩大，N为空的时候，此时簇C完成聚类，并输出。</p><p>⑤继续从D中随机选取未被访问的对象s，同样使用（2）中的聚类方法，直到对象集D中所有对象都被访问。</p><h6 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h6><p>能够发现任意形状的簇，并有效识别离群点；</p><p>不需要事先知道要形成的簇类的数量；</p><p>对数据库中样本的顺序不敏感，即Pattern的输入顺序对结果的影响不大，但对于处于簇类之间边界样本，可能会根据哪个簇类优先被探测到而其归属有所摆动；</p><h6 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h6><p>聚类之前需要人工选择Eps和minPts这两个参数；</p><p>当数据量增大时，要求较大的内存支持；</p><p>不能很好地反映高维数据和数据集已变化的密度；</p><p>由于算法使用了全局性表征密度的参数，因此当各个类的密度不均匀，或类间的距离相差很大时，聚类的质量较差。</p><h4 id="网格聚类方法"><a href="#网格聚类方法" class="headerlink" title="网格聚类方法"></a>网格聚类方法</h4><p>基于网格的聚类算法出发点不再是平面而是空间。</p><p><strong>在该空间中，有限个网格代表数据，聚类就是按一定的规则将网格合并。</strong></p><p><strong>基于网格的聚类算法由于处理数据时是独立的，仅仅依赖网格结构中每一维的单位数，因此处理速度很快。</strong></p><p><strong>但是此算法对参数十分敏感，速度快的代价是精确度不高，通常需要与其他聚类算法结合使用。</strong></p><p><strong>代表算法： CLIQUE、STING等算法。</strong></p><h3 id="回归分析"><a href="#回归分析" class="headerlink" title="回归分析"></a>回归分析</h3><p>是确定两种或两种以上变量间相互依赖的定量关系的一种统计分析方法。通常用于预测分析，时间序列模型以及发现变量之间的因果关系</p><p> 回归分析分类</p><p> 按照涉及的变量的多少</p><p> 分为一元回归和多元回归分析；多元回归有一个以上的自变量，而一元回归只有一个自变量。</p><p> 按照因变量的多少</p><p> 分为简单回归分析和多重回归分析</p><p> 按照自变量和因变量之间的关系类型</p><p>分为线性回归分析和非线性回归分析。</p><h4 id="一元线性回归"><a href="#一元线性回归" class="headerlink" title="一元线性回归"></a><strong>一元线性回归</strong></h4><p>线性回归使用最佳的拟合直线（也就是回归线） 建立因变量(Y) 和一个或多个自变量(X)之间的联系。 用一个等式来表示它。</p><p>最小二乘法用于拟合回归线最常用的方法。</p><h4 id="Logistic-Regression逻辑回归"><a href="#Logistic-Regression逻辑回归" class="headerlink" title="Logistic Regression逻辑回归"></a>Logistic Regression逻辑回归</h4><p>Logistic回归主要在流行病学中应用较多，比较常用的情形是探索某疾病的危险因素，根据危险因素预测某疾病发生的概率，等等。例如，想探讨胃癌发生的危险因素，可以选择两组人群，一组是胃癌组，一组是非胃癌组，两组人群肯定有不同的体征和生活方式等。这里的因变量就是是否胃癌，即“是”或“否”，自变量就可以包括很多了，例如年龄、性别、饮食习惯、幽门螺杆菌感染等。自变量既可以是连续的，也可以是分类的。</p><p>逻辑回归用来计算“事件&#x3D;Success”和“事件&#x3D;Failure”的概率。</p><p>常用于二分类问题。</p><p>简单、可并行化、可解释强，深受工业界喜爱。</p><p>逻辑回归是基于<strong>sigmoid</strong>函数构建的模型。sigmod函数公式如下：</p><p>$h(x)&#x3D;\frac{1}{1+e^{-x}}$</p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16681744821621668174481949.png" style="zoom:50%;" /><p>中间范围内函数斜率最大，对应Y的大部分数值变化</p><p>Y轴数值范围在 0~1 之间</p><p>X轴数值范围没有限制，当X大于一定数值后，Y无限趋近于1，小于一定数值后，Y无限趋近于0</p><p>当 X&#x3D;0 时，Y&#x3D;0.5</p><p>逻辑回归模型通过在线性回归模型的基础上，套一个sigmoid函数来实现，不管X取什么样的值，Y值都被非线性地映射在 0~1 之间，实现二分类。</p><p>公式中，<strong>y</strong>理解为样本x为正例的概率，而<strong>1-y</strong>则可以理解为样本x为负例时的概率。二者的比值**y&#x2F;(1-y)**被称为odds，即几率，反映x作为正例的相对可能性，对几率取对数就得到了线性回归模型。</p><h5 id="逻辑回归优点"><a href="#逻辑回归优点" class="headerlink" title="逻辑回归优点"></a>逻辑回归优点</h5><ol><li><p>直接对分类可能性进行建模，无需实现假设数据分布，避免了假设分布不准确所带来的问题。</p></li><li><p>形式简单，模型的可解释性非常好，特征的权重可以看到不同的特征对最后结果的影响。</p></li><li><p>除了类别，还能得到近似概率预测，对许多需利用概率辅助决策的任务很有用。</p></li></ol><h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><ol><li><p>准确率不是很高，因为形式非常的简单，很难去拟合数据的真实分布。</p></li><li><p>本身无法筛选特征。</p></li></ol><h3 id="关联规则Association-Rules："><a href="#关联规则Association-Rules：" class="headerlink" title="关联规则Association Rules："></a>关联规则Association Rules：</h3><p>反映一个事物与其他事物之间的相互依存性和关联性，用于从大量数据中挖掘出有价值的数据项之间的相关关系。</p><p><strong>经典案例“啤酒和纸尿裤搭配售卖</strong></p><p>•关联规则应用场景有：</p><p>•优化货架商品摆放</p><p>•交叉销售和捆绑销售 等</p><p>•常用算法：Apriori 算法 FP-growth算法等</p><p>关联规则:给定一组事务，寻找预测“某些项将会随其他项的出现而出现”的规则。</p><p>{面包，啤酒}→{牛奶}</p><p>蕴含符号“→”表现共现关系，而不是因果关系</p><p><strong>规则评估标准</strong>——支持度、置信度</p><p>支持度（support）：关联数据在数据集中出现的次数或所占的比重。<br>$$<br>support(X\to{Y})&#x3D;P(X\cup{Y})&#x3D;\frac{|{X\cup{Y}}|}{|D|}<br>$$<br>置信度（confidence）：置信度表示Y数据出现后，X数据出现的可能性，也可以说是数据的条件概率。<br>$$<br>confidence(X\Leftarrow{Y})&#x3D;P(X|Y)&#x3D;\frac{P(XY)}{P(Y)}<br>$$<br><strong>强关联规则</strong>：满足最小支持度和最小置信度的关联规则。</p><p><img src="https://files.catbox.moe/jjciej.png"></p><img src="https://files.catbox.moe/0qbfp6.png" style="zoom:50%;" /><p>候选项集:用来获取频繁项集。</p><p>频繁项集:在所有训练元组中同时出现的次数超过人工定义的阈值的项集（支持度&gt;&#x3D;最小支持度的集合），即候选项集中满足支持度条件的项集保留，不满足条件的舍弃。</p><p>频繁项集——基本原则</p><p>1.任意一个频繁项集，它所有的非空子集都必须是频繁的。</p><p>2.如果一个项集是不频繁的，那他的超集一定是不频繁的。</p><p> 在Apriori算法中，通常使用支持度作为判断频繁项集的标准。</p><p> Apriori算法的目标是找到<strong>最大的</strong>K项频繁集。</p><p><strong>频繁项集产生：</strong>目标是发现满足最小支持度阈值的所有项集，这些项集称作频繁项集（frequent itemset)</p><p> <strong>Apriori</strong>的算法步骤</p><p> 输入：数据集合D，支持度阈值α</p><p> 输出：最大的频繁k项集</p><p> 1）扫描整个数据集，得到所有出现过的数据，作为候选频繁1项集。k&#x3D;1，频繁0项集为空集。</p><p> 2）挖掘频繁k项集</p><p> 　　a) 扫描数据计算候选频繁k项集的支持度</p><p> 　　b) 去除候选频繁k项集中支持度低于阈值的数据集,得到频繁k项集。如果得到的频繁k项集为空，则直接返回频繁k-1项集的集合作为算法结果，算法结束。如果得到的频繁k项集只有一项，则直接返回频繁k项集的集合作为算法结果，算法结束。</p><p> 　　c) 基于频繁k项集，连接生成候选频繁k+1项集。</p><p> 3） 令k&#x3D;k+1，转入步骤2。</p><p> FP-growth算法(FP, Frequent Pattern)</p><p> FP-growth算法只需要对数据库进行两次扫描。而Apriori算法对于每个潜在的频繁项集都会扫描数据集判定给定的模式是否频繁，因此FP-growth算法要比Apriori算法快。</p><p> FP-growth算法第一遍对所有数据元素出现次数进行计数，第二遍只需考虑那些频繁的元素。</p><p> 发现频繁项集的基本过程分为两步，</p><p> 构建FP树</p><p> 从FP树中挖掘频繁项集。</p><p>FP-growth的一般流程如下： </p><p>•1：先扫描一遍数据集，得到频繁项为1的项目集，定义最小支持度（项目出现最少次数），删除那些小于最小支持度的项目，然后将原始数据集中的条目按项目集中降序进行排列。 </p><p>•2：第二次扫描，创建项头表（从上往下降序），以及FP树。 </p><p>•3：对于每个项目（可以按照从下往上的顺序）找到其条件模式基（CPB，conditional patten base）,递归调用树结构，删除小于最小支持度的项。如果最终呈现单一路径的树结构，则直接列举所有组合；非单一路径的则继续调用树结构，直到形成单一路径即可</p><h3 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h3><p> 神经网络是一种模拟人脑的神经网络以期能够实现类人工智能的机器学习技术。</p><p> 人脑中的神经网络是一个非常复杂的组织。成人的大脑中估计有1000亿个神经元之多。</p><p> 神经元是神经系统最基本的结构和功能单位。</p><p> 神经元模型MP结构 </p><p> 神经元模型是一个包含输入，输出与计算功能的模型。</p><p> 输入类比为神经元的树突，输出类比为神经元的轴突，计算则可以类比为细胞核。</p><p> 一个典型的神经元模型：包含有3个输入，1个输出，以及2个计算功能。中间的箭头线称为“连接”。每个上有一个“权值”。</p><p><img src="https://files.catbox.moe/nk4a3k.png"></p><p> 一个神经网络的训练算法就是让权重的值调整到最佳，以使得整个网络的预测效果最好。</p><p> a来表示输入，w来表示权值。每个有向箭头表示值的加权传递。</p><p> 在初端，传递的信号大小仍然是a，端中间有加权参数w，经过加权后的信号会变成a<em>w，因此在连接的末端，信号的大小就变成了a</em>w。</p><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16681819241531668181923410.png"></p><p> 如果将神经元图中的所有变量用符号表示，计算公式如图，z是在输入和权值的线性加权和叠加了一个函数g的值。MP模型中，函数g是sgn函数（阶跃函数），当x＞0时f(x)&#x3D;1，当x＜0时f(x)&#x3D;-1。</p><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16681820281531668182027243.png"></p><h4 id="神经元模型理解："><a href="#神经元模型理解：" class="headerlink" title="神经元模型理解："></a>神经元模型理解：</h4><p> 有一个数据，称之为样本。样本有四个属性，其中三个属性已知（特征），一个属性（目标）未知。需要通过三个已知属性预测未知属性。</p><p> 假设特征与目标之间确实是线性关系，并且已经得到表示这个关系的权值w1，w2，w3。那么，可以通过神经元模型预测新样本的目标。</p><p> 1943年发布的MP模型，简单，但是权重的值都是预先设置的，因此不能学习。</p><p> 把神经元的输入向前传递获得输出的过程称为前馈（feedforward）。</p><p> 单层神经网络（感知器）</p><p> 1958年，计算科学家Rosenblatt提出了由两层神经元组成的神经网络。起名为“感知器” （Perceptron）</p><h4 id="感知器模型结构"><a href="#感知器模型结构" class="headerlink" title="感知器模型结构"></a>感知器模型结构</h4><p> 在原来MP模型的“输入”位置添加神经元节点，标志其为“输入单元”。其余不变。</p><p> 有两个层次，输入层里的“输入单元”只负责传输数据，不做计算。</p><p> 输出层里的“输出单元” 需要对前面一层的输入进行计算，叫计算层。</p><p> 拥有一个计算层的网络称之为“单层神经网络”。</p><p> 感知器中的权值是通过训练得到的。感知器类似一个逻辑回归模型，可以做线性分类任务。</p><p> 可以用决策分界形象表达分类的效果。决策分界就是在二维的数据平面中划出一条直线，当数据的维度是3维的时候，就是划出一个平面，当数据的维度是n维时，就是划出一个n-1维的超平面。</p><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16681821621521668182161932.png"></p><h4 id="BP神经网络"><a href="#BP神经网络" class="headerlink" title="BP神经网络"></a>BP神经网络</h4><p>•1986年，Rumelhar和Hinton等人提出了反向传播（Backpropagation，BP）算法，解决了两层神经网络所需要的复杂计算量问题，带动了业界使用两层神经网络研究的热潮。</p><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16681822561531668182255907.png"></p><p>•假设预测目标是一个向量，只需要在“输出层”再增加节点</p><p>•使用向量和矩阵来表示层次中的变量。a(1)，a(2)，z是网络中传输的向量数据。W(1)和W(2)是网络的矩阵参数。</p><p>•偏置节点（bias unit）本质上是一个只含有存储功能，且存储值永远为1的单元。偏置单元与后一层的所有节点都有连接，设这些参数值为向量b。偏置的存在是为了更好的拟合数据。</p><p> 在两层神经网络中，使用平滑函数sigmoid作为函数g（称作激活函数active function）</p><p> 面对复杂的非线性分类任务，两层（带一个隐藏层）神经网络可以很好分类。</p><p> 输入层的节点数与特征的维度匹配，输出层的节点数与目标的维度匹配。</p><p> 隐藏层的节点数由设计者指定，节点数设置的多少，影响到整个模型的效果。</p><p> 如何决定隐藏层的节点数？目前业界没有完善的理论来指导，一般是根据经验设置。较好的方法是预先设定几个可选值，通过切换这几个值来看整个模型的预测效果，选择效果最好的值作为最终选择。这种方法又叫做Grid Search（网格搜索）。</p><p> 机器学习模型训练的目的，是使得参数尽可能的与真实的模型逼近。</p><p> 具体做法：先给所有参数赋上随机值来预测训练数据中的样本。样本的预测目标为yp，真实目标为y。定义一个值损失loss，目标就是使对所有训练数据的损失和尽可能的小。均方误差（MSE）</p><p> loss &#x3D; (yp - y)2</p><p> 如果将神经网络预测的矩阵公式带入到yp中，可以把损失写为关于参数的函数，称为<strong>损失函数</strong>（loss function）。</p><p> 问题：如何优化参数（改变网络的权重和偏置），能够让损失函数的值最小。优化问题</p><p>梯度下降算法（SGD）：每次计算参数在当前的梯度（求导），然后让参数向着梯度的反方向前进一段距离，不断重复，直到梯度接近零时截止。一般这个时候，所有的参数恰好达到使损失函数达到一个最低值的状态。</p><p> SGD定义了改变权重和偏置的方法：<br>$$<br>\omega _1\leftarrow\omega _1-\eta\frac{\partial{L}}{\partial{\omega_1}}<br>$$<br>η是一个常数，称为学习率（learning rate），决定了训练网络速率的快慢。当∂L&#x2F;∂w1是正数时，w1会变小；当∂L&#x2F;∂w1是负数 时，w1会变大。用这种方法去逐步改变网络的权重w和偏置b，损失函数会缓慢地降低</p><p> 在神经网络模型中，由于结构复杂，每次计算梯度的代价很大。</p><p> 需要使用反向传播算法（back propagation），简称BP算法，适合于多层神经元网络的一种学习算法，建立在梯度下降法的基础上。</p><p> BP网络的输入输出关系实质上是一种映射关系：一个n输入m输出的BP神经网络所完成的功能是从n维欧氏空间向m维欧氏空间中一有限域的连续映射，这一映射具有高度非线性。</p><p> 反向传播算法主要由两个环节(激励传播、权重更新)反复循环迭代，直到网络的对输入的响应达到预定的目标范围为止。</p><p> 两层神经网络应用于语音识别，图像识别，自动驾驶等多个领域。</p><h4 id="仍然存在若干的问题："><a href="#仍然存在若干的问题：" class="headerlink" title="仍然存在若干的问题："></a>仍然存在若干的问题：</h4><p> 训练耗时久，可能会出现局部最优解问题，使得神经网络的优化较为困难。</p><p>隐藏层的节点数需要调参，使用不太方便。</p><h4 id="多层神经网络（深度学习）"><a href="#多层神经网络（深度学习）" class="headerlink" title="多层神经网络（深度学习）"></a>多层神经网络（深度学习）</h4><p> 首先有一个“预训练”（pre-training）的过程，可以方便的让神经网络中的权值找到一个接近最优解的值，之后再使用“微调”(fine-tuning)技术来对整个网络进行优化训练。</p><p> 这两个技术的运用大幅度减少了训练多层神经网络的时间。他给多层神经网络相关的学习方法赋予了一个新名词–“深度学习”。</p><p> 预训练是提前已经给你一些初始化的参数，这个参数不是随机的，而是通过其他类似数据集上面学得的</p><h5 id="多层神经网络中的层数增加很多有什么好处？"><a href="#多层神经网络中的层数增加很多有什么好处？" class="headerlink" title="多层神经网络中的层数增加很多有什么好处？"></a>多层神经网络中的层数增加很多有什么好处？</h5><p> 具有更深入的表示特征，随着网络的层数增加，每一层对于前一层次的抽象表示更深入。</p><p> 在神经网络中，每一层神经元学习到的是前一层神经元值的更抽象的表示。例如第一个隐藏层学习到的是“边缘”的特征，第二个隐藏层学习到的是由“边缘”组成的“形状”的特征，第三个隐藏层学习到的是由“形状”组成的“图案”的特征，最后的隐藏层学习到的是由“图案”组成的“目标”的特征。通过抽取更抽象的特征来对事物进行区分，从而获得更好的区分与分类能力。</p><p> 更强的函数模拟能力：由于随着层数的增加，整个网络的参数就越多。神经网络本质就是模拟特征与目标之间的真实关系函数的方法，更多的参数意味着其模拟的函数可以更加的复杂，可以有更多的容量（capcity）去拟合真正的关系。</p><p> 通过研究发现，在参数数量一样的情况下，更深的网络往往具有比浅层的网络更好的识别效率。</p><p> 这点在ImageNet的多次大赛中得到了证实。从2012年起，每年获得ImageNet冠军的深度神经网络的层数逐年增加，2015年最好的方法GoogleNet是一个多达22层的神经网络。</p><h5 id="多层神经网络训练："><a href="#多层神经网络训练：" class="headerlink" title="多层神经网络训练："></a>多层神经网络训练：</h5><p>ReLU函数在训练多层神经网络时，更容易收敛，并且预测性能更好。</p><p> ReLU函数不是传统的非线性函数，而是分段线性函数。表达式非常简单，就是y&#x3D;max(x,0)。在x大于0，输出就是输入，在x小于0时，输出保持为0。这种函数的设计启发来自于生物神经元对于激励的线性响应，当低于某个阈值后就不再响应的模拟。</p><p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16681829671561668182966279.png"></p><h5 id="训练的主题仍然是优化和泛化。"><a href="#训练的主题仍然是优化和泛化。" class="headerlink" title="训练的主题仍然是优化和泛化。"></a>训练的主题仍然是优化和泛化。</h5><p> 当使用足够强的计算芯片（例如GPU图形加速卡）时，梯度下降算法以及反向传播算法在多层神经网络中的训练仍然工作的很好。</p><p> 目前学术界主要的研究既在于开发新的算法，也在于对这两个算法进行不断的优化，例如，增加了一种带动量因子（momentum）的梯度下降算法。　</p><p> 在深度学习中，泛化技术变的比以往更加的重要。是因为神经网络的层数增加了，参数也增加了，表示能力大幅度增强，很容易出现过拟合现象。</p><p>前馈神经网络（FF），工作原理通常遵循以下规则：</p><p>1.所有节点都完全连接</p><p>2.激活从输入层流向输出，无回环</p><p>3.输入和输出之间有一层（隐含层）</p><h4 id="RNN递归神经网络"><a href="#RNN递归神经网络" class="headerlink" title="RNN递归神经网络"></a><strong>RNN</strong>递归神经网络</h4><p>引入不同类型的神经元——递归神经元，在网络中每个隐含神经元会收到它自己的在固定延迟（一次或多次迭代）后的输出。</p><p> RNN主要被使用在上下文很重要的时候——即过去的迭代结果和样本产生的决策会对当前产生影响。最常见的上下文的例子是文本——一个单词只能在前面的单词或句子的上下文中进行分析。</p><p> <strong>循环神经网络</strong>很难训练，导致在实际应用中很难处理长距离的依赖。<strong>长短时记忆网络</strong>(成功解决了原始循环神经网络的缺陷，在语音识别、图片描述、自然语言处理等许多领域中成功应用。</p><p> LSTM长短时记忆网络引入了一个存储单元，一个特殊的单元，当数据有时间间隔（或滞后）时可以处理数据。</p><p> 存储单元实际上由一些元素组成，称为门，它们是递归性的，并控制信息如何被记住和遗忘。</p><p> <strong>LSTM</strong>的结构复杂</p><p> Autoncoder（AE）自动编码器，通过重建输入的神经网络训练过程，隐藏层向量具有降维的作用。特点是编码器会创建一个隐藏层（或多个隐藏层）包含了输入数据含义的低维向量。然后有一个解码器，会通过隐藏层的低维向量重建输入数据。</p><p> 帮助数据分类、可视化、存储。</p><h3 id="数据分析工具"><a href="#数据分析工具" class="headerlink" title="数据分析工具"></a>数据分析工具</h3><p> Excel</p><p> SPSS</p><p> Weka</p><p> 深度学习框架</p><ul><li>TensorFlow</li><li>Keras</li><li>PyTorch</li><li>Caffe</li><li>Deeplearning4j</li></ul><p> 深度学习框架是一种界面、库或工具，无需深入了解底层算法的细节的情况下，能够更容易、更快速地构建深度学习模型。</p><p> 深度学习框架利用预先构建和优化好的组件集合定义模型，为模型的实现提供了一种清晰而简洁的方法。</p><p> 一个良好的深度学习框架具备关键特征：</p><p> 优化的性能</p><p> 易于理解和编码</p><p> 良好的社区支持</p><p> 并行化的进程，以减少计算</p><p> 自动计算梯度</p><h1 id="第10章-数据可视化"><a href="#第10章-数据可视化" class="headerlink" title="第10章 数据可视化"></a>第10章 数据可视化</h1><h2 id="10-1-数据可视化概述"><a href="#10-1-数据可视化概述" class="headerlink" title="10.1 数据可视化概述"></a><strong>10.1</strong> 数据可视化概述</h2><p>数据可视化是指将大型数据集中的数据以图形图像形式表示，并利用数据分析和开发工具发现其中未知信息的处理过程。</p><p>基本思想是将数据库中每一个数据项作为单个图元素表示，大量的数据集构成数据图像，同时将数据的各个属性值以多维数据的形式表示，可以从不同的维度观察数据，从而对数据进行更深入的观察和分析。</p><p>雷达图是以从同一点开始的轴上表示的三个或更多个定量变量的二维图表的形式，显示多变量数据的图形方法。</p><p>依靠<strong>可视化手段进行数据分析</strong>可以<strong>让数据变得更加通俗易懂</strong>，有助于用户更加方便快捷地理解数据的深层次含义，有效参与复杂的数据分析过程，提升数据分析效率，改善数据分析效果。</p><p>可视化技术可以支持实现多种不同的目标：</p><ol><li><strong>观测、跟踪数据</strong></li><li><strong>分析数据</strong></li><li><strong>辅助理解数据</strong></li><li><strong>增强数据吸引力</strong></li></ol><p>可视化典型案例：</p><ul><li>安全供应商Norse打造了一张能够反映全球范围内黑客攻击频率的地图（<a href="http://map.ipviking.com),利用/">http://map.ipviking.com），利用</a> “蜜罐”攻击陷阱显示出所有实时渗透攻击活动。地图中的每一条线代表的都是一次攻击活动，借此可以了解每一天、每一分钟甚至每一秒世界上发生了多少次恶意渗透。</li></ul><p><img src="https://files.catbox.moe/b3htc4.png"></p><ul><li>2014年1月25日晚间，央视与百度合作，启用百度地图定位可视化大数据播报春节期间全国人口迁徙情况引起广泛关注。</li></ul><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16682386051231668238604428.png" style="zoom:67%;" /><ul><li>“世界国家健康与财富之间的关系”利用可视化技术，把世界上200个国家，从1810年到2010年历时200年其各国国民的健康、财富变化数据（收集了1千多万个数据）制作成三维动画进行了直观展示（<a href="http://www.moojnn.com/Index/whn%EF%BC%89%E3%80%82">http://www.moojnn.com/Index/whn）。</a></li></ul><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16682386411241668238640200.png" style="zoom:67%;" /><p>3D可视化是描绘和理解数据的一种手段，是数据的一种表征形式。3D可视化以一种独特的立体视角为用户呈现数据，可以帮助用户发现一些在2D模式下无法察觉的内容。</p><h2 id="大数据可视化方法"><a href="#大数据可视化方法" class="headerlink" title="大数据可视化方法"></a><strong>大数据可视化方法</strong></h2><h3 id="文本可视化"><a href="#文本可视化" class="headerlink" title="文本可视化"></a><strong>文本可视化</strong></h3><ol><li>文字是传递信息最常用的载体。</li><li>文本可视化的作用有以下四点：</li><li><strong>理解</strong> - 理解主旨</li><li><strong>组织</strong> - 组织、分类信息</li><li><strong>比较</strong> - 对比文档信息</li><li><strong>关联</strong> - 关联文本的 pattern 和其他信息</li></ol><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16682387551221668238754888.png" style="zoom: 50%;" /><p>•对文本的理解需求分成三级：词汇级（Lexical Level）、语法级（Syntactic Level）和语义级（Semantic Level）。词汇级用各类分词算法，语法级用一些句法分析算法，语义级用主题抽取算法。</p><p>•<strong>文本数据预处理</strong>将无效数据过滤，提取有效词等；<strong>文本特征抽取</strong>是指提取文本的关键词、词频分布、语法级的实体信息、语义级的主题等；<strong>文本特征的度量</strong>是指在多种环境或多个数据源所抽取的文本特征进行深层分析，如相似性、文本聚类等。</p><h4 id="文本可视化类型"><a href="#文本可视化类型" class="headerlink" title="文本可视化类型"></a>文本可视化类型</h4><p>•文本数据大致分为三种：单文本、文档集合和时序文本数据。对应的文本可视化也可分为三类：</p><ul><li>文本内容的可视化</li></ul><p>标签云（Word Clouds或Tag Clouds）是一种典型的文本可视化技术。将关键词根据词频或其他规则进行排序，按照一定规律进行布局排列，用大小、颜色、字体等图形属性对关键词进行可视化。一般用字号大小代表该关键词的重要性，该技术多用于快速识别网络媒体的主题热度。</p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16682391371211668239136903.png" style="zoom:50%;" /><p>•基于关键词的文本内容可视化</p><p>•文档散（DocuBurst ）也是基于关键词的文本可视化，不过它还通过径向布局体现了词的语义等级。如下图所示，外层的词是内层词的下义祠，颜色饱和度的深浅用来体现词频的高低。</p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16682391841301668239184076.png" style="zoom:50%;" /><p>•Document Cards</p><p>•文档卡片（Document Cards） 结合了文档中的关键词和关键图片进行可视化，布局在一张小卡片中。</p><p>其中的关键图片是指采用智能算法抽取并根据颜色分类后的代表性图片。</p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16682392451221668239244865.png" style="zoom:50%;" /><p>•时序文本内容可视化</p><p>•时序数据是指具有时间或顺序特性的文本，例如一篇小说故事情节的变化，或一个新闻事件随时间的演化。</p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16682392881871668239288148.png" style="zoom:50%;" /><p>•ThemeRiver主题河流是一种经典的时序文本可视化方法。光阴似水，用河流来隐喻时间的变化几乎所有人都能非常好地理解。</p><p>•横轴表示时间，每一条不同颜色线条视作一条河流，每条河流表示一个主题，河流的宽度代表在当前时间点上的一个度量（如主题的强度）。这样既可以在宏观上看出多个主题的发展变化，又能看出在特定时间点上主题的分布。</p><p>•TIARA结合了标签云，通过主题分析技术（latent dirichlet allocation，LDA），将文本关键词根据时间点放置在每条色带上，用词的大小表示关键词在该时刻出现的频率。TIARA帮助用户快速分析文本具体内容随时间变化的规律，而不是仅仅一个度量带变化。</p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16682393931241668239393076.png" style="zoom: 50%;" /><ul><li>文本关系的可视化</li></ul><p>•文本关系可视化：研究的是文本或文档集合中的关系信息，比如文本的相似性、互相引用的情况、链接等。说到关系布局，一般都是树或图。</p><p>•Word Tree单词树把文本中的句子按树形结构布局，可以很好的看出一个单词在文本中出现的频率和单词前后的联系。</p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16682394481251668239447570.png" style="zoom:50%;" /><ul><li>文本多层面信息的可视化</li></ul><p>•多层面或多维度是指从多个角度或提取多种特征对文本集合分析。</p><p>•Parallel Tag Clouds平行标签云结合了平行坐标和标签云视图。每一列是一个层面的标签云，然后连接的折线展现了选中标签在多个层面的分布。</p><h4 id="网络数据可视化"><a href="#网络数据可视化" class="headerlink" title="网络数据可视化"></a>网络数据可视化</h4><p>•网络数据，称作图数据，由节点（nodes）和边（edges）构成，用来描述实体间关系的一种结构</p><p>•实体：人、事、物</p><p>•例如：人与人之间的关系、城市之间的道路连接、科研论文之间的引用都组成了网络</p><p>•网络数据可视化常用方法：</p><p>•节点—链接法</p><p>相邻矩阵法</p><p>节点—链接法：节点表示对象，边表示节点之间的关系，如果图的每条边有方向，称为有向图（directed graph），如微博的关注就是有向的 如果图的每条边没有方向，称为无向图（undirected graph），如微信好友就是无向的</p><p>优点：最自然直接的表达方式，易于理解、接受</p><img src="https://files.catbox.moe/8u5kao.png" style="zoom:50%;" /><p>•节点—链接法的图简化</p><p>•在尽量不减少图信息的前提下，用最精简的图结构去表现数据背后的特征规律</p><p>•简化方法：基于节点；基于边；其它方法</p><p>•边绑定：在保持信息量不变的前提下，将图上互相靠近的边捆绑成一束，达到化繁为简的效果</p><p>•能够有效的减少在图绘制中边的混乱程度。能够提供给用户复杂连接图的全局概览，同时通过边的粗细与颜色深度也可以提供给用户图中主要连接关系的信息。</p><p>•相邻矩阵法</p><p>•N*N的矩阵，代表N个节点，矩阵内的位置(i, j)表达了第i个节点和第j个节点之间的关系</p><p>可以用数值矩阵，也可以将数值映射到色彩空间，表达简单易用； </p><p>节点之间的直接关系表达显著；</p><p>规避边的交叉<br> 缺点：</p><p>不易从相邻矩阵中挖掘去隐藏的 信息；节点之间的关系传递表达弱</p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16682397601301668239759623.png" style="zoom:50%;" /><h4 id="时空数据可视化"><a href="#时空数据可视化" class="headerlink" title="时空数据可视化"></a><strong>时空数据可视化</strong></h4><p>•时空数据是指具有时间元素并随时间变化而变化的空间数据，是描述地球环境中地物要素信息的一种表达方式。</p><p>•涉及到各式各样的数据，如地球环境地物要素的数量、形状、纹理、空间分布特征、内在联系及规律等的数字、文本、图形和图像等,不仅具有明显的空间分布特征，而且具有数据量庞大、非线性以及时变等特征。 </p><p>•时空数据的可视化表达手段可分为静态可视化和动态可视化。   </p><p>•时空数据静态可视化，一般是以二维地图上叠加可以描述时间变化的要素，来描述时空属性数据与空间范围内的变化特征。这些用于表达时空属性数据的要素可以通过不同的符号、注记、标绘符号、统计图表等多种方式来表达，也可以将多个时间的专题地图同时展示进行对比。    </p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16682398411301668239840912.png" style="zoom:50%;" /><p>•时空数据动态可视化表达 ：可采用动态地图、三维GIS等多种手段展现时空数据。将时空数据在动态变化的地图或三维场景中呈现出来，可以直观生动地表示各种空间信息的变化过程。</p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16682398751251668239874217.png" style="zoom:50%;" /><h4 id="多维数据可视化"><a href="#多维数据可视化" class="headerlink" title="多维数据可视化"></a><strong>多维数据可视化</strong></h4><p><strong>散点图</strong>（Scatter Plot）是最为常用的多维可视化方法。二维散点图将多个维度中的两个维度属性值集合映射至两条轴，在二维轴确定的平面内通过图形标记的不同视觉元素来反映其他维度属性值。</p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16682399601331668239959431.png" style="zoom:33%;" /><p><strong>投影</strong>是能够同时展示多维的可视化方法之一。VaR将各维度属性列集合通过投影函数映射到一个方块形图形标记中，并根据维度之间的关联度对各个小方块进行布局。</p><img src="https://fastly.jsdelivr.net/gh/Leevan001/pictureBed@main/utools/16682399941231668239993903.png" style="zoom:33%;" /><p><strong>平行坐标</strong>是研究和应用最为广泛的一种多维可视化技术，将维度与坐标轴建立映射，在多个平行轴之间以直线或曲线映射表示多维信息。</p><h2 id="可视化工具"><a href="#可视化工具" class="headerlink" title="可视化工具"></a><strong>可视化</strong>工具</h2><h3 id="信息图表工具"><a href="#信息图表工具" class="headerlink" title="信息图表工具"></a><strong>信息图表工具</strong></h3><p><strong>Excel</strong></p><p><strong>Google Chart API</strong></p><p><strong>Echarts</strong></p><p><strong>D3</strong></p><p><strong>Visual.ly</strong></p><p><strong>Tableau</strong></p><p>大数据魔镜是一款优秀的国产数据分析软件，丰富的数据公式和算法可以让用户真正理解探索分析数据，用户只要通过一个直观的拖放界面就可创造交互式的图表和数据挖掘模型。</p><h3 id="地图工具"><a href="#地图工具" class="headerlink" title="地图工具"></a>地图工具</h3><p>地图工具在数据可视化中较为常见，在展现数据基于空间或地理分布上有很强的表现力，可以直观地展现各分析指标的分布、区域等特征。</p><p>当指标数据要表达的主题跟地域有关联时，可以选择以地图作为大背景，从而帮助用户更加直观地了解整体的数据情况，同时也可以根据地理位置快速地定位到某一地区来查看详细数据。</p><p><strong>1. Google Fusion Tables</strong></p><p>让一般使用者也可以轻松制作出专业的统计地图。该工具可以让数据表呈现为图表、图形和地图，帮助发现一些隐藏在数据背后的模式和趋势。</p><p> <strong>2. Modest Maps</strong></p><p>是一个小型、可扩展、交互式的免费库，提供了一套查看卫星地图的API，只有10KB大小，是目前最小的可用地图库，开源项目，有强大的社区支持，是在网站中整合地图应用的理想选择。</p><p> <strong>3. Leaflet</strong></p><p>Leaflet是一个小型化的地图框架，通过小型化和轻量化来满足移动网页的需要。</p><h3 id="时间线工具"><a href="#时间线工具" class="headerlink" title="时间线工具"></a>时间线工具</h3><p>时间线是表现数据在时间维度的演变的有效方式，通过互联网技术，依据时间顺序，把一方面或多方面的事件串联起来，形成相对完整的记录体系，再运用图文的形式呈现给用户。</p><p>TimetoastXtimelineGephi</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
